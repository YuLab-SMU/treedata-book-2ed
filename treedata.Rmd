---
title: 'Data Integration, Manipulation and Visualization of Phylogenetic Trees'
author: Guangchuang Yu
date: "`r Sys.Date()`"
knit: "bookdown::render_book"
site: bookdown::bookdown_site
header-includes:
  - \usepackage{makeidx}
  - \makeindex
documentclass: book
classoption: numberinsequence,twoside
bibliography: references.bib
csl: apa.csl
always_allow_html: yes
toc_appendix: yes
toc-depth: 2
link-citations: yes
colorlinks: false
language:
  ui:
    chapter_name: "Chapter "
lot: yes
lof: yes
fontsize: 11pt
monofont: "Source Code Pro"
monofontoptions: "Scale=0.7"
github-repo: YuLab-SMU/treedata-book
twiter-handle: guangchuangyu
description: "Master ggtree package suite to handle tree with data."
highlight_bw: yes
graphics: yes
#papersize: a4
geometry: "left=35mm,right=35mm,top=25mm,bottom=25mm"
cover-image: book-cover.png
---


```{r include=FALSE}
source("setup.R")

options(
  htmltools.dir.version = FALSE, formatR.indent = 2, width = 55, digits = 4
)

options(tinytex.clean = FALSE)

## manual setting. the ropenscilabs/icons package will set up everything for you.
## fontawesome supports
## htmltools::tagList(rmarkdown::html_dependency_font_awesome())
## icons::download_fontawesome()

library(knitr)
#knit_hooks$set(crop = hook_pdfcrop)

opts_chunk$set(message=FALSE, warning=FALSE, eval=TRUE, 
            echo=TRUE, cache=TRUE, out.width="98%",
            fig.process=svg2png)

if (knitr::is_latex_output()) {
    opts_chunk$set(dev = "cairo_pdf")
} else {
    opts_chunk$set(dev = "svg")
}

```




<!--
# Welcome {-}

<img class="cover" src="book-cover.png" width="210" height="297" /> This is the online work-in-progress book of "Data Integration, Manipulation and Visualization of Phylogenetic Trees". This book gives your all the details of using the ggtree package suite to handle tree with data. The book is written by Guangchuang Yu.


<center>
<img src="book-cover.png" style="width:500px;border:2px solid black;"/>
</center>

-->

\newpage
\frontmatter
# Preface {-}


```{asis, echo=identical(knitr:::pandoc_to(), 'html')}
**Note**: This book has been published by [Chapman & Hall/CRC](https://www.routledge.com/Data-Integration-Manipulation-and-Visualization-of-Phylogenetic-Trees/Yu/p/book/9781032233574). The online version of this book is free to read here (thanks to Chapman & Hall/CRC), and licensed under the [Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License](http://creativecommons.org/licenses/by-nc-sa/4.0/).
<p style="text-align: center;"><a href="https://www.routledge.com/Data-Integration-Manipulation-and-Visualization-of-Phylogenetic-Trees/Yu/p/book/9781032233574"><img src="https://yulab-smu.top/treedata-book/9781032233574_cover_review.png" alt="The ggtree book cover" /></a></p>
```



I am so excited to have this book published. The book is meant as a guide for data integration, manipulation and visualization of phylogenetic trees using a suite of R packages, `r CRANpkg("tidytree")`, `r Biocpkg("treeio")`, `r Biocpkg("ggtree")` and `r Biocpkg("ggtreeExtra")`. Hence, if you are starting to read this book, we assume you have a working knowledge of how to use R and `r CRANpkg("ggplot2")`. 

The development of the `r Biocpkg("ggtree")` package started during my PhD study at the University of Hong Kong. I joined the State Key Laboratory of Emerging Infectious Diseases (SKLEID) under the supervision of Yi Guan and Tommy Lam. I was asked to provide assistance to modify the newick tree string to incorporate some additional information, such as amino acid substitutions, in the internal node labels of the phylogeny for visualization. I wrote an R script to do it and soon realized that most phylogenetic tree visualization software can only display one type of data through node labels. Basically, we cannot display two data variables at the same time for comparative analysis. In order to produce tree graphs displaying different types of branch/node associated information, such as bootstrap values and substitutions, people mostly relied on post-processing image software. This situation motivates me to develop `r Biocpkg("ggtree")`. First of all, I think a good user interface must fully support the `r CRANpkg("ggplot2")` syntax, which allows us to draw graphs by superimposing layers. In this way, simple graphs are simple, and complex graphs are just a combination of simple layers, which are easy to generate. 

After several years of development, `r Biocpkg("ggtree")` has evolved into a package suite, including `r CRANpkg("tidytree")` for manipulating tree with data using the tidy interface; `r Biocpkg("treeio")` for importing and exporting tree with richly annotated data; `r Biocpkg("ggtree")` for tree visualization and annotation and `r Biocpkg("ggtreeExtra")` for presenting data with a phylogeny side-by-side for a rectangular layout or in outer rings for a circular layout. The `r Biocpkg("ggtree")` is a general tool that supports different types of tree and tree-like structures and can be applied to different disciplines to help researchers presenting and interpreting data in the evolutionary or hierarchical context. 


## Structure of the book {-}


+ Part I (Tree data input, output and manipulation) describes `r Biocpkg("treeio")` package for tree data input and output, and `r CRANpkg("tidytree")` package for tree data manipulation.
+ Part II (Tree data visualization and annotation) introduces tree visualization and annotation using the grammar of graphic syntax implemented in the `r Biocpkg("ggtree")` package. It emphasizes presenting tree-associated data on the tree.
+ Part III (ggtree extensions) introduces `r Biocpkg("ggtreeExtra")` for presenting data on circular layout trees and other extensions including `r Biocpkg("MicrobiotaProcess")` and `r Biocpkg("tanggle")` *etc*.
+ Part IV (Miscellaneous topics) describes utilities provided by the `r Biocpkg("ggtree")` package suite and presents a set of reproducible examples.


```{r, child="software-info.md"}
```

## Acknowledgments {-}

Many people have contributed to this book with spelling and grammar corrections. I'd particularly like to thank Shuangbin Xu, Lin Li and Xiao Luo for their detailed technical reviews of the book, and Tiao You for designing the front cover of the book. 

Many others have contributed during the development of the `r Biocpkg("ggtree")` package suite. I would like to thank Hadley Wickham, for creating the `r CRANpkg("ggplot2")` package that `r Biocpkg("ggtree")` relies on; Tommy Tsan-Yuk Lam and Yi Guan for being great advisors and supporting the development of `r Biocpkg("ggtree")` during my PhD; Richard Ree for inviting me to catalysis meeting on phylogenetic tree visualization; William Pearson for inviting me to publish a protocol paper of `r Biocpkg("ggtree")` in the *Current Procotols in Bioinformatics* journal; Shuangbin Xu, Yonghe Xia, Justin Silverman, Bradley Jones, Watal M. Iwasaki, Ruizhu Huang, Casey Dunn, Tyler Bradley, Konstantinos Geles, Zebulun Arendsee and many others who have contributed source code or given me feedback; and last, but not least, the members of the `r Biocpkg("ggtree")` mailing list^[<https://groups.google.com/forum/#!forum/bioc-ggtree>], for providing many challenging problems that have helped improve the `r Biocpkg("ggtree")` package suite. 

<!--chapter:end:index.Rmd-->

\newpage
\frontmatter
# About the Author {#author .unnumbered}

**Guangchuang Yu** (https://yulab-smu.top) is a professor of Bioinformatics and director of the Department of Bioinformatics at Southern Medical University. He earned his Ph.D. from the School of Public Health, The University of Hong Kong. As an active R user, he has authored several R packages, such as `r CRANpkg("aplot")`, `r CRANpkg("badger")`, `r Biocpkg("ChIPseeker")`, `r Biocpkg("clusterProfiler")`, `r Biocpkg("DOSE")`, `r CRANpkg("emojifont")`, `r Biocpkg("enrichplot")`, `r CRANpkg("ggbreak")`, `r CRANpkg("ggfun")`, `r CRANpkg("ggimage")`, `r CRANpkg("ggplotify")`, `r Biocpkg("ggtree")`, `r Biocpkg("GOSemSim")`, `r CRANpkg("hexSticker")`, `r CRANpkg("meme")`, `r Biocpkg("meshes")`, `r CRANpkg("nCov2019")`, `r CRANpkg("plotbb")`, `r Biocpkg("ReactomePA")`, `r CRANpkg("scatterpie")`, `r CRANpkg("seqmagick")`, `r Biocpkg("seqcombo")`, `r CRANpkg("shadowtext")`, `r CRANpkg("tidytree")` and `r Biocpkg("treeio")`. He has supervised post-graduate students to develop a few other packages, including `r Biocpkg("ggmsa")`, `r Biocpkg("ggtreeExtra")`, `r Biocpkg("MicrobiomeProfiler")` and `r Biocpkg("MicrobiotaProcess")`. 


His research group aims to generate new insights into human health and disease through the development of new software tools and novel analysis of biomedical data. The software package developed by his research group helps biologists analyze data and reveal biological clues hidden in the data. 


He has published several journal articles, including 5 highly cited papers [@yu2012; @yu_dose_2015; @yu_chipseeker:_2015; @yu_reactomepa_2016; @yu_ggtree:_2017]. The articles have been cited more than 10,000 times. The ggtree [@yu_ggtree:_2017] paper was selected as a feature article to celebrate the 10^th^ anniversary of the launch of _Methods in Ecology and Evolution_^[10th Anniversary Volume 8: Phylogenetic tree visualization with multivariate data: <https://methodsblog.com/2020/11/19/ggtree-tree-visualization/>]. He was one of the 2020 Highly Cited Chinese Researchers (Elsevier-Scopus) in Biomedical Engineering.



<!--chapter:end:00_author.Rmd-->

\mainmatter


# (PART\*) Part I: Tree data input, output, and manipulation {-}

\newpage

# Importing Tree with Data {#chapter1}



```{r echo=FALSE, results="hide", message=FALSE}
library(tidyr)
library(dplyr)
library(tidytree)
library(ggplot2)

library("treeio")
```

## Overview of Phylogenetic Tree Construction {#pc}


Phylogenetic trees are used to describe genealogical relationships among a group of organisms, which can be constructed based on the genetic sequences of the organisms. A rooted phylogenetic tree represents a model of evolutionary history depicted by ancestor-descendant relationships between tree nodes and clustering of `r squote('sister')` or `r squote('cousin')` organisms at a different level of relatedness, as illustrated in Figure \@ref(fig:phylogeny). In infectious disease research, phylogenetic trees are usually built from the pathogens' gene or genome sequences to show which pathogen sample is genetically closer to another sample, providing insights into the underlying unobserved epidemiologic linkage and the potential source of an outbreak.

(ref:phylogenyscap) Components of a phylogenetic tree.

(ref:phylogenycap) **Components of a phylogenetic tree.** External nodes (green circles), also called `r squote("tips")`, represent actual organisms sampled and sequenced (*e.g.*, viruses in infectious disease research). They are the `r squote("taxa")` in the terminology of evolutionary biology. The internal nodes (blue circles) represent hypothetical ancestors for the tips. The root (red circle) is the common ancestor of all species in the tree. The horizontal lines are branches and represent evolutionary changes (gray number) measured in a unit of time or genetic divergence. The bar at the bottom provides the scale of these branch lengths. 

```{r phylogeny, message=FALSE, echo=F, fig.width=6, fig.height=4, fig.cap='(ref:phylogenycap)', fig.scap='(ref:phylogenyscap)', out.extra=''}
require(ggtree)
set.seed(2017-04-22)
tr <- rtree(10)
p <- ggtree(tr) + 
  geom_nodepoint(color='#619CFF', size=3) + 
  geom_rootpoint(size=3, color='#F8766D') + 
  geom_tippoint(color='#00BA38', size=3) +
  geom_text2(aes(subset=(node != parent), 
                 label=round(branch.length, 2), x=branch), 
             vjust=-.5, color='grey50', size=3) + geom_treescale() 

d <- p$data
i <- d$isTip
d$label[i][order(d$y[i],decreasing=F)] <- paste0('virus', 10:1)
p$data <- d
p + geom_tiplab(offset = .05, size=4.5) + xlim(NA,4)
```

A phylogenetic tree can be constructed from genetic sequences using distance-based methods or character-based methods. Distance-based methods, including the unweighted pair group method with arithmetic means (UPGMA\index{UPGMA}) and the Neighbor-joining (NJ\index{NJ}), are based on the matrix of pairwise genetic distances calculated between sequences. The character-based methods, including maximum parsimony\index{maximum parsimony} (MP) [@fitch_toward_1971], maximum likelihood\index{maximum likelihood} (ML) [@felsenstein_evolutionary_1981], and Bayesian\index{Bayesian} Markov Chain Monte Carlo\index{Markov Chain Monte Carlo} (BMCMC) method [@rannala_probability_1996], are based on a mathematical model that describes the evolution of genetic characters and searches for the best phylogenetic tree according to their optimality criteria.


The MP method assumes that the evolutionary change is rare and minimizes the amount of character-state changes (*e.g.*, number of DNA substitutions). The criterion is similar to Occam's razor, that the simplest hypothesis that can explain the data is the best hypothesis. Unweighted parsimony assumes mutations across different characters (nucleotides or amino acids) are equally likely, while the weighted method assumes the unequal likelihood of mutations (*e.g.*, the third codon position is more liable than other codon positions; and the transition mutations have a higher frequency than transversion). The concept of the MP method is straightforward and intuitive, which is a probable reason for its popularity amongst biologists who care more about the research question rather than the computational details of the analysis. However, this method has several disadvantages, in particular, the tree inference can be biased by the well-known systematic error called long-branch attraction (LBA\index{LBA}) that incorrectly infer distantly related lineages as closely related [@felsenstein_cases_1978]. This is because the MP method poorly takes into consideration of many sequence evolution factors (*e.g.*, reversals and convergence) that are hardly observable from the existing genetic data.

The maximum likelihood (ML) method and Bayesian Markov Chain Monte Carlo (BMCMC) method are the two most commonly used methods in phylogenetic tree construction and are most often used in scientific publications. ML and BMCMC methods require a substitution model of sequence evolution. Different sequence data have different substitution models to formulate the evolutionary process of DNA, codon and amino acid. There are several models for nucleotide substitution, including JC69\index{JC69}, K2P\index{K2P}, F81\index{F81}, HKY\index{HKY}, and GTR\index{GTR} [@arenas_trends_2015]. These models can be used in conjunction with the rate variation across sites (denoted as +$\Gamma$)) [@yang_maximum_1994] and the proportion of invariable sites (denoted as +I) [@shoemaker_evidence_1989]. Previous research [@lemmon_importance_2004] had suggested that misspecification of substitution model might bias phylogenetic inference. Procedural testing for the best-fit substitution model is recommended.


The optimal criterion of the ML method is to find the tree that maximizes the likelihood given the sequence data. The procedure of the ML method is simple: calculating the likelihood of a tree and optimizing its topology and branches (and the substitution model parameters, if not fixed) until the best tree is found. Heuristic search, such as those implemented in `r pkg_phyml` and `r pkg_raxml`, is often used to find the best tree based on the likelihood criterion. The Bayesian method finds the tree that maximizes posterior probability by sampling trees through MCMC based on the given substitution model. One of the advantages of BMCMC is that parameter variance and tree topological uncertainty, included by the posterior clade probability, can be naturally and conveniently obtained from the sampling trees in the MCMC process. Moreover, the influence of topological uncertainty on other parameter estimates is also naturally integrated into the BMCMC phylogenetic framework.

In a simple phylogenetic tree, data associated with the tree branches/nodes could be the branch lengths (indicating genetic or time divergence) and lineage supports such as bootstrap values estimated from bootstrapping procedure or posterior clade probability summarized from the sampled trees in the BMCMC analysis.




## Phylogenetic Tree Formats {#format}


There are several file formats designed to store phylogenetic trees and the data associated with the nodes and branches. The three commonly used formats are Newick^[http://evolution.genetics.washington.edu/phylip/newick_doc.html], NEXUS [@maddison_nexus:_1997], and Phylip [@felsenstein_phylip_1989]. Some formats (*e.g.*, NHX) are extended from the Newick\index{Newick} format. Newick and NEXUS formats are supported as input by most of the software in evolutionary biology, while some of the software tools output newer standard files (*e.g.*, `r pkg_beast` and `r pkg_mrbayes`) by introducing new rules/data blocks for storing evolutionary inferences. In the other cases (*e.g.*, `r pkg_paml` and `r pkg_r8s`), output log files are only recognized by their own single software.


### Newick tree format 

The Newick\index{Newick} tree format is the standard for representing trees in computer-readable form. 


(ref:randomTreescap) A sample tree for demonstrating Newick text to encode tree structure.

(ref:randomTreecap) **A sample tree for demonstrating Newick text to encode tree structure.** Tips were aligned to the right-hand side and branch lengths were labeled on the middle of each branch.

```{r randomTree, message=FALSE, warning=F, fig.height=3.5, echo=FALSE, fig.cap="(ref:randomTreecap)", fig.scap="(ref:randomTreescap)", out.extra=''}
library(Biostrings)
library(ape)
library(phytools)
library(ggtree)
library(dplyr)
library(tidyr)
library(stringr)
linewidth <- 60
set.seed(2016-11-08)
tr <- roundBranches(rtree(5), 2)
ggtree(tr, size=1.5) + geom_tiplab(align=T, size=8, linesize=.8) + geom_label2(aes(subset=node != parent, x=branch, label=branch.length))
```

The rooted tree shown in Figure \@ref(fig:randomTree) can be represented by the following sequence of characters as a Newick tree text.

```{r message=FALSE, echo=FALSE, comment=""}
cat(write.tree(tr), '\n')
```

```{r siblingNodes, echo=FALSE}
i <- parent(tr, nodeid(tr, 't1')) # parent node of t1
tr2 <- tree_subset(tr, i, levels_back=0)
tr2$root.edge <- NULL
siblingNodes <- sub(";", "", write.tree(tr2))
```

The tree text ends with a semicolon. Internal nodes are represented by a pair of matched parentheses. Between the parentheses are descendant nodes of that node. For instance `r siblingNodes` represents the parent node of `r tr2$tip.label[1]` and `r tr2$tip.label[2]` that are the immediate descendants. Sibling nodes are separated by a comma and tips are represented by their names. A branch length (from the parent node to child node) is represented by a real number after the child node and is preceded by a colon. Singular data (*e.g.*, bootstrap values) associated with internal nodes or branches may be encoded as node labels and represented by the simple text/numbers before the colon.


Newick tree format was developed by Meacham in 1984 for the Phylogeny Inference Package or `r pkg_phylip` [@retief_phylogenetic_2000] package. Newick format is now the most widely used tree format and used by `r pkg_phylip`, `r pkg_paup` [@wilgenbusch_inferring_2003], *TREE-PUZZLE* [@schmidt_tree-puzzle:_2002], `r pkg_mrbayes`, and many other applications. Phylip tree format contains Phylip multiple sequence alignment (MSA) with a corresponding Newick tree text that was built based on the MSA sequences in the same file.

### NEXUS tree format

The NEXUS\index{NEXUS} format [@maddison_nexus:_1997] incorporates Newick tree text with related information organized into separated units known as **blocks**. A NEXUS block has the following structure:


```
#NEXUS
...
BEGIN characters;
...
END;
```

For example, the above example tree can be saved as the following NEXUS format:

```{r message=FALSE, echo=FALSE, eval=TRUE, comment=NA}
aa = capture.output(write.nexus(tr))
i = grep("^\tTREE", aa)
aa[i] = yulab.utils::str_wrap(aa[i], 60)
cat(aa, sep="\n")
```



Comments can be placed using square brackets. Some blocks can be recognized by most of the programs including `TAXA` (contains information of taxa), `DATA` (contains data matrix, *e.g.*, sequence alignment), and `TREE` (contains a phylogenetic tree, *i.e.*, Newick tree text). Notably, blocks can be very diverse and some of them are only recognized by one particular program. For example NEXUS file exported by `r pkg_paup` has a *paup* block that contains *PAUP\** commands, whereas `r pkg_figtree` exports the NEXUS file with a *figtree* block that contains visualization settings. NEXUS organizes different types of data into different blocks, whereas programs that support reading NEXUS can parse some blocks they recognized and ignore those they could not. This is a good mechanism to allow different programs to use the same format without crashing when unsupported types of data are present. Notably, most of the programs only support parsing `TAXA`, `DATA`, and `TREE` blocks; therefore, a program/platform that could generically read all kinds of data blocks from the NEXUS would be useful for phylogenetic data integration.

The `DATA` block is widely used to store sequence alignment. For this purpose, the user can store tree and sequence data in Phylip format which are essentially Phylip multiple sequence alignment and Newick tree text, respectively. It is used in `r pkg_phylip`. 

<!-- 

~~and it's also a drawback of NEXUS for most of the software can only parse the tree strucuture without support of the associated data. NEXUS is good for storing specific information for particular program, it can be used for storing annotated trees.~~

It is very difficult to share tree annotation data among different programs unless the data is a matrix which can be stored in `DATA` block. The `DATA` block is widely used to store sequence alignment. For this purpose, user can store tree in Phylip format which was used in `r pkg_phylip` package and can contains Phylip multiple sequence alignment with Newick tree text.

-->


### New Hampshire eXtended format {#nhxtext}

<!-- Although NEXUS supports additional information in separated blocks, they are mostly not recognized by different software and can't share information among different programs. In order to store annotated tree,-->

Newick, NEXUS, and phylip are mainly designed to store phylogenetic trees and basic singular data associated with internal nodes or branches. In addition to the singular data annotation at branches and nodes (mentioned above), New Hampshire eXtended (NHX\index{NHX}) format, which is based on Newick (also called New Hampshire), was developed to introduce tags to associate multiple data fields with the tree nodes (both internal nodes and tips). Tags are placed after branch length and must be wrapped between `[&&NHX` and `]` which makes it possible to be compatible with NEXUS format as it defined characters between `[` and `]` as comments. NHX is also the output format of `r pkg_phyldog` [@boussau_genome-scale_2013] and `r pkg_revbayes` [@hohna_revbayes:_2016]. A Tree Viewer (`r pkg_atv`) [@zmasek_atv:_2001] is a java tool that supports displaying annotation data stored in NHX format, but this package is no longer maintained.

Here is a sample tree from NHX definition document^[http://www.genetics.wustl.edu/eddy/forester/NHX.html]:

```{r echo=FALSE, eval=FALSE, comment=NA}
x <- "(((ADH2:0.1[&&NHX:S=human], ADH1:0.11[&&NHX:S=human]):0.05[&&NHX:S=primates:D=Y:B=100],ADHY:0.1[&&NHX:S=nematode],ADHX:0.12[&&NHX:S=insect]):0.1[&&NHX:S=metazoa:D=N],(ADH4:0.09[&&NHX:S=yeast],ADH3:0.13[&&NHX:S=yeast], ADH2:0.12[&&NHX:S=yeast],ADH1:0.11[&&NHX:S=yeast]):0.1[&&NHX:S=Fungi])[&&NHX:D=N];"
cat(str_wrap(x, linewidth))
```

```{r echo=FALSE, comment=NA}
x <- c("(((ADH2:0.1[&&NHX:S=human], ADH1:0.11[&&NHX:S=human]):0.05",
    "[&&NHX:S=primates:D=Y:B=100],ADHY:0.1[&&NHX:S=nematode],",
    "ADHX:0.12[&&NHX:S=insect]):0.1[&&NHX:S=metazoa:D=N],(ADH4:0.09",
    "[&&NHX:S=yeast],ADH3:0.13[&&NHX:S=yeast],ADH2:0.12[&&NHX:S=yeast],",
    "ADH1:0.11[&&NHX:S=yeast]):0.1[&&NHX:S=Fungi])[&&NHX:D=N];"
    )
writeLines(x)
```

### Jplace format 

To store the Next Generation Sequencing (NGS) short reads mapped onto a phylogenetic tree (for metagenomic classification), Matsen [@matsen_format_2012] proposed jplace\index{jplace} format for such phylogenetic placements. Jplace format is based on JSON and contains four keys: `tree`, `fields`, `placements`, `metadata`, and `version`. The `tree` value contains tree text extended from Newick tree format by putting the edge label in brackets (if available) after branch length and putting the edge number in curly braces after the edge label. The `fields` value contains header information of placement data. The value of `placements` is a list of `pqueries`. Each `pquery` contains two keys: `p` for placements and `n` for name or `nm` for names with multiplicity. The value of `p` is a list of placement for `pqueries`.

Here is a jplace sample file:


```
{
	"tree": "(((((((A:4{1},B:4{2}):6{3},C:5{4}):8{5},D:6{6}):
	3{7},E:21{8}):10{9},((F:4{10},G:12{11}):14{12},H:8{13}):
	13{14}):13{15},((I:5{16},J:2{17}):30{18},(K:11{19},
	L:11{20}):2{21}):17{22}):4{23},M:56{24});",
	"placements": [
	{"p":[24, -61371.300778, 0.333344, 0.000003, 0.003887], 
	 "n":["AA"]
	},
	{"p":[[1, -61312.210786, 0.333335, 0.000001, 0.000003],
	      [2, -61322.210823, 0.333322, 0.000003, 0.000003],
	      [3, -61352.210823, 0.333322, 0.000961, 0.000003]],
	 "n":["BB"]
	},
	{"p":[[8, -61312.229128, 0.200011, 0.000001, 0.000003],
	      [9, -61322.229179, 0.200000, 0.000003, 0.000003],
	      [10, -61342.229223, 0.199992, 0.000003, 0.000003]], 
	"n":["CC"]
	}
	],
	"metadata": {"info": "a jplace sample file"},
	"version" : 2,
	"fields": ["edge_num", "likelihood", "like_weight_ratio", 
	"distal_length", "pendant_length"
	]
}
```


Jplace is the output format of `r pkg_pplacer`\index{pplacer} [@matsen_pplacer_2010] and Evolutionary Placement Algorithm (`r pkg_epa`\index{EPA}) [@berger_performance_2011]. But these two programs do not contain tools to visualize placement results. `r pkg_pplacer` provides `placeviz` to convert jplace file to phyloXML\index{phyloXML} or Newick formats which can be visualized by `r pkg_archaeopteryx`. 

### Software outputs

`r pkg_raxml`\index{RAxML} [@stamatakis_raxml_2014] can output Newick format by storing the bootstrap values as internal node labels. Another way that `r pkg_raxml` supports is to place bootstrap value inside square brackets and after branch length. This could not be supported by most of the software that supports Newick format where square brackets will be ignored. 

`r pkg_beast`\index{BEAST} [@bouckaert_beast_2014] output is based on NEXUS, and it also introduces square brackets in the tree block to store evolutionary evidence inferred by `r pkg_beast`. Inside brackets, curly braces may also be incorporated if feature values have a length of more than 1 (*e.g.*, Highest Probability Density (HPD) or range of substitution rate). These brackets are placed between node and branch length (*i.e.*, after label if exists and before the colon). The bracket is not defined in Newick format and is a reserved character for NEXUS comment. So this information will be ignored for standard NEXUS parsers. 


Here is a sample `TREE` block of the `r pkg_beast` output:


```{r echo=FALSE, comment=NA, eval=FALSE}
f <- system.file("extdata/BEAST/beast_mcc.tree", package="treeio")
x <- readLines(f)
tr <- x[42]
tr <- gsub("\\[[^\\[]+(length=\\d+\\.\\d)[^\\[]*\\]", "[&\\1]", tr)
tr <- gsub("(:\\d+\\.\\d{2})\\d*,", "\\1,", tr)
#w <- 80
#ii <- 1:floor(nchar(tr)/w)* w
#start <- c(1, ii+1)
#end <- c(ii, nchar(tr))
#x <- c(x[1:41],
#      substring(tr, start, end),
#      x[43:length(x)])
#cat(paste0(x, collapse="\n"))
cat(str_wrap(tr, linewidth))

## new version, more robust

y <- read.beast.newick(textConnection(tr))
y@phylo$edge.length = round(y@phylo$edge.length, 2)
y@data=y@data[c('node', 'length')]
y@data$length <- round(y@data$length, 2)
write.beast(y, translate=F)

```

```{r echo=FALSE, comment=NA}

x <- c("TREE * TREE1 = [&R] (((11[&length=9.47]:9.39,14[&length=6.47]:6.39)",
  "[&length=25.72]:25.44,4[&length=9.14]:8.82)[&length=3.01]:3.1,",
  "(12[&length=0.62]:0.57,(10[&length=1.6]:1.56,(7[&length=5.21]:5.19,",
  "((((2[&length=3.3]:3.26,(1[&length=1.34]:1.32,(6[&length=0.85]:0.83,",
  "13[&length=0.85]:0.83)[&length=2.5]:2.49)[&length=0.97]:0.94)",
  "[&length=0.5]:0.5,9[&length=1.76]:1.76)[&length=2.41]:2.36,",
  "8[&length=2.19]:2.11)[&length=0.27]:0.24,(3[&length=3.33]:3.31,",
  "(15[&length=5.29]:5.27,5[&length=3.29]:3.27)[&length=1.04]:1.04)",
  "[&length=1.98]:2.04)[&length=2.83]:2.84)[&length=5.39]:5.37)",
  "[&length=2.02]:2)[&length=4.35]:4.36)[&length=0];")

writeLines(x)
```


`r pkg_beast` output can contain many different evolutionary inferences, depending on the analysis models defined in *BEAUTi* for running. For example in molecular clock analysis, it contains `rate`, `length`, `height`, `posterior` and corresponding HPD and range for uncertainty estimation. `Rate` is the estimated evolutionary rate of the branch. `Length` is the length of the branch in years. `Height` is the time from node to root, while `posterior` is the Bayesian clade credibility value. The above example is the output tree of a molecular clock analysis and should contain these inferences. To save space, only the `length` estimation was shown above. Besides, Molecular Evolutionary Genetics Analysis (`r pkg_mega`) [@kumar_mega7_2016] also supports exporting trees in `r pkg_beast` compatible Nexus format (see [session 1.3.2](#mega)). 

*`r pkg_mrbayes`*\index{MrBayes} [@huelsenbeck_mrbayes_2001] is a program that uses the Markov Chain Monte Carlo\index{Markov Chain Monte Carlo} method to sample from the posterior probability distributions. Its output file annotates nodes and branches separately by two sets of square brackets. For example below, posterior clade probabilities for the node and branch length estimates for the branch:


```{r echo=F, eval=F, comment=NA}
f <- system.file("extdata/MrBayes/Gq_nxs.tre", package="treeio")
x <- readLines(f)
tr <- x[36]
tr <- gsub("\\[[^\\[]+(prob=\\d+\\.\\d)[^\\[]*\\]:", "[&\\1]:", tr) 
tr <- gsub("\\[[^\\[]+(length_mean=[^,]+)[^\\[]*\\]([,\\)]{1})", "[&\\1]\\2", tr)
tr <- gsub("\\[[^\\[]+(prob=\\d+\\.\\d)[^\\[]*\\]\\[", "[&\\1]\\[", tr)
tr <- gsub("\\[[^\\[]+(length_mean=[^,]+)[^\\[]*\\];", "[&\\1];", tr)

tr <- gsub("(\\[&length_mean=\\d+\\.\\d)\\d*(e-)0*([1-9]+)\\]", "[&\\1\\2\\3]", tr)
tr <- gsub("(\\[&length_mean=0)\\.0+e\\+0+\\]", "[&\\1]", tr)
tr <- gsub("e-0*", "e-", tr)
tr <- gsub("\\[&\\[&", "[&", tr)
tr <- gsub("(:\\d+\\.\\d{2})\\d*([e\\,\\[]{1})", "\\1\\2", tr)

#w <- 80
#ii <- 1:floor(nchar(tr)/w)* w
#start <- c(1, ii+1)
#end <- c(ii, nchar(tr))
#x <- c(x[1:35],
#      substring(tr, start, end),
#      x[37:length(x)])
#cat(paste0(x, collapse="\n"))
cat(str_wrap(tr, linewidth))
```

```{r echo=FALSE, comment=NA}
x <- c("  tree con_all_compat = [&U] (8[&prob=1.0]:2.94e-1[&length_mean=2.9e-1],",
  "10[&prob=1.0]:2.25e-1[&length_mean=2.2e-1],((((1[&prob=1.0]:1.43e-1",
  "[&length_mean=1.4e-1],2[&prob=1.0]:1.92e-1[&length_mean=1.9e-1])[&prob=1.0]:",
  "1.24e-1[&length_mean=1.2e-1],9[&prob=1.0]:2.27e-1[&length_mean=2.2e-1])",
  "[&prob=1.0]:1.72e-1[&length_mean=1.7e-1],12[&prob=1.0]:5.11e-1",
  "[&length_mean=5.1e-1])[&prob=1.0]:1.76e-1[&length_mean=1.7e-1],",
  "(((3[&prob=1.0]:5.46e-2[&length_mean=5.4e-2],(6[&prob=1.0]:1.03e-2",
  "[&length_mean=1.0e-2],7[&prob=1.0]:7.13e-3[&length_mean=7.2e-3])[&prob=1.0]:",
  "6.93e-2[&length_mean=6.9e-2])[&prob=1.0]:6.03e-2[&length_mean=6.0e-2],",
  "(4[&prob=1.0]:6.27e-2[&length_mean=6.2e-2],5[&prob=1.0]:6.31e-2",
  "[&length_mean=6.3e-2])[&prob=1.0]:6.07e-2[&length_mean=6.0e-2])[&prob=1.0]:,",
  "1.80e-1[&length_mean=1.8e-1]11[&prob=1.0]:2.37e-1[&length_mean=2.3e-1])",
  "[&prob=1.0]:4.05e-1[&length_mean=4.0e-1])[&prob=1.0]:1.16e+000",
  "[&length_mean=1.162699558201079e+000])[&prob=1.0][&length_mean=0];")

writeLines(x)
```


To save space, most of the inferences were removed and only contains `prob` for clade probability and `length_mean` for mean value of branch length. The full version of this file also contains `prob_stddev`, `prob_range`, `prob(percent)`, `prob+-sd` for probability inferences and `length_median`, `length_95%_HPD` for every branch.

The `r pkg_beast` and `r pkg_mrbayes` outputs are expected to be parsed without inferences (dropped as comments) by software that supports NEXUS. `r pkg_figtree` supports parsing `r pkg_beast`, and `r pkg_mrbayes` outputs with inferences that can be used to display or annotate on the tree. But from there, extracting these data for further analysis is still challenging.

`r pkg_hyphy`\index{HyPhy} [@pond_hyphy:_2005] could do a number of phylogenetic analyses, including ancestral sequence\index{ancestral sequences} reconstruction. For ancestral sequence reconstruction, these sequences and the Newick tree text are stored in NEXUS format as the major analysis output. It did not completely follow the NEXUS\index{NEXUS} definition and only put the ancestral node labels in `TAXA` instead of the external node label. The `MATRIX` block contains sequence alignment of ancestral nodes which cannot be referred back to the tree stored in the `TREES` block since it does not contain node labels. Here is the sample output (to save space, only the first 72bp of alignment are shown):


```{r echo=FALSE, warning=FALSE, comment=NA}
f <- system.file("extdata/HYPHY/ancseq.nex", package="treeio")
x <- readLines(f)
x[25:37] <- substring(x[25:37], 1, 73)
x[4] <- sub("on", "\n\ton",x[4])
x[11] <- sub("'Node15' ", "'Node15'\n\t\t\t", x[11]) 
cat(paste0(x, collapse="\n"))
```


There are other applications that output rich information text that also contains phylogenetic trees with associated data. For example `r pkg_r8s`\index{r8s} [@sanderson_r8s:_2003] output three trees in its log file, namely `TREE`, `RATE`, and `PHYLO` for branches scaled by time, substitution rate, and absolute substitutions, respectively.


Phylogenetic Analysis by Maximum Likelihood (`r pkg_paml`\index{PAML}) [@yang_paml_2007] is a package of programs for phylogenetic analyses of DNA or protein sequences. Two main programs, `r pkg_baseml` and `r pkg_codeml`, implement a variety of models. `r pkg_baseml` estimates tree topology, branch lengths, and substitution parameters using a number of nucleotide substitution models available, including JC69\index{JC69}, K80, F81, F84, HKY85\index{HKY85}, T92, TN93, and GTR\index{GTR}. `r pkg_codeml` estimates synonymous and non-synonymous substitution rates, likelihood ratio test of positive selection under codon substitution models [@goldman_codon-based_1994].

`r pkg_baseml`\index{BaseML} outputs *mlb* file that contains input sequence (taxa) alignment and a phylogenetic tree with branch length as well as substitution model and other parameters estimated. The supplementary result file, *rst*, contains sequence alignment (with ancestral sequence if it performs reconstruction of ancestral sequences) and Naive Empirical Bayes (NBE) probabilities that each site in the alignment evolved. `r pkg_codeml` outputs *mlc* file that contains tree structure and estimation of synonymous and non-synonymous substitution rates. `r pkg_codeml`\index{CodeML} also outputs a supplementary result file, *rst*, that is similar to `r pkg_baseml` except that site is defined as a codon instead of a nucleotide. Parsing these files can be tedious and would oftentimes need a number of post-processing steps and require expertise in programming (e.g., with Python^[<http://biopython.org/wiki/PAML>] or Perl^[<http://bioperl.org/howtos/PAML_HOWTO.html>]).


Introducing square brackets is quite common for storing extra information, including *RAxML* to store bootstrap value, NHX format for annotation, jplace for edge label, and `r pkg_beast` for evolutionary estimation, *etc*. But the positions to place square brackets are not consistent in different software and the contents employ different rules for storing associated data, these properties make it difficult to parse associated data. For most of the software, they will just ignore square brackets and only parse the tree structure if the file is compatible. Some of them contain invalid characters (e.g., curly braces in `tree` field of jplace format), and even the tree structure can't be parsed by standard parsers. 

It is difficult to extract useful phylogeny/taxon-related information from the different analysis outputs produced by various evolutionary inference software, for displaying on the same phylogenetic tree and for further analysis. `r pkg_figtree`\index{FigTree} supports `r pkg_beast` output, but not for most of the other software outputs that contain evolutionary inferences or associated data. For those output-rich text files (e.g., `r pkg_r8s`, `r pkg_paml`, *etc.*), the tree structure cannot be parsed by any tree viewing software and users need expertise to manually extract the phylogenetic tree and other useful result data from the output file. However, such manual operation is slow and error-prone.

<!-- can't be supported and hard to display on the tree. A very common solution is to modified node labels by putting associated data to node labels and dispaly them as node lables. This is quite restricted and error prone.--> 

It was not easy to retrieve phylogenetic trees with evolutionary data from different analysis outputs of commonly used software in the field. Some of them (*e.g.*, `r pkg_paml` output and jplace file) without software or programming library to support parsing the file, while others (*e.g.*, `r pkg_beast` and `r pkg_mrbayes` output) can be parsed without evolutionary inferences as they are stored in square brackets that will be omitted as a comment by most of the software. Although `r pkg_figtree` support visualizing evolutionary statistics inferred by `r pkg_beast` and `r pkg_mrbayes`, extracting these data for further analysis is not supported. Different software packages implement different algorithms for different analyses (*e.g.*, `r pkg_paml` for *d~N~/d~S~*, `r pkg_hyphy` for ancestral sequences, and `r pkg_beast` for skyline analysis). Therefore, in encountering the genomic sequence data, there is a desired need to efficiently and flexibly integrate different analysis inference results for comprehensive understanding, comparison, and further analysis. This motivated us to develop the programming library to parse the phylogenetic trees and data from various sources.

<!--
to complete each other or compare similar analyses from different software (*e.g.*, clade probability inferred from `BEAST` and `MrBayes`). Without programming library to parse these software outputs make it difficult to integrate evolutionary statistics for comparison and further analysis.
-->

## Getting Tree Data with `r Biocpkg("treeio")`

Phylogenetic trees are commonly used to present evolutionary relationships of
species. Information associated with taxon species/strains may be further
analyzed in the context of the evolutionary history depicted by the phylogenetic
tree. For example, the host information of the influenza virus strains in the tree
could be studied to understand the host range of a virus lineage. Moreover, such
meta-data (*e.g.*, isolation host, time, location, *etc.*) directly associated
with taxon strains are also often subjected to further evolutionary or
comparative phylogenetic models and analyses, to infer their dynamics associated
with the evolutionary or transmission processes of the virus. All these
meta-data or other phenotypic or experimental data are stored either as the
annotation data associated with the nodes or branches and are often produced in
inconsistent format by different analysis programs.

Getting trees into R is still limited. Newick and Nexus can be imported by
several packages, including `r CRANpkg("ape")`, `r CRANpkg("phylobase")`. NeXML
format can be parsed by `r CRANpkg("RNeXML")`. However, analysis results from
widely used software packages in this field are not well
supported. SIMMAP output can be parsed by `r CRANpkg("phyext2")` and `r CRANpkg("phytools")`.
Although `r pkg_phyloch` can
import `r pkg_beast` and `r pkg_mrbayes` output, only internal node attributes were parsed and
tip attributes were ignored^[<https://github.com/ropensci/software-review/issues/179#issuecomment-369164110>]. Many other software outputs are mainly required
programming expertise to import the tree with associated data. Linking external
data, including experimental and clinical data, to phylogeny is another obstacle
for evolution biologists.

To fill the gap that most of the tree formats or software outputs cannot be parsed within the same software/platform, an R package `r Biocpkg("treeio")` [@wang_treeio_2020] was developed for parsing various tree file formats and outputs from common evolutionary analysis software. The `r Biocpkg("treeio")` package is developed with the R programming language [@rstats]. Not only the tree structure can be parsed, but also the associated data and evolutionary inferences, including NHX
annotation, clock rate inferences (from `r pkg_beast` or `r pkg_r8s` [@sanderson_r8s:_2003] programs),
synonymous and non-synonymous substitutions (from `r pkg_codeml`), and ancestral
sequence construction (from
`r pkg_hyphy`, `r pkg_baseml` or `r pkg_codeml`), *etc.*.
Currently, `r Biocpkg("treeio")` is able to read
the following file formats: Newick, Nexus, New Hampshire eXtended format (NHX),
jplace and Phylip as well as the data outputs from the following analysis programs:
`r pkg_astral`, 
`r pkg_beast`,
`r pkg_epa`,
`r pkg_hyphy`,
`r pkg_mega`,
`r pkg_mrbayes`,
`r pkg_paml`,
`r pkg_phyldog`,
`r pkg_pplacer`,
`r pkg_r8s`,
`r pkg_raxml` and 
`r pkg_revbayes`, *etc*. 
This is made possible with the several parser functions developed in `r Biocpkg("treeio")` (Table \@ref(tab:treeio-function)) [@wang_treeio_2020].


```{r treeio-function, echo=F, message=FALSE}
ff <- tibble::tribble(
  ~`Parser function`, ~Description,
  "read.astral"			, "parsing output of ASTRAL",
  "read.beast"      	, "parsing output of BEAST",
  "read.codeml"     	, "parsing output of CodeML (rst and mlc files)",
  "read.codeml_mlc" 	, "parsing mlc file (output of CodeML)",
  "read.fasta"			, "parsing FASTA format sequence file",
  "read.hyphy"      	, "parsing output of HYPHY",
  "read.hyphy.seq"  	, "parsing ancestral sequences from HYPHY output",
  "read.iqtree"			, "parsing IQ-Tree Newick string, with the ability to parse SH-aLRT and UFBoot support values",
  "read.jplace"     	, "parsing jplace file including the output of EPA and pplacer",
  "read.jtree"			, "parsing [jtree](#write-jtree) format",
  "read.mega"			, "parsing MEGA Nexus output",
  "read.mega_tabular"	, "parsing MEGA tabular output",
  "read.mrbayes"    	, "parsing output of MrBayes",
  "read.newick"     	, "parsing Newick string, with the ability to parse node label as support values",
  "read.nexus"			, "parsing standard NEXUS file (re-exported from ape)",
  "read.nhx"        	, "parsing NHX file including the output of PHYLDOG and RevBayes",
  "read.paml_rst"   	, "parsing rst file (output of BaseML or CodeML)",
  "read.phylip"     	, "parsing phylip file (phylip alignment + Newick string)",
  "read.phylip.seq" 	, "parsing multiple sequence alignment from phylip file",
  "read.phylip.tree"	, "parsing newick string from phylip file",
  "read.phyloxml"		, "parsing phyloXML file",
  "read.r8s"        	, "parsing output of r8s",
  "read.raxml"      	, "parsing output of RAxML",
  "read.tree"			, "parsing newick string (re-exported from ape)"
  )

library(kableExtra)
knitr::kable(ff, caption = "Parser functions defined in treeio", booktabs = T) %>% 
  kable_styling(latex_options = c("striped", "scale_down"),
                bootstrap_options = c("striped", "hover")) #%>% landscape
```



The `r Biocpkg("treeio")` package defines base
classes and functions for phylogenetic tree input and output. It is an
infrastructure that enables evolutionary evidence inferred by commonly
used software packages to be used in `R`. For instance, *d~N~/d~S~* values or
ancestral sequences inferred
by `r pkg_codeml` [@yang_paml_2007],
clade support values (posterior) inferred
by `r pkg_beast` [@bouckaert_beast_2014] and short read placement
by `r pkg_epa` [@berger_performance_2011]
and `r pkg_pplacer` [@matsen_pplacer_2010]. These pieces of 
evolutionary evidence can be further analyzed in `R` and used to annotate
a phylogenetic tree using `r Biocpkg("ggtree")`
[@yu_ggtree:_2017]. The growth of analysis tools and models introduces
a challenge to integrate different varieties of data and analysis results from
different sources for an integral analysis on the same phylogenetic tree
background. The `r Biocpkg("treeio")` package [@wang_treeio_2020]
provides a `merge_tree` function to allow [combining tree data](#merge-tree) obtained from
different sources. In addition, `r Biocpkg("treeio")` also enables [external data](#link-external-data) to be linked to a phylogenetic tree structure.



After parsing, storage of the tree structure with associated data is made
through an S4 class, `treedata`, defined in the `r CRANpkg('tidytree')` package. These parsed data
are mapped to the tree branches and nodes inside `treedata` object, so that they
can be efficiently used to visually annotate the tree
using `r Biocpkg("ggtree")` [@yu_ggtree:_2017] and `r Biocpkg("ggtreeExtra")` [@ggtreeExtra_2021]. 
A programmable platform for phylogenetic data parsing, integration, and annotations as such makes us more easily to identify the evolutionary dynamics and correlation patterns (Figure \@ref(fig:treeioDiagram)) [@wang_treeio_2020].




(ref:treeioDiagramscap) Overview of the *treeio* package and its relations with *tidytree* and *ggtree*.

(ref:treeioDiagramcap) __Overview of the *treeio* package and its relations with *tidytree* and *ggtree*__. *Treeio* supports parsing a tree with data from a number of file formats and software outputs. A *treedata* object stores a phylogenetic tree with node/branch-associated data. *Treeio* provides several functions to manipulate a tree with data. Users can convert the *treedata* object into a tidy data frame (each row represents a node in the tree and each column represents a variable) and process the tree with data using the tidy interface implemented in *tidytree*. The tree can be extracted from the *treedata* object and exported to a Newick and NEXUS file or can be exported with associated data into a single file (either in the BEAST NEXUS or jtree format). Associated data stored in the *treedata* object can be used to annotate the tree using *ggtree*. In addition, *ggtree* supports a number of tree objects, including *phyloseq* for microbiome data and *obkData* for outbreak data. The *phylo*, multiPhylo (*ape* package), *phylo4*, *phylo4d* (*phylobase* package), *phylog* (*ade4* package), *phyloseq* (*phyloseq* package), and *obkData* (*OutbreakTools* package) are tree objects defined by the R community to store tree with or without domain-specific data. All these tree objects as well as hierarchical clustering results (*e.g.*, *hclust* and *dendrogram* objects) are supported by *ggtree*.

```{r treeioDiagram, out.width="95%", echo=FALSE, fig.cap="(ref:treeioDiagramcap)", fig.scap="(ref:treeioDiagramscap)"}
knitr::include_graphics("img/treeio-diagram.png", auto_pdf = TRUE)
```


### Overview of `r Biocpkg("treeio")`

The `r Biocpkg("treeio")`\index{treeio} package [@wang_treeio_2020] defined `S4` classes for storing phylogenetic trees with diverse types of associated data or covariates from different sources including analysis outputs from different software packages. It also defined corresponding parser functions for parsing phylogenetic trees with annotation data and stored them as data objects in R for further manipulation or analysis (see Table \@ref(tab:treeio-function)). Several accessor functions were defined to facilitate accessing the tree annotation data, including `get.fields` for obtaining annotation features available in the tree object, `get.placements` for obtaining the phylogenetic placement results (*i.e.*, the output of `r pkg_pplacer`, `r pkg_epa`, *etc.*), `get.subs` for obtaining the genetic substitutions from parent node to child node, and `get.tipseq` for getting the tip sequences. 


The `S3` class, `phylo`, which was defined in `r CRANpkg("ape")`\index{ape} [@paradis_ape_2004] package, is widely used in `R` community and many packages. As `r Biocpkg("treeio")` uses `S4` class, to enable those available R packages to analyze the tree imported by `r Biocpkg("treeio")`, `r Biocpkg("treeio")` provides `as.phylo` function to convert `r Biocpkg("treeio")`-generated tree object to `phylo` object that only contains tree structure without annotation data. In the other way, `r Biocpkg("treeio")` also provides `as.treedata` function to convert `phylo` object with evolutionary analysis result (*e.g.*, bootstrap values calculated by `r CRANpkg("ape")` or ancestral states inferred by `r CRANpkg("phangorn")`\index{phangorn} [@schliep_phangorn_2011] *etc.*) to be stored as a `treedata` `S4` object, making it easy to map the data to the tree structure and to be visualized using `r Biocpkg("ggtree")` [@yu_ggtree:_2017].


<!--
(*e.g.*, `phangorn`  for ancestral state reconstruction and `ape` for divergence time estimation) that implemented evolutionary inferences are supporting `phylo` object. 
-->

To allow integration of different kinds of data in a phylogenetic tree, `r Biocpkg("treeio")` [@wang_treeio_2020] provides `merge_tree` function (details in [section 2.2.1](#merge-tree)) for combining evolutionary statistics/evidence imported from different sources including those common tree files and outputs from analysis programs (Table \@ref(tab:treeio-function)). There is other information, such as sampling location, taxonomy information, experimental result, and evolutionary traits, *etc.* that are stored in separate files with the user-defined format. In `r Biocpkg("treeio")`, we could read in these data from the users' files using standard R *IO* functions, and attach them to the tree object by the [full_join](#link-external-data) methods defined in `r CRANpkg("tidytree")` and `r Biocpkg("treeio")` packages (see also the [`%<+%` operator](#attach-operator) defined in `r Biocpkg("ggtree")`). After attaching, the data will become the attributes associated with nodes or branches, which can be compared with other data incorporated or can be visually displayed on the tree [@yu_two_2018].

To facilitate storing complex data associated with the phylogenetic tree, `r Biocpkg("treeio")`\index{treeio} implemented `write.beast` and `write.jtree` functions to export a `treedata` object into a single file (see [Chapter 3](#chapter3)). 

<!-- A full list of functions that defined in *treeio* can be found in Table \@ref(tab:treeio). -->

### Function demonstration

#### Parsing BEAST output


```{r echo=FALSE}
options(show_data_for_treedata = FALSE)
```

```{r}
file <- system.file("extdata/BEAST", "beast_mcc.tree", package="treeio")
beast <- read.beast(file)
beast
```

Since _`%`_ is not a valid character in _`names`_, all the feature names that contain _`x%`_ will convert to _`0.x`_. For example, _`length_95%_HPD`_ will be changed to _`length_0.95_HPD`_.

Not only tree structure but also all the features inferred by `r pkg_beast`\index{BEAST} will be stored in the `S4` object. These features can be used for tree annotation (Figure \@ref(fig:beast)). 

#### Parsing MEGA output {#mega}

Molecular Evolutionary Genetics Analysis (`r pkg_mega`)\index{MEGA} software [@kumar_mega7_2016] supports exporting trees in three distinct formats: Newick, tabular, and Nexus. The Newick file can be parsed using the `read.tree` or `read.newick` functions. MEGA Nexus file is similar to BEAST Nexus and `r Biocpkg("treeio")` [@wang_treeio_2020] provides `read.mega` function to parse the tree.

```{r}
file <- system.file("extdata/MEGA7", "mtCDNA_timetree.nex", 
                    package = "treeio")
read.mega(file)
```

The tabular output contains tree and associated information (divergence time in this example) in a tabular flat text file. The `read.mega_tabular` function can parse the tree with data simultaneously.


```{r}
file <- system.file("extdata/MEGA7", "mtCDNA_timetree_tabular.txt", 
                    package = "treeio")
read.mega_tabular(file) 
```


#### Parsing MrBayes output


Although the Nexus file generated by `r pkg_mrbayes`\index{MrBayes} is different from the output of `r pkg_beast`, they are similar. The `r Biocpkg("treeio")` package provides the `read.mrbayes()` which internally calls `read.beast()` to parse `r pkg_mrbayes` outputs.

```{r}
file <- system.file("extdata/MrBayes", "Gq_nxs.tre", package="treeio")
read.mrbayes(file)
```

#### Parsing PAML output

Phylogenetic Analysis by Maximum Likelihood (`r pkg_paml`)\index{PAML} is a package of tools for phylogenetic analyses of DNA and protein sequences using maximum likelihood. Tree search algorithms are implemented in `r pkg_baseml` and `r pkg_codeml`. The `read.paml_rst()` function provided in `r Biocpkg("treeio")` can parse *rst* file from `r pkg_baseml` and `r pkg_codeml`. The only difference is the space in the sequences.
For `r pkg_baseml`, every ten bases are separated by one space, while for `r pkg_codeml`, every three bases (triplet) are separated by one space.

```{r fig.width=12, fig.height=10, warning=FALSE, fig.align="center"}
brstfile <- system.file("extdata/PAML_Baseml", "rst", package="treeio")
brst <- read.paml_rst(brstfile)
brst
```

Similarly, we can parse the *rst* file from `r pkg_codeml`.

```{r}
crstfile <- system.file("extdata/PAML_Codeml", "rst", package="treeio")
## type can be one of "Marginal" or "Joint"
crst <- read.paml_rst(crstfile, type = "Joint")
crst
```


Ancestral sequences inferred by `r pkg_baseml` or `r pkg_codeml` via marginal or
joint ML reconstruction methods will be stored in the S4 object and mapped to
tree nodes. `r Biocpkg("treeio")` [@wang_treeio_2020] will automatically determine the substitutions between the
sequences at both ends of each branch. The amino acid substitution will also be
determined by translating nucleotide sequences to amino acid sequences. These
computed substitutions will also be stored in the S4 object for efficient tree annotation later (Figure \@ref(fig:codeml)).

`r pkg_codeml` infers selection
pressure and estimated *d~N~/d~S~*, *d~N~* and *d~S~*. These pieces of information are
stored in output file *mlc*, which can be parsed by the `read.codeml_mlc()` function.


```{r}
mlcfile <- system.file("extdata/PAML_Codeml", "mlc", package="treeio")
mlc <- read.codeml_mlc(mlcfile)
mlc
```

The *rst* and *mlc* files can be parsed separately as demonstrated previously, they
can also be parsed together using the `read.codeml()` function.


```{r}
## tree can be one of "rst" or "mlc" to specify
## using tree from which file as base tree in the object
ml <- read.codeml(crstfile, mlcfile, tree = "mlc")
ml
```

All the features in both *rst* and *mlc* files are imported into a single S4
object and hence are available for further annotation and visualization. For
example, we can annotate and display both *d~N~/d~S~* (from *mlc* file) and
amino acid substitutions (derived from *rst* file) on the same phylogenetic tree [@yu_ggtree:_2017].


#### Parsing HyPhy output

Hypothesis testing using Phylogenies (`r pkg_hyphy`)\index{HYPHY} is a software package for analyzing genetic sequences. Ancestral sequences inferred by `r pkg_hyphy` are
stored in the Nexus output file, which contains the tree topology and ancestral
sequences. To parse this data file, users can use the `read.hyphy.seq()` function.


```{r warning=FALSE}
ancseq <- system.file("extdata/HYPHY", "ancseq.nex", package="treeio")
read.hyphy.seq(ancseq)
```

To map the sequences on the tree, users should also provide an
internal-node-labeled tree. If users want to determine substitution, they need
to also provide tip sequences. In this case, substitutions will be determined automatically, just as we parse the output of `r pkg_codeml`.

```{r warning=FALSE}
nwk <- system.file("extdata/HYPHY", "labelledtree.tree", package="treeio")
tipfas <- system.file("extdata", "pa.fas", package="treeio")
hy <- read.hyphy(nwk, ancseq, tipfas)
hy
```




#### Parsing r8s output

The `r pkg_r8s` package uses parametric, semi-parametric, and
non-parametric methods to relax the molecular clock to allow better estimations of
divergence times and evolution rates [@sanderson_r8s:_2003]. It outputs three
trees in a log file, namely, *TREE*, *RATO*, and *PHYLO* for time tree, rate tree,
and absolute substitution tree, respectively.

The time tree is scaled by divergence time, the rate tree is scaled by substitution rate
and the absolute substitution tree is scaled by the absolute number of substitutions.
After parsing the file, all these three trees are stored in a *multiPhylo* object (Figure \@ref(fig:multiPhylo)).


```{r fig.width=4, fig.height=6, width=60, warning=FALSE, fig.align="center"}
r8s <- read.r8s(system.file("extdata/r8s", "H3_r8s_output.log", package="treeio"))
r8s
```


#### Parsing output of RAxML bootstrap analysis

`r pkg_raxml` bootstrapping analysis
outputs a Newick tree text that is not standard, as it stores bootstrap values
inside square brackets after branch lengths. This file usually cannot be parsed
by a traditional Newick parser, such as `ape::read.tree()`. The function
`read.raxml()` can read such files and store the bootstrap as an additional
feature, which can be used to display on the tree or used to color tree
branches, *etc.*



```{r fig.width=12, fig.height=10, width=60, warning=FALSE, fig.align="center"}
raxml_file <- system.file("extdata/RAxML", 
                          "RAxML_bipartitionsBranchLabels.H3", 
                          package="treeio")
raxml <- read.raxml(raxml_file)
raxml
```



#### Parsing NHX tree

NHX (New Hampshire eXtended) format is an extension of Newick by introducing NHX\index{NHX}
tags. NHX is commonly used in phylogenetics software,
including
`r pkg_phyldog` [@boussau_genome-scale_2013],
`r pkg_revbayes` [@hohna_probabilistic_2014],
for storing statistical inferences. The following codes imported an NHX tree with
associated data inferred by `r pkg_phyldog` (Figure \@ref(fig:beastFigtree)A).

```{r}
nhxfile <- system.file("extdata/NHX", "phyldog.nhx", package="treeio")
nhx <- read.nhx(nhxfile)
nhx
```

#### Parsing Phylip tree

Phylip format contains multiple sequence alignment of taxa in Phylip sequence
format with corresponding Newick tree text that was built from taxon sequences.
Multiple sequence alignment can be sorted based on the tree structure and displayed at
the right-hand side of the tree using `r Biocpkg("ggtree")` through the [`msaplot()` function](#msaplot) or in combining with the `r Biocpkg("ggmsa")` package (see also Basic Protocol 5 of [@yu_cp_2020]).

```{r}
phyfile <- system.file("extdata", "sample.phy", package="treeio")
phylip <- read.phylip(phyfile)
phylip
```

#### Parsing EPA and pplacer output

`r pkg_epa` [@berger_performance_2011] and `r pkg_pplacer` [@matsen_pplacer_2010] have a common output file format, `jplace`, which can be
parsed by the `read.jplace()` function.

```{r}
jpf <- system.file("extdata/EPA.jplace",  package="treeio")
jp <- read.jplace(jpf)
print(jp)
```

The number of evolutionary placement on each branch will be calculated and
stored as the *nplace* feature, which can be mapped to line size and/or color
using `r Biocpkg("ggtree")` [@yu_ggtree:_2017].


#### Parsing jtree format{#jtree}

The *jtree* is a JSON-based format that was defined in
this `r Biocpkg("treeio")` package [@wang_treeio_2020] to support tree
data interchange (see [session 3.3](#write-jtree)).
Phylogenetic tree with associated data can be exported to a single *jtree*
file using the `write.jtree()` function. The *jtree* can be easily parsed using any
JSON parser. The *jtree* format contains three keys: tree, data, and meta-data.
The tree value contains tree text extended from Newick tree format by putting
the edge number in curly braces after branch length. The data value contains
node/branch-specific data, while the meta-data value contains additional meta information.




```{r}
jtree_file <- tempfile(fileext = '.jtree')
write.jtree(beast, file = jtree_file)
read.jtree(file = jtree_file)
```


### Converting other tree-like objects to `phylo` or `treedata` objects {#as-treedata}


To extend the application scopes of `r Biocpkg("treeio")`, `r CRANpkg("tidytree")` and `r Biocpkg("ggtree")`, `r Biocpkg("treeio")` [@wang_treeio_2020] provides several `as.phylo` and `as.treedata` methods to convert other tree-like objects, such as `phylo4d` and `pml`, to `phylo` or `treedata` object. So that users can easily [map associated data to the tree structure](#data-integration), [export a tree with/without data to a single file](#chapter3), [manipulate](#chapter2) and [visualize a tree](#chapter4) with/without data. These convert functions (Table \@ref(tab:treeio-treedata-object)) create the possibility of using `r CRANpkg("tidytree")` to process tree using tidy interface and `r Biocpkg("ggtree")` to visualize tree using the grammar of graphic syntax.



```{r treeio-treedata-object, echo=F, message=FALSE}
ff <- tibble::tribble(
  ~`Convert function`, ~`Supported object`, ~Description,
  "as.phylo", 		"ggtree", 	"convert ggtree object to phylo object",
  "as.phylo", 		"igraph",	"convert igraph object (only tree graph supported) to phylo object",
  "as.phylo", 		"phylo4",	"convert phylo4 object to phylo object",
  "as.phylo", 		"pvclust",	"convert pvclust object to phylo object",
  "as.phylo",		"treedata",	"convert treedata object to phylo object",
  "as.treedata",	"ggtree",	"convert ggtree object to treedata object",
  "as.treedata",	"phylo4",	"convert phylo4 object to treedata object",
  "as.treedata",	"phylo4d",	"convert phylo4d object to treedata object",
  "as.treedata",	"pml",		"convert pml object to treedata object",
  "as.treedata",	"pvclust",	"convert pvclust object to treedata object",
  )


require(kableExtra)
caption = "Conversion of tree-like object to phylo or treedata object"

knitr::kable(ff, caption=caption, booktabs = T) %>% 
  collapse_rows(columns = 1, latex_hline = "major", valign ="top") %>%
  kable_styling(latex_options = c("striped", "scale_down"),
                bootstrap_options = c("striped", "hover")) #%>% landscape
```

Here, we used `pml` object which was defined in the `r CRANpkg("phangorn")` package\index{phangorn}, as an example. The `pml()` function computes the likelihood of a phylogenetic tree given a sequence alignment and a model and the `optim.pml()` function optimizes different model parameters. The output is a `pml` object, and it can be converted to a `treedata` object using `as.treedata` provided by `r Biocpkg("treeio")` [@wang_treeio_2020]. The amino acid substitution (ancestral sequence estimated by `pml`) that stored in the `treedata` object can be visualized using `r Biocpkg("ggtree")` as demonstrated in Figure \@ref(fig:pmlTree).


(ref:pmlTreescap) Converting `pml` object to `treedata` object. 

(ref:pmlTreecap) **Converting `pml` object to `treedata` object.** This allows using `r CRANpkg("tidytree")` to process the tree data as well as using `r Biocpkg("ggtree")` and `r Biocpkg("ggtreeExtra")` to visualize the tree with associated data.

```{r pmlTree, fig.width=14, fig.height=14, fig.cap="(ref:pmlTreecap)", fig.scap="(ref:pmlTreescap)", message=FALSE, out.width="100%"}
library(phangorn)
treefile <- system.file("extdata", "pa.nwk", package="treeio")
tre <- read.tree(treefile)
tipseqfile <- system.file("extdata", "pa.fas", package="treeio")
tipseq <- read.phyDat(tipseqfile,format="fasta")
fit <- pml(tre, tipseq, k=4)
fit <- optim.pml(fit, optNni=FALSE, optBf=T, optQ=T,
                 optInv=T, optGamma=T, optEdge=TRUE,
                 optRooted=FALSE, model = "GTR",
				 control = pml.control(trace =0))

pmltree <- as.treedata(fit)
ggtree(pmltree) + geom_text(aes(x=branch, label=AA_subs, vjust=-.5))
```

### Getting information from `treedata` object {#get-treedata-data}

After the tree was imported, users may want to extract information stored
in the `treedata` object. `r Biocpkg("treeio")` provides several accessor
methods to extract tree structure, features/attributes that stored in the object,
and their corresponding values.

The `get.tree()` or `as.phylo()` methods can convert the `treedata` object to a
`phylo` object which is the fundamental tree object in the R community and
many packages work with `phylo` object.

```{r eval=FALSE}
beast_file <- system.file("examples/MCC_FluA_H3.tree", package="ggtree")
beast_tree <- read.beast(beast_file)
# or get.tree
as.phylo(beast_tree)
```

```{r eval=TRUE}
beast_file <- system.file("examples/MCC_FluA_H3.tree", package="ggtree")
beast_tree <- read.beast(beast_file)
# or get.tree
print(as.phylo(beast_tree), printlen=3)
```


The `get.fields` method returns a vector of features/attributes stored in
the object and associated with the phylogeny.

```{r}
get.fields(beast_tree)
```

The `get.data` method returns a tibble of all the associated data.


```{r}
get.data(beast_tree)
```

If users are only interested in a subset of the features/attributes returned by
`get.fields`, they can extract the information from the output of `get.data` or
directly subset the data by `[` or `[[`.

```{r}
beast_tree[, c("node", "height")]
head(beast_tree[["height_median"]])
```

## Summary {#summary1}


Software tools for inferring molecular evolution (*e.g.*, ancestral states, molecular dating\index{molecular dating} and selection pressure, *etc.*) are proliferating, but there is no single data format that is used by all different programs and capable to store different types of phylogenetic data. Most of the software packages have their unique output formats and these formats are not compatible with each other. Parsing software outputs is challenging, which restricts the joint analysis using different tools. The `r Biocpkg("treeio")` package [@wang_treeio_2020] provides a set of functions (Table \@ref(tab:treeio-function)) for parsing various types of phylogenetic data files and a set of converters (Table \@ref(tab:treeio-treedata-object)) to convert tree-like objects to phylo or treedata objects. These phylogenetic data can be integrated that allow further exploration and comparison. To date, most software tools in the field of molecular evolution are isolated and often not fully compatible with each other's input and output files. These software tools are designed to do their analysis and the outputs are often not readable in other software. No tools have been designed to unify the inference data from different analysis programs. Efficient incorporation of data from different inference methods can enhance the comparison and understanding of the study target, which may help discover new systematic patterns and generate new hypotheses.


As phylogenetic trees are growing in their application to identify patterns in an evolutionary context, more different disciplines are employing phylogenetic trees in their research. For example, spatial ecologists may map the geographical positions of the organisms to their phylogenetic trees to understand the biogeography of the species [@schon_age_2015]; disease epidemiologists may incorporate the pathogen sampling time and locations into the phylogenetic analysis to infer the disease transmission dynamics in spatiotemporal space [@he_emergence_2013]; microbiologists may determine the pathogenicity of different pathogen\index{pathogen} strains and map them into their phylogenetic trees to identify the genetic determinants of the pathogenicity [@bosi_comparative_2016]; genomic scientists may use the phylogenetic trees to help taxonomically classify their metagenomic sequence data [@gupta_using_2015]. A robust tool such as `r Biocpkg("treeio")` to import and map different types of data into the phylogenetic tree is important to facilitate these phylogenetics-related research, or `r squote("phylodynamics")`. Such tools could also help integrate different meta-data (time, geography, genotype\index{genotype}, epidemiological information) and analysis results (selective pressure, evolutionary rates) at the highest level and provide a comprehensive understanding of the study organisms. In the field of influenza research, there have been such attempts of studying the phylodynamics\index{phylodynamics} of the influenza virus by mapping different meta-data and analysis results on the same phylogenetic tree and evolutionary timescale [@lam_dissemination_2015]. 

<!--chapter:end:01_treeio_importing_tree.Rmd-->

\newpage

# Manipulating Tree with Data {#chapter2}


```{r include=FALSE}
library(knitr)
opts_chunk$set(message=FALSE, warning=FALSE, eval=TRUE, echo=TRUE, cache=TRUE)
```



```{r echo=FALSE, results="hide", message=FALSE}
library("ape")
library("tidytree")
library(treeio)
```



```{r echo=FALSE}
options(show_data_for_treedata = FALSE)
```


## Manipulating Tree Data Using Tidy Interface {#tidytree}

All the tree data parsed/merged
by `r Biocpkg("treeio")`\index{treeio} [@wang_treeio_2020] can be converted to a tidy
data frame using the `r CRANpkg("tidytree")`
package. The `r CRANpkg("tidytree")` package
provides tidy interfaces to manipulate trees with associated data. For instance,
external data can be linked to phylogeny or evolutionary data obtained from
different sources can be merged using tidyverse verbs. After the tree data was
processed, it can be converted back to a `treedata` object and exported to [a single tree file](#chapter3), further analyzed in R or visualized using `r Biocpkg("ggtree")` [@yu_ggtree:_2017] and `r Biocpkg("ggtreeExtra")` [@ggtreeExtra_2021].


### The `phylo` object

The `phylo` class defined in the `r CRANpkg("ape")` package [@paradis_ape_2004] is
fundamental for phylogenetic analysis in R. Most of the R packages
in [this field](https://CRAN.R-project.org/view=Phylogenetics) rely
extensively on the `phylo` object. The `r CRANpkg("tidytree")` package provides `as_tibble`
method to convert the `phylo` object to a tidy data frame, a `tbl_tree` object\index{ape}.

```{r}
library(ape)
set.seed(2017)
tree <- rtree(4)
tree
x <- as_tibble(tree)
x
```

The `tbl_tree` object can be converted back to a `phylo` object using the `as.phylo()` method.


```{r}
as.phylo(x)
```

Using `tbl_tree` object makes tree and data manipulation more effective and
easier (see also the example in [FAQ](#bind-tip)). For example, we can link evolutionary trait to phylogeny using the `r CRANpkg("dplyr")` verbs `full_join()`:

```{r}
d <- tibble(label = paste0('t', 1:4),
            trait = rnorm(4))

y <- full_join(x, d, by = 'label')
y
```

### The `treedata` object

The `r CRANpkg("tidytree")` package defines `treedata` class to store a phylogenetic tree with
associated data. After mapping external data to the tree structure, the
`tbl_tree` object can be converted to a `treedata` object.


```{r}
as.treedata(y)
```

The `treedata` class is used
in the [treeio](https://bioconductor.org/packages/treeio/) package [@wang_treeio_2020] to store evolutionary evidence inferred by commonly used software (`r pkg_beast`, `r pkg_epa`, `r pkg_hyphy`, `r pkg_mrbayes`, `r pkg_paml`, `r pkg_phyldog`, `r pkg_pplacer`, `r pkg_r8s`, `r pkg_raxml`, and `r pkg_revbayes`, etc.) (see details in [Chapter 1](#chapter1)).

The `r CRANpkg("tidytree")` package also provides the `as_tibble()` method to convert a `treedata` object to a tidy data frame. The phylogenetic tree structure and the evolutionary
inferences were stored in the `tbl_tree` object, making it consistent and easier
for manipulating evolutionary statistics inferred by different software as well
as linking external data to the same tree structure.


```{r}
y %>% as.treedata %>% as_tibble
```



### Access related nodes {#accesor-tidytree}

The `r CRANpkg("dplyr")` verbs can be applied to `tbl_tree` directly to manipulate tree data. In addition, `r CRANpkg("tidytree")` provides several verbs to filter related nodes, including
`child()`, `parent()`, `offspring()`, `ancestor()`, `sibling()` and `MRCA()`.

These verbs accept a `tbl_tree` object and a selected node which can be node number or label.


```{r}
child(y, 5)
parent(y, 2)
offspring(y, 5)
ancestor(y, 2)
sibling(y, 2)
MRCA(y, 2, 3)
```

All these methods are also implemented in `r Biocpkg("treeio")` for working with `phylo` and `treedata` objects. You can try accessing related nodes using the tree object. For instance, the following command will output child nodes of the selected internal node `5`:

```{r}
child(tree, 5)
```

Beware that the methods for tree objects output relevant node numbers, while the methods for `tbl_tree` object output a `tibble` object that contains related information.


## Data Integration

### Combining tree data {#merge-tree}

The `r Biocpkg("treeio")` package [@wang_treeio_2020] serves as an
infrastructure that enables various types of phylogenetic data inferred from
common analysis programs to be imported and used in R. For instance, *d~N~/d~S~*
or ancestral sequences estimated by `r pkg_codeml`,
and clade support values (posterior) inferred by `r pkg_beast`/`r pkg_mrbayes`.
In addition, `r Biocpkg("treeio")` supports linking external data to phylogeny. It brings these external phylogenetic data (either from software output or external sources) to the R
community and makes it available for further analysis in R.
Furthermore, `r Biocpkg("treeio")` can combine
multiple phylogenetic trees into one with their node/branch-specific
attribute data. Essentially, as a result, one such attribute (*e.g.*,
substitution rate) can be mapped to another attribute (*e.g.*, *d~N~/d~S~*) of
the same node/branch for comparison and further computations [@yu_ggtree:_2017; @yu_two_2018].


A previously published dataset, seventy-six H3 hemagglutinin gene sequences of
a lineage containing swine and human influenza A viruses
[@liang_expansion_2014], was used here to demonstrate the utilities of comparing
evolutionary statistics inferred by different software. The dataset was
re-analyzed by `r pkg_beast` for timescale estimation
and `r pkg_codeml` for synonymous and
non-synonymous substitution estimation. In this example, we first parsed the
outputs from `r pkg_beast` using the `read.beast()` function and
from `r pkg_codeml` using
the `read.codeml()` function into two `treedata` objects. Then these two objects containing separate sets of node/branch-specific data were merged via the `merge_tree()` function.



```{r}
beast_file <- system.file("examples/MCC_FluA_H3.tree", package="ggtree")
rst_file <- system.file("examples/rst", package="ggtree")
mlc_file <- system.file("examples/mlc", package="ggtree")
beast_tree <- read.beast(beast_file)
codeml_tree <- read.codeml(rst_file, mlc_file)

merged_tree <- merge_tree(beast_tree, codeml_tree)
merged_tree
```

After merging the `beast_tree` and `codeml_tree` objects, all
node/branch-specific data imported from `r pkg_beast`
and `r pkg_codeml` output files are
all available in the `merged_tree` object. The tree object was converted to a
tidy data frame using the [tidytree](https://cran.r-project.org/package=tidytree)
package and visualized as hexbin scatterplots of *d~N~/d~S~*, *d~N~*, and *d~S~* inferred
by `r pkg_codeml` vs. *rate*
(substitution rate in a unit of substitutions/site/year) inferred
by `r pkg_beast` on the same branches.


(ref:correlationscap) Correlation of *d~N~/d~S~*, *d~N~*, and *d~S~* versus substitution rate.

(ref:correlationcap) **Correlation of *d~N~/d~S~*, *d~N~*, and *d~S~* vs. substitution rate.** After merging the *BEAST* and *CodeML* outputs, the branch-specific estimates (substitution rate, *d~N~/d~S~* , *d~N~*, and *d~S~*) from the two analysis programs are compared on the same branch basis. The associations of *d~N~/d~S~*, *d~N~*, and *d~S~* vs. *rate* are visualized in hexbin scatter plots.


```{r correlations, fig.width=9, fig.height=3, warning=FALSE, fig.cap="(ref:correlationcap)", fig.scap="(ref:correlationscap)", out.extra='', out.width="100%"}
library(dplyr)
df <- merged_tree %>% 
  as_tibble() %>%
  select(dN_vs_dS, dN, dS, rate) %>%
  subset(dN_vs_dS >=0 & dN_vs_dS <= 1.5) %>%
  tidyr::gather(type, value, dN_vs_dS:dS)
df$type[df$type == 'dN_vs_dS'] <- 'dN/dS'
df$type <- factor(df$type, levels=c("dN/dS", "dN", "dS"))
ggplot(df, aes(rate, value)) + geom_hex() + 
  facet_wrap(~type, scale='free_y') 
```


The output is illustrated in Figure \@ref(fig:correlations). We can then test the association of these node/branch-specific data using Pearson correlation, which in this case showed that *d~N~* and *d~S~*, but not *d~N~/d~S~*\index{d\textsubscript{N}/d\textsubscript{S}}  are significantly (*p*-values) associated with *rate*.

Using the `merge_tree()` function, we are able to compare analysis results using an identical
model from different software packages or different models using different or
identical software. It also allows users to integrate different analysis findings
from different software packages. Merging tree data is not restricted to
software findings, associating external data to analysis findings is also
granted. The `merge_tree()` function is chainable and allows several tree objects
to be merged into one.


```{r}
phylo <- as.phylo(beast_tree)
N <- Nnode2(phylo)
d <- tibble(node = 1:N, fake_trait = rnorm(N), another_trait = runif(N))
fake_tree <- treedata(phylo = phylo, data = d)
triple_tree <- merge_tree(merged_tree, fake_tree)
triple_tree
```

The `triple_tree` object shown above contains analysis results obtained from `r pkg_beast`
and `r pkg_codeml`, and evolutionary
traits from external sources. All these pieces of information can be used to annotate the
tree using `r Biocpkg("ggtree")` [@yu_ggtree:_2017] and `r Biocpkg("ggtreeExtra")` [@ggtreeExtra_2021].




### Linking external data to phylogeny {#link-external-data}

In addition to analysis findings that are associated with the tree as demonstrated
above, there is a wide range of heterogeneous data, including phenotypic data,
experimental data, and clinical data, *etc.*, that need to be integrated and
linked to phylogeny. For example, in the study of viral evolution, tree nodes may be
associated with epidemiological information, such as location, age, and subtype.
Functional annotations may need to be mapped onto gene trees for comparative
genomics studies. To facilitate data
integration, `r Biocpkg("treeio")` provides
`full_join()` methods to link external data to phylogeny and store it in either `phylo` or `treedata` object. Beware that linking external data to a `phylo` object will produce a `treedata` object to store the input `phylo` with associated data. The `full_join` methods can also be used at tidy data frame level (*i.e.*, `tbl_tree` object described previously) and at `ggtree` level (described in [Chapter 7](#attach-operator)) [@yu_two_2018].


The following example calculated bootstrap values and merged those values with the tree (a `phylo` object) by matching their node numbers.



```{r apeBoot, message=FALSE}
library(ape)
data(woodmouse)
d <- dist.dna(woodmouse)
tr <- nj(d)
bp <- boot.phylo(tr, woodmouse, function(x) nj(dist.dna(x)))
bp2 <- tibble(node=1:Nnode(tr) + Ntip(tr), bootstrap = bp)
full_join(tr, bp2, by="node")
```

Another example demonstrates merging evolutionary traits with the tree (a `treedata` object) by matching their tip labels.


```{r}
file <- system.file("extdata/BEAST", "beast_mcc.tree", package="treeio")
beast <- read.beast(file)
x <- tibble(label = as.phylo(beast)$tip.label, trait = rnorm(Ntip(beast)))
full_join(beast, x, by="label")
```

Manipulating tree objects is frustrated with the fragmented functions available
for working with `phylo` objects, not to mention linking external data to the
phylogeny structure. With the `r Biocpkg("treeio")` package [@wang_treeio_2020], it is easy to combine tree data from various sources. 
In addition, with the `r CRANpkg("tidytree")` package, manipulating trees is easier using the [tidy data principles](https://www.jstatsoft.org/article/view/v059i10) and 
consistent with tools already in wide use, including
`r CRANpkg("dplyr")`,
`r CRANpkg("tidyr")`,
`r CRANpkg("ggplot2")`,
and `r Biocpkg("ggtree")` [@yu_ggtree:_2017].


### Grouping taxa

The `groupOTU()`\index{groupOTU} and `groupClade()`\index{groupClade} methods are designed for adding taxa grouping
information to the input tree object. The methods were implemented in `r CRANpkg("tidytree")`,
`r Biocpkg("treeio")`, and `r Biocpkg("ggtree")` respectively to support adding grouping information for the 
`tbl_tree`, `phylo` and `treedata`, and `ggtree` objects. This grouping information can be
used directly in tree visualization (*e.g.*, [coloring a tree based on grouping information](#group-taxa-vis))
with `r Biocpkg("ggtree")` (Figure \@ref(fig:groupOTU)).



#### groupClade

The `groupClade()` method accepts an internal node or a vector of internal nodes
to add grouping information of selected clade/clades.



```{r}
nwk <- '(((((((A:4,B:4):6,C:5):8,D:6):3,E:21):10,((F:4,G:12):14,H:8):13):
        13,((I:5,J:2):30,(K:11,L:11):2):17):4,M:56);'
tree <- read.tree(text=nwk)

groupClade(as_tibble(tree), c(17, 21))
```


#### groupOTU


```{r}
set.seed(2017)
tr <- rtree(4)
x <- as_tibble(tr)
## the input nodes can be node ID or label
groupOTU(x, c('t1', 't4'), group_name = "fake_group")
```

Both `groupClade()` and `groupOTU()` work with the `tbl_tree`, `phylo` and `treedata`, and `ggtree` objects. Here is an example of using `groupOTU()` with a `phylo` tree object\index{groupOTU}.

```{r}
groupOTU(tr, c('t2', 't4'), group_name = "fake_group") %>%
  as_tibble
```

Another example of working with the `ggtree` object can be found in [session 6.4](#group-taxa-vis).


The `groupOTU` will trace back from input nodes to most recent common ancestor.
In this example, nodes 1, 4, 5 and 6 are
grouping together (`4 (t2) -> 6 -> 5` and `1 (t4) -> 5`).

Related operational taxonomic units (OTUs) are grouping and they are not necessarily within a clade.
They can be monophyletic (clade), polyphyletic or paraphyletic.

```{r}
cls <- list(c1=c("A", "B", "C", "D", "E"),
            c2=c("F", "G", "H"),
            c3=c("L", "K", "I", "J"),
            c4="M")

as_tibble(tree) %>% groupOTU(cls)
```

If there are conflicts when tracing back to the most recent common ancestor, users can set `overlap`
parameter to "origin" (the first one counts), "overwrite" (default, the last one
counts), or "abandon" (un-selected for grouping)^[<https://groups.google.com/forum/#!msg/bioc-ggtree/Q4LnwoTf1DM/uqYdYB_VBAAJ>].


## Rerooting tree {#reroot-treeio}

A phylogenetic tree can be rerooted with a specified `outgroup`. The `r CRANpkg("ape")` package implements a `root()` method to reroot a tree stored in a `phylo` object, while the `r Biocpkg("treeio")` package provides the `root()` method for `treedata` object. This method is designed to re-root a phylogenetic tree with associated data concerning the specified `outgroup` or at the specified `node` based on the `root()` implemented in the `r CRANpkg("ape")` package.


We first linked external data to a tree using `left_join()` and stored all the information in a `treedata` object, `trda`. 

```{r reroot_build_td}
library(ggtree)
library(treeio)
library(tidytree)
library(TDbook)

# load `tree_boots`, `df_tip_data`, and `df_inode_data` from 'TDbook'

trda <- tree_boots %>% 
        left_join(df_tip_data, by=c("label" = "Newick_label")) %>% 
        left_join(df_inode_data, by=c("label" = "newick_label"))
trda
```


Then we can reroot the tree with the associated data mapping to the branches and nodes correctly as demonstrated in Figure \@ref(fig:reroot). The figure was visualized using `r Biocpkg("ggtree")` (see also Chapters [4](#chapter4) and [5](#chapter5)).


(ref:rerootscap) Reroot a phylogenetic tree with associated data.

(ref:rerootcap) **Reroot a phylogenetic tree with associated data.** Original tree (A) and  re-rooted tree (B) with associated data mapped to the branches or nodes of the tree correctly. (A) and (B) present before and after rooting on the branch leading to the tip node 'Suricata_suricatta', respectively.


```{r reroot, fig.width=14, fig.height=5, fig.cap="(ref:rerootcap)", fig.scap="(ref:rerootscap)"}
# reroot
trda2 <- root(trda, outgroup = "Suricata_suricatta", edgelabel = TRUE)
# The original tree
p1 <- trda %>%
      ggtree() +
      geom_nodelab(
        mapping = aes(
          x = branch,
          label = bootstrap
        ),
        nudge_y = 0.36
      ) +
      xlim(-.1, 4.5) +
      geom_tippoint(
        mapping = aes(
          shape = trophic_habit, 
          color = trophic_habit, 
          size = mass_in_kg
        )
      ) +
      scale_size_continuous(range = c(3, 10)) +
      geom_tiplab(
        offset = .14, 
      ) +
      geom_nodelab(
        mapping = aes(
          label = vernacularName.y, 
          fill = posterior
        ),
        geom = "label"
      ) + 
      scale_fill_gradientn(colors = RColorBrewer::brewer.pal(3, "YlGnBu")) +
      theme(legend.position = "right")  

# after reroot
p2 <- trda2 %>%
      ggtree() +
      geom_nodelab(
        mapping = aes(
          x = branch,
          label = bootstrap
        ),
        nudge_y = 0.36
      ) +
      xlim(-.1, 5.5) +
      geom_tippoint(
        mapping = aes(
          shape = trophic_habit,
          color = trophic_habit,
          size = mass_in_kg
        )
      ) +
      scale_size_continuous(range = c(3, 10)) +
      geom_tiplab(
        offset = .14,
      ) +
      geom_nodelab(
        mapping = aes(
          label = vernacularName.y,
          fill = posterior
        ),
        geom = "label"
      ) +
      scale_fill_gradientn(colors = RColorBrewer::brewer.pal(3, "YlGnBu")) +
      theme(legend.position = "right")

plot_list(p1, p2, tag_levels='A', ncol=2)
```


The `outgroup` parameter represents the specific new `outgroup`, it can be a node label (character) or node number. If it is a "single one" value, meaning using the node below this tip as the new root, if it has multiple values, meaning the most recent common of the values will be used as the new root. Note that, if the node labels should be treated as edge labels, the `edgelabel` should be set to `TRUE` to return the correct relationship between the `node` and `associated data`. For more details about re-root, including precautions and pitfalls, please refer to the review article [@reroot_review].

## Rescaling Tree Branches {#rescale-treeio}

Phylogenetic data can be merged for joint analysis (Figure \@ref(fig:correlations)). They can be displayed on the same tree structure as a more complex annotation to help visually inspection of their evolutionary patterns. All the numerical data stored in a `treedata` object can be used to re-scale tree branches. For example, CodeML infers d~N~/d~S~, d~N~, and d~S~, all these statistics can be used as branch lengths (Figure \@ref(fig:rescale)). All these values can also be used to color the tree (session [4.3.4](#color-tree)) and can be projected to a vertical dimension to create a two-dimensional tree or phenogram (session [4.2.2](#layouts-of-phylogenetic-tree) and Figures \@ref(fig:2d) and \@ref(fig:continuousColor)). 



(ref:rescalescap) Rescaling tree branches.

(ref:rescalecap) **Rescaling tree branches.** The tree with branches scaled in time (year from the root) (A). The tree was rescaled using *d~N~* as branch lengths (B). The tree was rescaled using substitution rates (C).

```{r rescale, fig.width=12, fig.height=4.5, message=F, echo=T, fig.cap="(ref:rescalecap)", fig.scap="(ref:rescalescap)", out.extra='', out.width="100%"}
p1 <- ggtree(merged_tree) + theme_tree2()
p2 <- ggtree(rescale_tree(merged_tree, 'dN')) + theme_tree2()
p3 <- ggtree(rescale_tree(merged_tree, 'rate')) + theme_tree2()

plot_list(p1, p2, p3, ncol=3, tag_levels='A')
```

Modifying branch lengths in the tree object in addtion to using the `rescale_tree()` function, users can directly specify a variable as branch length in `ggtree()` as demonstrated in [session 4.3.6](#rescale-tree). 


## Subsetting Tree with Data

### Removing tips in a phylogenetic tree {#remove-tip}

Sometimes we want to remove selected tips from a phylogenetic tree. This is due to several reasons, including low sequence quality, errors in sequence assembly, an alignment error in part of the sequence, an error in phylogenetic inference, *etc*.

Let's say that we want to remove three tips (colored red) from the tree (Figure \@ref(fig:removeTip)A), the `drop.tip()` method removes specified tips and updates the tree (Figure \@ref(fig:removeTip)B). All associated data will be maintained in the updated tree. 

(ref:removeTipscap) Removing tips from a tree.

(ref:removeTipcap) **Removing tips from a tree.** Original tree with three tips (colored red) to remove (A). The updated tree removed selected tips (B).


```{r removeTip, fig.width=12, fig.height=6, fig.cap="(ref:removeTipcap)", fig.scap="(ref:removeTipscap)", out.width="100%"}
f <- system.file("extdata/NHX", "phyldog.nhx", package="treeio")
nhx <- read.nhx(f)
to_drop <- c("Physonect_sp_@2066767",
            "Lychnagalma_utricularia@2253871",
            "Kephyes_ovata@2606431")
p1 <- ggtree(nhx) + geom_tiplab(aes(color = label %in% to_drop)) +
  scale_color_manual(values=c("black", "red")) + xlim(0, 0.8)

nhx_reduced <- drop.tip(nhx, to_drop)
p2 <- ggtree(nhx_reduced) + geom_tiplab() + xlim(0, 0.8)  
plot_list(p1, p2, ncol=2, tag_levels = "A")
```


### Subsetting tree by tip label {#subset-tip}

Sometimes a tree can be large and difficult to look at only the portions of interest. The `tree_subset()` function was created in the `r Biocpkg("treeio")` package [@wang_treeio_2020] to extract a subset of the tree portion while still maintaining the structure of the tree portion. The `beast_tree` in Figure \@ref(fig:subsetTip)A is slightly crowded. Obviously, we can make the figure taller to allow more space for the labels (similar to using the "Expansion" slider in `FigTree`) or we can make the text smaller. However, these solutions are not always applicable when you have a lot of tips (*e.g.*, hundreds or thousands of tips). In particular, when you are only interested in the portion of the tree around a particular tip, you certainly don't want to explore a large tree to find the certain species you are interested in.

Let's say you are interested in tip *A/Swine/HK/168/2012* from the tree (Figure \@ref(fig:subsetTip)A) and you want to look at the immediate relatives of this tip. 

The `tree_subset()` function allows you to look at the portions of the tree that are of interest. By default, the `tree_subset()` function will internally call the [`groupOTU()`](#groupotu) to assign the group specified tip from the rest of the other tips (Figure \@ref(fig:subsetTip)B). Additionally, the branch lengths and related associated data are maintained after subsetting (Figure \@ref(fig:subsetTip)C). The root of the tree is always anchored at zero for the subset tree by default and all the distances are relative to this root. If you want all the distances to be relative to the original root, you can specify the root position (by `root.position` parameter) to the root edge of the subset tree, which is the sum of branch lengths from the original root to the root of the subset tree (Figures \@ref(fig:subsetTip)D and E).

(ref:subsetTipscap) Subsetting tree for a specific tip.

(ref:subsetTipcap) **Subsetting tree for a specific tip.** Original tree (A). Subset tree (B). Subset tree with data (C). Visualize the subset tree relative to the original position, without rootedge (D) and with rootedge (E).

```{r subsetTip, fig.width=12, fig.height=7, echo=T, fig.cap="(ref:subsetTipcap)", fig.scap="(ref:subsetTipscap)", out.extra='', out.width="100%"}
beast_file <- system.file("examples/MCC_FluA_H3.tree", package="ggtree")
beast_tree <- read.beast(beast_file)

p1 = ggtree(beast_tree) + 
  geom_tiplab(offset=.05) +  xlim(0, 40) + theme_tree2()

tree2 = tree_subset(beast_tree, "A/Swine/HK/168/2012", levels_back=4)  
p2 <- ggtree(tree2, aes(color=group)) +
  scale_color_manual(values = c("black", "red"), guide = 'none') +
  geom_tiplab(offset=.2) +  xlim(0, 4.5) + theme_tree2() 

p3 <- p2 +   
  geom_point(aes(fill = rate), shape = 21, size = 4) +
  scale_fill_continuous(low = 'blue', high = 'red') +
  xlim(0,5) + theme(legend.position = 'right')

p4 <- ggtree(tree2, aes(color=group), 
          root.position = as.phylo(tree2)$root.edge) +
  geom_tiplab() + xlim(18, 24) + 
  scale_color_manual(values = c("black", "red"), guide = 'none') +
  theme_tree2()

p5 <- p4 + 
  geom_rootedge() + xlim(0, 50) 

plot_list(p1, p2, p3, p4, p5, 
        design="AABBCC\nAADDEE", tag_levels='A')
```



### Subsetting tree by internal node number {#subset-node}

If you are interested in a certain clade, you can specify the input node as an internal node number. The `tree_subset()` function will take the clade as a whole and also trace it back to particular levels to look at the immediate relatives of the clade (Figures \@ref(fig:subsetNode)A and B). We can use the `tree_subset()` function to zoom in selected portions and plot a whole tree with the portion of it, which is similar to the `ape::zoom()` function to explore a very large tree (Figures \@ref(fig:subsetNode)C and D). Users can also use `viewClade()` function to restrict tree visualization at specific clade as demonstrated in [session 6.1](#viewing-selected-clade).


(ref:subsetNodescap) Subsetting tree for a specific clade.

(ref:ssubsetNodecap) **Subsetting tree for the specific clade.** Extracting a clade (A). Extracting a clade and tracing it back to look at its immediate relatives (B). Viewing a very large tree (C) and a selected portion of it (D).

```{r subsetNode, fig.width=10, fig.height=10, echo=T, fig.cap="(ref:ssubsetNodecap)", fig.scap="(ref:subsetNodescap)", out.extra='', out.width="100%"}
clade <- tree_subset(beast_tree, node=121, levels_back=0)
clade2 <- tree_subset(beast_tree, node=121, levels_back=2)
p1 <- ggtree(clade) + geom_tiplab() + xlim(0, 5)
p2 <- ggtree(clade2, aes(color=group)) + geom_tiplab() + 
  xlim(0, 9) + scale_color_manual(values=c("black", "red"))


library(ape)
library(tidytree)
library(treeio)

data(chiroptera)

nodes <- grep("Plecotus", chiroptera$tip.label)
chiroptera <- groupOTU(chiroptera, nodes)

clade <- MRCA(chiroptera, nodes)
x <- tree_subset(chiroptera, clade, levels_back = 0)

p3 <- ggtree(chiroptera, aes(colour = group)) + 
  scale_color_manual(values=c("black", "red")) +
  theme(legend.position = "none")
p4 <- ggtree(x) + geom_tiplab() + xlim(0, 6)
plot_list(p1, p2, p3, p4, 
  ncol=2, tag_levels = 'A')
```



## Manipulating Tree Data for Visualization {#ggtree-fortify}

Tree visualization is supported by `r Biocpkg("ggtree")` [@yu_ggtree:_2017]. Although `r Biocpkg("ggtree")`\index{ggtree} implemented several methods for [visual exploration of trees with data](#chapter6), you may want to do something that is not supported directly. In this case, you need to manipulate tree data with node coordination positions that are used for visualization. This is quite easy with `r Biocpkg("ggtree")`. Users can use the `fortify()` method which internally calls `tidytree::as_tibble()` to convert the tree to a tidy data frame and add columns of coordination positions (*i.e.*, x, y, branch, and angle) that are used to plot the tree. You can also access the data via `ggtree(tree)$data`.

Here is an example to plot two trees face-to-face that is similar to a graph produced by the `ape::cophyloplot()` function\index{ape} (Figure \@ref(fig:cophylo))\index{geom\textunderscore tree}.



(ref:cophyloscap) Plot two phylogenetic trees face to face.

(ref:cophylocap) **Plot two phylogenetic trees face-to-face.** Plotting a tree using `ggtree()` (left-hand side) and subsequently adding another layer of a tree by `geom_tree()` (right-hand side). The relative positions of the plotted trees can be manually adjusted and adding layers to each of the trees (*e.g.*, tip labels and highlighting clades) is independent.

```{r cophylo, fig.width=8, fig.height=6, message=F, echo=T, fig.cap="(ref:cophylocap)", fig.scap="(ref:cophyloscap)", out.extra='', out.width="100%"}
library(dplyr)
library(ggtree)

set.seed(1024)
x <- rtree(30)
y <- rtree(30)
p1 <- ggtree(x, layout='roundrect') + 
  geom_hilight(
         mapping=aes(subset = node %in% c(38, 48, 58, 36),
                     node = node,
                     fill = as.factor(node)
                     )
     ) +
    labs(fill = "clades for tree in left" )

p2 <- ggtree(y)

d1 <- p1$data
d2 <- p2$data

## reverse x-axis and 
## set offset to make the tree on the right-hand side of the first tree
d2$x <- max(d2$x) - d2$x + max(d1$x) + 1

pp <- p1 + geom_tree(data=d2, layout='ellipse') +      
  ggnewscale::new_scale_fill() +
  geom_hilight(
         data = d2, 
         mapping = aes( 
            subset = node %in% c(38, 48, 58),
            node=node,
            fill=as.factor(node))
  ) +
  labs(fill = "clades for tree in right" ) 

dd <- bind_rows(d1, d2) %>% 
  filter(!is.na(label))

pp + geom_line(aes(x, y, group=label), data=dd, color='grey') +
    geom_tiplab(geom = 'shadowtext', bg.colour = alpha('firebrick', .5)) +
    geom_tiplab(data = d2, hjust=1, geom = 'shadowtext', 
                bg.colour = alpha('firebrick', .5))
```

It is quite easy to plot multiple trees and connect taxa in one figure; for instance, plotting trees constructed from all internal gene segments of influenza virus and connecting equivalent strains across the trees [@venkatesh_avian_2018]. Figure \@ref(fig:cophylo3) demonstrates the usage of plotting multiple trees by combining multiple layers of `geom_tree()`. 


(ref:cophylo3scap) Plot multiple phylogenetic trees side-by-side.

(ref:cophylo3cap) **Plot multiple phylogenetic trees side-by-side.** Plotting a tree using `ggtree()` and subsequently adding multiple layers of trees by `geom_tree()`.

```{r cophylo3, fig.width=8, fig.height=6, message=F, echo=T, fig.cap="(ref:cophylo3cap)", fig.scap="(ref:cophylo3scap)", out.extra='', out.width="100%"}
z <- rtree(30)
d2 <- fortify(y)
d3 <- fortify(z)
d2$x <- d2$x + max(d1$x) + 1
d3$x <- d3$x + max(d2$x) + 1

dd = bind_rows(d1, d2, d3) %>% 
  filter(!is.na(label))

p1 + geom_tree(data = d2) + geom_tree(data = d3) + geom_tiplab(data=d3) + 
  geom_line(aes(x, y, group=label, color=node < 15), data=dd, alpha=.3)
```



## Summary {#summary2}

The `r Biocpkg("treeio")` package allows us to import diverse phylogeny associated data into R. However, a phylogenetic tree is stored in a way to facilitate computational processing which is not human friendly and needs the expertise to manipulate and explore tree data. The `r CRANpkg("tidytree")` package provides a tidy interface for exploring tree data, while `r Biocpkg("ggtree")` provides a set of utilities to visualize and explore tree data using the grammar of graphics. This full suite of packages makes it easy for ordinary users to interact with tree data and allows us to integrate phylogeny associated data from different sources (*e.g.*, experimental results or analysis findings), which creates the possibilities of integrative and comparative study. Moreover, this package suite brings phylogenetic analysis into the tidyverse and certainly takes us to the next level of processing phylogenetic data.


<!--chapter:end:02_tidytree.Rmd-->

\newpage

# Exporting tree with data {#chapter3}


```{r echo=FALSE, results="hide", message=FALSE}
library('jsonlite')
library("treeio")
```

```{r echo=FALSE}
options(show_data_for_treedata = FALSE)
```


## Introduction

The `r Biocpkg("treeio")` package [@wang_treeio_2020] supports parsing various phylogenetic tree file formats including software outputs that contain evolutionary evidence. Some of the formats are just log files
(*e.g.*, `r pkg_paml`
and `r pkg_r8s` output), while some of the others are
non-standard formats (*e.g.*, `r pkg_beast`
and `r pkg_mrbayes` output that introduce a square
bracket, which was reserved to store comments in standard Nexus format, to store
inferences). With `r Biocpkg("treeio")`, we are
now able to parse these files to extract phylogenetic trees and map associated
data on the tree structure. Exporting tree structure is easy, users can use
the `as.phyo()` method defined in `r Biocpkg("treeio")` to
convert a `treedata` object to a `phylo` object and then use `write.tree()` or
`write.nexus()` implemented
in `r CRANpkg("ape")` package
[@paradis_ape_2004] to export the tree structure as Newick text or Nexus file.
This is quite useful for converting non-standard formats to a standard format and
for extracting trees from software outputs, such as log files.

However, exporting a tree with associated data is still challenging. These
associated data can be parsed from analysis programs or obtained from external
sources (*e.g.*, phenotypic data, experimental data, and clinical data). The major
obstacle here is that there is no standard format designed for storing a
tree with data. [NeXML](http://www.nexml.org/) [@vos_nexml:_2012] may be the most
flexible format. However, it is currently not widely supported. Most of the
analysis programs in this field rely extensively on Newick string and Nexus
format. In my opinion, although [BEAST Nexus
format](http://beast.community/nexus_metacomments) may not be the best solution,
it is currently a good approach for storing heterogeneous associated data. The
beauty of the format is that all the annotated elements are stored within square
brackets, which are reserved for comments. In this way, existing programs that can read standard Nexus format are able to parse it by ignoring the annotated elements. 


## Exporting Tree Data to *BEAST* Nexus Format


### Exporting/converting software output

The `r Biocpkg("treeio")` package [@wang_treeio_2020] provides the `write.beast()`\index{BEAST} function to export `treedata` object as BEAST Nexus file [@bouckaert_beast_2014].
With `r Biocpkg("treeio")`, it is easy to convert
software output to BEAST format if the output can be parsed
by `r Biocpkg("treeio")` (see [Chapter 1](#chapter1)). 

Here is an example of converting NHX file to BEAST format:

```{r comment=NA, eval=FALSE}
nhxfile <- system.file("extdata/NHX", "phyldog.nhx", package="treeio")
nhx <- read.nhx(nhxfile)
# write.beast(nhx, file = "phyldog.tree")
write.beast(nhx)
```

```{r echo=FALSE, comment=NA}
x <- '#NEXUS
[R-package treeio, Thu Oct 14 11:24:19 2021]

BEGIN TAXA;
	DIMENSIONS NTAX = 16;
	TAXLABELS
		Prayidae_D27SS7@2825365
		Kephyes_ovata@2606431
		Chuniphyes_multidentata@1277217
		Apolemia_sp_@1353964
		Bargmannia_amoena@263997
		Bargmannia_elongata@946788
		Physonect_sp_@2066767
		Stephalia_dilata@2960089
		Frillagalma_vityazi@1155031
		Resomia_ornicephala@3111757
		Lychnagalma_utricularia@2253871
		Nanomia_bijuga@717864
		Cordagalma_sp_@1525873
		Rhizophysa_filiformis@3073669
		Hydra_magnipapillata@52244
		Ectopleura_larynx@3556167
	;
END;
BEGIN TREES;
	TRANSLATE
		1	Prayidae_D27SS7@2825365,
		2	Kephyes_ovata@2606431,
		3	Chuniphyes_multidentata@1277217,
		4	Apolemia_sp_@1353964,
		5	Bargmannia_amoena@263997,
		6	Bargmannia_elongata@946788,
		7	Physonect_sp_@2066767,
		8	Stephalia_dilata@2960089,
		9	Frillagalma_vityazi@1155031,
		10	Resomia_ornicephala@3111757,
		11	Lychnagalma_utricularia@2253871,
		12	Nanomia_bijuga@717864,
		13	Cordagalma_sp_@1525873,
		14	Rhizophysa_filiformis@3073669,
		15	Hydra_magnipapillata@52244,
		16	Ectopleura_larynx@3556167
	;
	TREE * UNTITLED = [&R] (((1[&Ev=S,ND=0,S=58]:0.0682841,(2[&Ev=S,ND=1,
S=69]:0.0193941,3[&Ev=S,ND=2,S=70]:0.0121378)[&Ev=S,ND=3,S=60]:0.0217782)
[&Ev=S,ND=4,S=36]:0.0607598,((4[&Ev=S,ND=9,S=31]:0.11832,(((5[&Ev=S,ND=10,
S=37]:0.0144549,6[&Ev=S,ND=11,S=38]:0.0149723)[&Ev=S,ND=12,S=33]:0.0925388,
7[&Ev=S,ND=13,S=61]:0.077429)[&Ev=S,ND=14,S=24]:0.0274637,(8[&Ev=S,ND=15,
S=52]:0.0761163,((9[&Ev=S,ND=16,S=53]:0.0906068,10[&Ev=S,ND=17,S=54]:1e-06)
[&Ev=S,ND=18,S=45]:1e-06,((11[&Ev=S,ND=19,S=65]:0.120851,12[&Ev=S,ND=20,
S=71]:0.133939)[&Ev=S,ND=21,S=56]:1e-06,13[&Ev=S,ND=22,S=64]:0.0693814)
[&Ev=S,ND=23,S=46]:1e-06)[&Ev=S,ND=24,S=40]:0.0333823)[&Ev=S,ND=25,S=35]:
1e-06)[&Ev=D,ND=26,S=24]:0.0431861)[&Ev=S,ND=27,S=19]:1e-06,14[&Ev=S,ND=28,
S=26]:0.22283)[&Ev=S,ND=29,S=17]:0.0292362)[&Ev=D,ND=8,S=17]:0.185603,
(15[&Ev=S,ND=5,S=16]:0.0621782,16[&Ev=S,ND=6,S=15]:0.332505)[&Ev=S,ND=7,
S=12]:0.185603)[&Ev=S,ND=30,S=9];
END;'

writeLines(x)
```

Another example of converting `r pkg_codeml` output to BEAST format:

```{r comment=NA, eval=FALSE}
mlcfile <- system.file("extdata/PAML_Codeml", "mlc", package="treeio")
ml <- read.codeml_mlc(mlcfile)
# write.beast(ml, file = "codeml.tree")
write.beast(ml) # output not shown
```

```{r echo=FALSE, comment=NA, eval=FALSE}
x <- '#NEXUS
[R-package treeio, Thu Oct 14 11:27:48 2021]

BEGIN TAXA;
	DIMENSIONS NTAX = 15;
	TAXLABELS
		A
		B
		C
		D
		E
		F
		G
		H
		I
		J
		K
		L
		M
		N
		O
	;
END;
BEGIN TREES;
	TRANSLATE
		1	A,
		2	B,
		3	C,
		4	D,
		5	E,
		6	F,
		7	G,
		8	H,
		9	I,
		10	J,
		11	K,
		12	L,
		13	M,
		14	N,
		15	O
	;
	TREE * UNTITLED = [&U] (11[&t=0.082,N=1514.9,S=633.1,dN_vs_dS=0.0224,
dN=0.002,dS=0.0878,N_x_dN=3,S_x_dS=55.6]:0.081785,14[&t=0.062,N=1514.9,
S=633.1,dN_vs_dS=0.0095,dN=7e-04,dS=0.0689,N_x_dN=1,S_x_dS=43.6]:0.062341,
(4[&t=0.082,N=1514.9,S=633.1,dN_vs_dS=0.0385,dN=0.0033,dS=0.0849,N_x_dN=5,
S_x_dS=53.8]:0.082021,(12[&t=0.006,N=1514.9,S=633.1,dN_vs_dS=1e-04,dN=0,
dS=0.0062,N_x_dN=0,S_x_dS=3.9]:0.005508,(10[&t=0.014,N=1514.9,S=633.1,
dN_vs_dS=0.0457,dN=7e-04,dS=0.0143,N_x_dN=1,S_x_dS=9]:0.013996,(7[&t=0.046,
N=1514.9,S=633.1,dN_vs_dS=0.1621,dN=0.006,dS=0.0373,N_x_dN=9.2,S_x_dS=23.6]:
0.045746,((3[&t=0.028,N=1514.9,S=633.1,dN_vs_dS=0.0461,dN=0.0013,dS=0.0282,
N_x_dN=2,S_x_dS=17.9]:0.02773,(5[&t=0.031,N=1514.9,S=633.1,dN_vs_dS=0.0641,
dN=0.002,dS=0.0305,N_x_dN=3,S_x_dS=19.3]:0.031104,15[&t=0.048,N=1514.9,
S=633.1,dN_vs_dS=0.0538,dN=0.0026,dS=0.0485,N_x_dN=4,S_x_dS=30.7]:0.048389)
23[&t=0.008,N=1514.9,S=633.1,dN_vs_dS=1e-04,dN=0,dS=0.0094,N_x_dN=0,
S_x_dS=6]:0.008328)22[&t=0.016,N=1514.9,S=633.1,dN_vs_dS=0.0395,dN=7e-04,
dS=0.0165,N_x_dN=1,S_x_dS=10.4]:0.015959,(8[&t=0.021,N=1514.9,S=633.1,
dN_vs_dS=0.1028,dN=0.002,dS=0.0191,N_x_dN=3,S_x_dS=12.1]:0.021007,
(9[&t=0.015,N=1514.9,S=633.1,dN_vs_dS=1e-04,dN=0,dS=0.0167,N_x_dN=0,
S_x_dS=10.6]:0.014739,(2[&t=0.032,N=1514.9,S=633.1,dN_vs_dS=1e-04,
dN=0,dS=0.0358,N_x_dN=0,S_x_dS=22.7]:0.031643,(1[&t=0.01,N=1514.9,
S=633.1,dN_vs_dS=0.0646,dN=7e-04,dS=0.0101,N_x_dN=1,S_x_dS=6.4]:0.01034,
(6[&t=0.007,N=1514.9,S=633.1,dN_vs_dS=0.298,dN=0.0013,dS=0.0044,N_x_dN=2,
S_x_dS=2.8]:0.006649,13[&t=0.009,N=1514.9,S=633.1,dN_vs_dS=0.0738,dN=7e-04,
dS=0.0088,N_x_dN=1,S_x_dS=5.6]:0.009195)28[&t=0.028,N=1514.9,S=633.1,
dN_vs_dS=0.0453,dN=0.0013,dS=0.0289,N_x_dN=2,S_x_dS=18.3]:0.028303)27
[&t=0.008,N=1514.9,S=633.1,dN_vs_dS=0.0863,dN=7e-04,dS=0.0076,N_x_dN=1,
S_x_dS=4.8]:0.008072)26[&t=0.003,N=1514.9,S=633.1,dN_vs_dS=1.5591,dN=0.0013,
dS=8e-04,N_x_dN=2,S_x_dS=0.5]:0.0035)25[&t=0.02,N=1514.9,S=633.1,
dN_vs_dS=1e-04,dN=0,dS=0.023,N_x_dN=0,S_x_dS=14.6]:0.020359)24[&t=0.001,
N=1514.9,S=633.1,dN_vs_dS=1e-04,dN=0,dS=6e-04,N_x_dN=0,S_x_dS=0.4]:0.000555)
21[&t=0.024,N=1514.9,S=633.1,dN_vs_dS=0.0549,dN=0.0013,dS=0.0237,N_x_dN=2,
S_x_dS=15]:0.023675)20[&t=0.046,N=1514.9,S=633.1,dN_vs_dS=0.0419,dN=0.002,
dS=0.047,N_x_dN=3,S_x_dS=29.8]:0.045745)19[&t=0.015,N=1514.9,S=633.1,
dN_vs_dS=1e-04,dN=0,dS=0.0166,N_x_dN=0,S_x_dS=10.5]:0.014684)18[&t=0.059,
N=1514.9,S=633.1,dN_vs_dS=0.0964,dN=0.0053,dS=0.0545,N_x_dN=8,S_x_dS=34.5]:
0.059308)17[&t=0.232,N=1514.9,S=633.1,dN_vs_dS=0.0129,dN=0.0033,dS=0.2541,
N_x_dN=5,S_x_dS=160.9]:0.231628)16;
END;'

writeLines(x)
```

Some software tools that do not support these outputs can be supported through data conversion. For example, we can convert the NHX file to BEAST file and use NHX tags to color the tree using
`r pkg_figtree` (Figure \@ref(fig:beastFigtree)A) or convert `r pkg_codeml` output and use
*d~N~/d~S~*, *d~N~*, or *d~S~* to color the tree in `r pkg_figtree` (Figure \@ref(fig:beastFigtree)B). Before conversion, these files could not be opened in Figtree. Treeio's conversion function makes data available to other software tools and expands the application range of these tools.

(ref:beastFigtreescap) Visualizing BEAST file in FigTree.

(ref:beastFigtreecap) **Visualizing BEAST file in FigTree.** Directly visualizing `NHX` file (A) and `CodeML` output (B) in `FigTree` is not supported. `treeio` can convert these files to BEAST compatible NEXUS format which can be directly opened in `FigTree` and visualized together with annotated data.

```{r beastFigtree, fig.width=8, fig.height=9.6, echo=FALSE, fig.cap="(ref:beastFigtreecap)", fig.scap="(ref:beastFigtreescap)", out.width="100%"}
# knitr::include_graphics("img/phyldog.png")
# knitr::include_graphics("img/codeml.png")

p1 = magick::image_read("img/phyldog.png")
p2 = magick::image_read("img/codeml.png")
g1 = ggplotify::as.ggplot(p1)
g2 = ggplotify::as.ggplot(p2)
cowplot::plot_grid(g1, g2, ncol=1, labels=c("A", "B"), 
    rel_heights=c(1.18, 1))
```


### Combining tree with external data

Using the utilities provided
by `r CRANpkg("tidytree")` and `r Biocpkg("treeio")`, it is easy to link
external data onto the corresponding phylogeny. The `write.beast()` function enables users to export the tree with external data to a single tree file\index{data integration}.

```{r comment=NA, results='hide'}
phylo <- as.phylo(nhx)
## save space for printing the tree text
phylo$edge.length <- round(phylo$edge.length, 2)

## print the newick text
write.tree(phylo)
```

```{r echo=FALSE, comment=NA}
x <- "(((Prayidae_D27SS7@2825365:0.07,(Kephyes_ovata@2606431:0.02,
Chuniphyes_multidentata@1277217:0.01):0.02):0.06,((Apolemia_sp_@1353964:0.12,
(((Bargmannia_amoena@263997:0.01,Bargmannia_elongata@946788:0.01):0.09,
Physonect_sp_@2066767:0.08):0.03,(Stephalia_dilata@2960089:0.08,
((Frillagalma_vityazi@1155031:0.09,Resomia_ornicephala@3111757:0):0,
((Lychnagalma_utricularia@2253871:0.12,Nanomia_bijuga@717864:0.13):0,
Cordagalma_sp_@1525873:0.07):0):0.03):0):0.04):0,Rhizophysa_filiformis@3073669:
0.22):0.03):0.19,(Hydra_magnipapillata@52244:0.06,
Ectopleura_larynx@3556167:0.33):0.19);"

writeLines(x)
```


```{r results='hide'}
N <- Nnode2(phylo)
fake_data <- tibble(node = 1:N, fake_trait = round(rnorm(N), 2), 
                    another_trait = round(runif(N), 2))
fake_tree <- full_join(phylo, fake_data, by = "node")
# write.beast(fake_tree)

## to save space, use a subtree
fake_tree2 = tree_subset(fake_tree, node=27, levels_back=0)
write.beast(fake_tree2)
```


```{r echo=FALSE, comment=NA}
x <- "#NEXUS
[R-package treeio, Tue Nov 16 10:13:32 2021]

BEGIN TAXA;
	DIMENSIONS NTAX = 5;
	TAXLABELS
		Frillagalma_vityazi@1155031
		Resomia_ornicephala@3111757
		Lychnagalma_utricularia@2253871
		Nanomia_bijuga@717864
		Cordagalma_sp_@1525873
	;
END;
BEGIN TREES;
	TRANSLATE
		1	Frillagalma_vityazi@1155031,
		2	Resomia_ornicephala@3111757,
		3	Lychnagalma_utricularia@2253871,
		4	Nanomia_bijuga@717864,
		5	Cordagalma_sp_@1525873
	;
	TREE * UNTITLED = [&R] ((1[&fake_trait=-1.42,another_trait=0.17]:0.09,
2[&fake_trait=0.19,another_trait=0.04]:0)[&fake_trait=0.85,
another_trait=0.56]:0,(5[&fake_trait=0.22,another_trait=0.73]:0.07,
(3[&fake_trait=0.02,another_trait=0.29]:0.12,4[&fake_trait=-1.29,
another_trait=0.35]:0.13)[&fake_trait=-0.33,another_trait=0.88]:0)
[&fake_trait=0.27,another_trait=0.94]:0):0.29;
END;"

writeLines(x)
```


After merging, the `fake_trait` and `another_trait` stored in `fake_data` will be linked to the tree, `phylo`, and stored in the `treedata` object, the `fake_tree`. The `write.beast()` function exports the tree with associated data to a single BEAST format file. The associated data can be used to visualize the tree using `r Biocpkg("ggtree")` (Figure \@ref(fig:beast)) or `r pkg_figtree` (Figure \@ref(fig:beastFigtree)).


### Merging tree data from different sources

Not only Newick tree text can be combined with associated data, but also tree
data obtained from software output can be combined with external data, as well
as different tree objects can be merged (for details, see [Chapter 2](#chapter2)).


```{r}
## combine tree object with data
tree_with_data <- full_join(nhx, fake_data, by = "node")
tree_with_data

## merge two tree object
tree2 <- merge_tree(nhx, fake_tree)
identical(tree_with_data, tree2)
```

After merging data from different sources, the tree with the associated data can
be exported into a single file.

```{r comment=NA}
outfile <- tempfile(fileext = ".tree")
write.beast(tree2, file = outfile)
```

The output BEAST Nexus file can be imported into R using the `read.beast`
function and all the associated data can be used to annotate the tree
using [ggtree](https://bioconductor.org/packages/ggtree/) [@yu_ggtree:_2017].


```{r}
read.beast(outfile)
```

## Exporting Tree Data to the *jtree* Format {#write-jtree}

The `r Biocpkg("treeio")` package [@wang_treeio_2020] provides the
`write.beast()` function to export `treedata` to BEAST Nexus file. This is quite useful
to convert file format, combine tree with data and merge tree data from
different sources as we demonstrated in
[the previous session](#exporting-tree-data-to-beast-nexus-format).
The `r Biocpkg("treeio")` package also supplies
the `read.beast()` function to parse the output file of the `write.beast()` function. Although
with `r Biocpkg("treeio")`, the R community has the ability to
manipulate BEAST Nexus format and process tree data, there is still a lacking
library/package for parsing BEAST files in other programming languages. 

[JSON](https://www.json.org/) (JavaScript Object Notation) is a lightweight data-interchange format and
is widely supported in almost all modern programming languages. To make it easy
to import a tree with data in other programming
languages, `r Biocpkg("treeio")` supports
exporting a tree with data in the `jtree` format, which is JSON-based and can be easy to parse using any language that supports JSON.


```{r subtree-jtree, echo=FALSE}
tree3 <- tree_subset(tree2, node=24, levels_back=0) 
```

```{r comment=NA, eval=FALSE}
# write.jtree(tree2)

# to save space, use a subtree
tree3 <- tree_subset(tree2, node=24, levels_back=0) 
write.jtree(tree3)
```

```{r print-jtree, comment=NA, echo=FALSE}
x <- '{
	"tree": "(Physonect_sp_@2066767:0.077429{3},(Bargmannia_amoena@263997:0.0144549
{1},Bargmannia_elongata@946788:0.0149723{2}):0.0925388{5}):0.28549{4};",
	"data":[
  {
    "edge_num": 1,
    "Ev": "S",
    "ND": 10,
    "S": 37,
    "fake_trait": -0.69,
    "another_trait": 0.42
  },
  {
    "edge_num": 2,
    "Ev": "S",
    "ND": 11,
    "S": 38,
    "fake_trait": -0.95,
    "another_trait": 0.38
  },
  {
    "edge_num": 3,
    "Ev": "S",
    "ND": 13,
    "S": 61,
    "fake_trait": 0.59,
    "another_trait": 0.65
  },
  {
    "edge_num": 4,
    "Ev": "S",
    "ND": 14,
    "S": 24,
    "fake_trait": -0.69,
    "another_trait": 0.06
  },
  {
    "edge_num": 5,
    "Ev": "S",
    "ND": 12,
    "S": 33,
    "fake_trait": -0.58,
    "another_trait": 0.4
  }
],
	"metadata": {"info": "R-package treeio", "data": "Tue Nov 16 10:21:20 2021"}
}'

writeLines(x)
```

The `jtree` format is based on JSON and can be parsed using JSON parser.

```{r comment=NA, results='hide'}
jtree_file <- tempfile(fileext = '.jtree')
write.jtree(tree3, file = jtree_file)
jsonlite::fromJSON(jtree_file)
```

```{r print-json, comment=NA, echo=FALSE}
x <- '$tree
[1] "(Physonect_sp_@2066767:0.077429{3},(Bargmannia_amoena@263997:0.0144549{1},
Bargmannia_elongata@946788:0.0149723{2}):0.0925388{5}):0.28549{4};"

$data
  edge_num Ev ND  S fake_trait another_trait
1        1  S 10 37      -0.69          0.42
2        2  S 11 38      -0.95          0.38
3        3  S 13 61       0.59          0.65
4        4  S 14 24      -0.69          0.06
5        5  S 12 33      -0.58          0.40

$metadata
$metadata$info
[1] "R-package treeio"

$metadata$data
[1] "Tue Nov 16 10:24:34 2021"'

writeLines(x)
```


The `jtree` file can be directly imported as a `treedata` object using
the `read.jtree()` function provided also
in `r Biocpkg("treeio")` package (see also [session 1.3](#jtree)).

```{r}
read.jtree(jtree_file)
```

## Summary {#summary3}

Phylogenetic tree-associated data is often stored in a separate file and needs the expertise to map the data to the tree structure. Lacking standardization to store and represent phylogeny and associated data makes it difficult for researchers to access and integrate the phylogenetic data into their studies. The `r Biocpkg("treeio")`\index{treeio} package provides functions to import phylogeny with associated data from several sources, including analysis findings from commonly used software and external data such as experimental data, clinical data, or meta-data. These trees and their associated data can be exported into a single file as `BEAST` or `jtree` formats, and the output file can be parsed back to R by `r Biocpkg("treeio")` and the data is easy to access. The input and output utilities supplied by `r Biocpkg("treeio")` package lay the foundation for phylogenetic data integration for downstream comparative study and visualization. It creates the possibility of integrating a tree with associated data from different sources and extends the applications of phylogenetic analysis in different disciplines. 

<!--chapter:end:03_treeio_exporting_tree.Rmd-->

# (PART\*) Part II: Tree data visualization and annotation {-}

\newpage


# Phylogenetic Tree Visualization {#chapter4}

```{r include=F}
library("ape")
library("grid")
library("ggplot2")
library("cowplot")
library("treeio")
library("ggtree")
```


## Introduction

There are many software packages and web tools that are designed for displaying phylogenetic trees, such as `r pkg_treeview` [@page_visualizing_2002], `r pkg_figtree`\index{FigTree}, `r pkg_treedyn` [@chevenet_treedyn:_2006], *Dendroscope* [@huson_dendroscope_2012], `r pkg_evolview`\index{EvolView} [@he_evolview_2016], and `r pkg_itol`\index{iTOL} [@letunic_interactive_2007], *etc*. Only a few of them, such as `r pkg_figtree`, `r pkg_treedyn` and `r pkg_itol`, allow users to annotate the trees with colored branches, highlighted clades with tree features. However, their pre-defined annotating functions are usually limited to some specific phylogenetic data. As phylogenetic trees are becoming more widely used in multidisciplinary studies, there is an increasing need to incorporate various types of phylogenetic covariates and other associated data from different sources into the trees for visualizations and further analyses. For instance, the influenza virus has a wide host range, diverse and dynamic genotypes, and characteristic transmission behaviors that are mostly associated with the virus's evolution and essentially among themselves. Therefore, in addition to standalone applications that focus on each of the specific analysis and data types, researchers studying molecular evolution need a robust and programmable platform that allows the high levels of integration and visualization of many of these different aspects of data (raw or from other primary analyses) over the phylogenetic trees to identify their associations and patterns.


To fill this gap, we developed `r Biocpkg("ggtree")`\index{ggtree} [@yu_ggtree:_2017], a package for the R programming language [@rstats] released under the Bioconductor\index{Bioconductor} project [@gentleman_bioconductor_2004]. The `r Biocpkg("ggtree")` is built to work with `treedata` objects (see Chapters [1](#chapter1) and [9](#chapter9)), and display tree graphics with the `r CRANpkg("ggplot2")` package [@wickham_ggplot2_2016] that was based on the grammar of graphics [@wilkinson_grammar_2005]. 


The R language is increasingly used in phylogenetics. However, a comprehensive package, designed for viewing and annotating phylogenetic trees, particularly with complex data integration, is not yet available. Most of the R packages in phylogenetics focus on specific statistical analyses rather than viewing and annotating the trees with more generalized phylogeny-associated data. Some packages, including `r CRANpkg("ape")`\index{ape} [@paradis_ape_2004] and `r CRANpkg("phytools")` [@revell_phytools_2012], which are capable of displaying and annotating trees, are developed using the base graphics system of R. In particular, `r CRANpkg("ape")` is one of the fundamental packages for phylogenetic analysis and data processing. However, the base graphics system is relatively difficult to extend and limits the complexity of the tree figure to be displayed. `r CRANpkg("OutbreakTools")` [@jombart_outbreaktools_2014] and `r Biocpkg("phyloseq")` [@mcmurdie_phyloseq_2013] extended `r CRANpkg("ggplot2")` to plot phylogenetic trees. The `r CRANpkg("ggplot2")` system of graphics allows rapid customization and exploration of design solutions. However, these packages were designed for epidemiology and microbiome data respectively and did not aim to provide a general solution for tree visualization\index{visualization} and annotation\index{annotation}. The `r Biocpkg("ggtree")` package also inherits versatile properties of `r CRANpkg("ggplot2")`, and more importantly allows constructing complex tree figures by freely combining multiple layers of annotations (see also [Chapter 5](#chapter5)) using the tree associated data imported from different sources (see detailed in [Chapter 1](#chapter1) and [@wang_treeio_2020]).


## Visualizing Phylogenetic Tree with `r Biocpkg("ggtree")`


The `r Biocpkg("ggtree")` package [@yu_ggtree:_2017] is designed for annotating phylogenetic trees with their associated data of different types and from various sources. These data could come from users or analysis programs and might include evolutionary rates, ancestral sequences\index{ancestral sequences}, *etc.* that are associated with the taxa from real samples, or with the internal nodes representing hypothetic ancestor strain/species, or with the tree branches indicating evolutionary time courses [@wang_treeio_2020]. For instance, the data could be the geographic positions of the sampled avian influenza viruses (informed by the survey locations) and the ancestral nodes (by phylogeographic inference) in the viral gene tree [@lam_phylodynamics_2012].

The `r Biocpkg("ggtree")` supports `r CRANpkg("ggplot2")`'s graphical language, which allows a high level of customization, is intuitive and flexible. Notably, `r CRANpkg("ggplot2")` itself does not provide low-level geometric objects or other support for tree-like structures, and hence `r Biocpkg("ggtree")` is a useful extension in that regard. Even though the other two phylogenetics-related R packages, `r CRANpkg("OutbreakTools")`, and `r Biocpkg("phyloseq")`, are developed based on `r CRANpkg("ggplot2")`, the most valuable part of the `r CRANpkg("ggplot2")`\index{ggplot2} syntax - adding layers of annotations - is not supported in these packages. For example, if we have plotted a tree without taxa labels, `r CRANpkg("OutbreakTools")` and `r Biocpkg("phyloseq")` provide no easy way for general `R` users, who have little knowledge about the infrastructures of these packages, to add a layer of taxa labels. The `r Biocpkg("ggtree")` extends `r CRANpkg("ggplot2")` to support tree objects by implementing a geometric layer, `geom_tree()`, to support visualizing tree structure. In `r Biocpkg("ggtree")`, viewing a phylogenetic tree is relatively easy, via the command `ggplot(tree_object) + geom_tree() + theme_tree()` or `ggtree(tree_object)` for short. Layers of annotations can be added one-by-one via the `+` operator. To facilitate tree visualization, `r Biocpkg("ggtree")` provides several geometric layers, including `geom_treescale()` for adding legend of tree branch scale (genetic distance, divergence time, *etc.*), `geom_range()` for displaying uncertainty of branch lengths (confidence interval or range, *etc.*), `geom_tiplab()` for adding taxa label, `geom_tippoint()` and `geom_nodepoint()` for adding symbols of tips and internal nodes, `geom_hilight()` for highlighting clades with rectangle, and `geom_cladelab()` for annotating selected clades with bar and text label, *etc.*. A full list of geometric layers provided by `r Biocpkg("ggtree")` is summarized in Table \@ref(tab:geoms).


To view a phylogenetic tree, we first need to parse the tree file into `R`. 
The `r Biocpkg("treeio")` package is able to parse diverse annotation data from different software outputs into `S4` phylogenetic data objects (see also [Chapter 1](#chapter1)). The `r Biocpkg("ggtree")` package mainly utilizes these `S4` objects to display and annotate the tree. Other R packages defined `S3`/`S4` classes to store phylogenetic trees with domain-specific associated data, including `phylo4` and `phylo4d` defined in the `r CRANpkg("phylobase")` package, `obkdata` defined in the `r CRANpkg("OutbreakTools")` package, and `phyloseq` defined in the `r Biocpkg("phyloseq")` package, *etc*. All these tree objects are also supported in `r Biocpkg("ggtree")` and their specific annotation data can be used to annotate the tree directly in `r Biocpkg("ggtree")` (see also [Chapter 9](#chapter9)). Such compatibility of `r Biocpkg("ggtree")` facilitates the integration of data and analysis results. In addition, `r Biocpkg("ggtree")` also supports other tree-like structures, including [dendrogram](#dendrogram) and [tree graphs](#igraph).


### Basic Tree Visualization

The `r Biocpkg('ggtree')` package extends `r CRANpkg('ggplot2')` [@wickham_ggplot2_2016] package to support viewing a phylogenetic tree.
It implements `geom_tree()`\index{geom\textunderscore tree} layer for displaying a phylogenetic tree, as shown below in Figure \@ref(fig:basicviz)A.


```{r fig.width=3, fig.height=3, fig.align="center", eval=F}
library("treeio")
library("ggtree")

nwk <- system.file("extdata", "sample.nwk", package="treeio")
tree <- read.tree(nwk)

ggplot(tree, aes(x, y)) + geom_tree() + theme_tree()
```

The function, `ggtree()`, was implemented as a shortcut to visualize a tree, and it works exactly the same as shown above.

The `r Biocpkg('ggtree')` package takes all the advantages of `r CRANpkg('ggplot2')`. For example, we can change the color, size, and type of the lines as we do with `r CRANpkg('ggplot2')` (Figure \@ref(fig:basicviz)B).

```{r fig.width=3, fig.height=3, fig.align="center", eval=F}
ggtree(tree, color="firebrick", size=2, linetype="dotted")
```

By default, the tree is viewed in ladderize form, user can set the parameter `ladderize = FALSE` to disable it (Figure \@ref(fig:basicviz)C, see also [FAQ A.5](#branch-setting)).

```{r fig.width=3, fig.height=3, fig.align="center", eval=F}
ggtree(tree, ladderize=FALSE)
```

The `branch.length` is used to scale the edge, user can set the parameter `branch.length = "none"` to only view the tree topology (cladogram, Figure \@ref(fig:basicviz)D) or other numerical variables to scale the tree (*e.g.*, _d~N~/d~S~_, see also in [Chapter 5](#chapter5)).

```{r fig.width=3, fig.height=3, fig.align="center", eval=F}
ggtree(tree, branch.length="none")
```



(ref:basicvizscap) Basic tree visualization.

(ref:basicvizcap) **Basic tree visualization.** Default ggtree output with ladderized effect (A), non-variable setting (*e.g.*, color, size, line type) (B), non-ladderized tree (C), cladogram that only displays tree topology without branch length information (D).


```{r basicviz, fig.width=12, fig.height=3, echo=F, fig.cap="(ref:basicvizcap)", fig.scap="(ref:basicvizscap)", out.width="100%"}

library("treeio")
library("ggtree")

nwk <- system.file("extdata", "sample.nwk", package="treeio")
tree <- read.tree(nwk)

aplot::plot_list(
    ggplot(tree, aes(x, y)) + geom_tree() + theme_tree(),
    ggtree(tree, color="firebrick", size=2, linetype="dotted"),
    ggtree(tree, ladderize=FALSE),
    ggtree(tree, branch.length="none"),
    ncol=4, tag_levels='A')
```

### Layouts of a phylogenetic tree {#tree-layouts}

Viewing phylogenetic with `r Biocpkg("ggtree")` is quite simple, just pass the tree object to the `ggtree()` function. We have developed several types of layouts for tree presentation (Figure \@ref(fig:layout)), including *rectangular* (by default), *roundrect* (rounded rectangular), *ellipse*, *slanted*, *circular*, *fan*, *unrooted*\index{unrooted} (equal angle and daylight methods), time-scaled, and two-dimensional layouts\index{tree layout}. 

Here are examples of visualizing a tree with different layouts:


```{r eval=F}
library(ggtree)
set.seed(2017-02-16)
tree <- rtree(50)
ggtree(tree)
ggtree(tree, layout="roundrect")
ggtree(tree, layout="slanted")
ggtree(tree, layout="ellipse")
ggtree(tree, layout="circular")
ggtree(tree, layout="fan", open.angle=120)
ggtree(tree, layout="equal_angle")
ggtree(tree, layout="daylight")
ggtree(tree, branch.length='none')
ggtree(tree, layout="ellipse", branch.length="none")
ggtree(tree, branch.length='none', layout='circular')
ggtree(tree, layout="daylight", branch.length = 'none')
```



(ref:layoutscap) Tree layouts.

(ref:layoutcap) **Tree layouts.** Phylogram: rectangular layout (A), rounded rectangular layout (B), slanted layout (C), ellipse layout (D), circular layout (E), and fan layout (F). Unrooted: equal-angle method (G) and daylight method (H). Cladogram: rectangular layout (I), ellipse (J), circular layout (K), and unrooted layout (L). Slanted and fan layouts for cladogram are also supported.

```{r layout, echo=F, fig.width=12, fig.height=9, fig.cap="(ref:layoutcap)", fig.scap="(ref:layoutscap)", out.extra='', message=FALSE, out.width="100%"}
library(ggtree)
library(cowplot)

set.seed(2017-02-16)
tree <- rtree(50)
p1 <- ggtree(tree, layout="circular")
p2 <- ggtree(tree, layout="fan", open.angle=120)
#p1 <- ggplotify::as.ggplot(p1, scale=1.05)
#p2 <- ggplotify::as.ggplot(p2, scale=1.05)

playout <- plot_grid(
  ggtree(tree), # + ggtitle("rectangular layout")+theme(plot.title = element_text(hjust = 0.5)),
  ggtree(tree, layout="roundrect"),
  ggtree(tree, layout="slanted"), # + ggtitle("slanted layout")+theme(plot.title = element_text(hjust = 0.5)),
  ggtree(tree, layout="ellipse"),
  p1, # + ggtitle("circular layout")+theme(plot.title = element_text(hjust = 0.5), plot.margin = unit(c(0,0,0,0), "lines")),
  p2, # + ggtitle("fan layout")+theme(plot.title = element_text(hjust = 0.5), plot.margin = unit(c(0,0,0,0), "lines")),
  ggtree(tree, layout="equal_angle"),
  ggtree(tree, layout="daylight"),  
  ggtree(tree, branch.length='none'),
  ggtree(tree, layout="ellipse", branch.length="none"),
  ggtree(tree, branch.length='none', layout='circular'),
  ggtree(tree, layout="daylight", branch.length = 'none'),
  ncol=4, labels = LETTERS[1:12])
# save(playout, file="data/playout.rda")
playout
```


Other possible layouts that can be drawn by modifying
scales/coordination (Figure \@ref(fig:layout2)).

<!-- for examples, [reverse label of time
scale](https://github.com/GuangchuangYu/ggtree/issues/87), [repropotion
circular/fan tree](
https://groups.google.com/d/msg/bioc-ggtree/UoGQekWHIvw/ZswUUZKSGwAJ), *etc.*. -->

```{r eval=FALSE}
ggtree(tree) + scale_x_reverse()
ggtree(tree) + coord_flip()
ggtree(tree) + layout_dendrogram()
ggplotify::as.ggplot(ggtree(tree), angle=-30, scale=.9)
ggtree(tree, layout='slanted') + coord_flip()
ggtree(tree, layout='slanted', branch.length='none') + layout_dendrogram()
ggtree(tree, layout='circular') + xlim(-10, NA)
ggtree(tree) + layout_inward_circular()
ggtree(tree) + layout_inward_circular(xlim=15)
```

```{r fig.keep='none', echo=FALSE, warning=FALSE}
# tree_angle <- grid::grid.grabExpr(print(ggtree(tree), newpage=TRUE, vp = grid::viewport(angle=-30, width=.9, height=.9)))
tree_angle <- ggplotify::as.ggplot(ggtree(tree), angle=-30, scale=.9)
```



(ref:layout2scap) Derived Tree layouts.

(ref:layout2cap) **Derived Tree layouts.** right-to-left rectangular layout (A), bottom-up rectangular layout (B), top-down rectangular layout (Dendrogram) (C), rotated rectangular layout (D), bottom-up slanted layout (E), top-down slanted layout (Cladogram) (F), circular layout (G), circular inward layout (H and I). 

```{r layout2, fig.cap="(ref:layout2cap)", fig.scap="(ref:layout2scap)", fig.width=8, fig.height = 8, echo=FALSE, warning=FALSE, out.width="100%"}
plot_grid(
    ggtree(tree) + scale_x_reverse(),
    ggtree(tree) + coord_flip(),
    ggtree(tree) + layout_dendrogram(),
    tree_angle,
    ggtree(tree, layout='slanted') + coord_flip(),
    ggtree(tree, layout='slanted', branch.length='none') + layout_dendrogram(),
    ggtree(tree, layout='circular') + xlim(-10, NA),
#    ggtree(tree) + scale_x_reverse() + coord_polar(theta='y'),
#    ggtree(tree) + scale_x_reverse(limits=c(15, 0)) + coord_polar(theta='y'),
    ggtree(tree) + layout_inward_circular(),
    ggtree(tree) + layout_inward_circular(xlim=15),
    ncol=3, labels=LETTERS[1:9])

```



**Phylogram.** Layouts of *rectangular*, *roundrect*, *slanted*, *ellipse*, *circular*, and *fan* are supported to visualize phylogram\index{phylogram} (by default, with branch length scaled) as demonstrated in Figures \@ref(fig:layout)A-F.


**Unrooted layout.** Unrooted (also called `r squote('radial')`) layout is supported by equal-angle and daylight algorithms; users can specify unrooted layout algorithm by passing "equal_angle" or "daylight" to `layout` parameter to visualize the tree. The equal-angle method was proposed by Christopher Meacham in *PLOTREE*, which was incorporated in `r pkg_phylip` [@retief_phylogenetic_2000]. This method starts from the root of the tree and allocates arcs of angle to each subtree proportional to the number of tips in it. It iterates from root to tips and subdivides the angle allocated to a subtree into angles for its dependent subtrees. This method is fast and was implemented in many software packages. As shown in Figure \@ref(fig:layout)G, the equal angle method has a drawback that tips tend to be clustered together, which will leave many spaces unused. The daylight method starts from an initial tree built by equal angle and iteratively improves it by successively going to each interior node and swinging subtrees so that the arcs of "daylight" are equal (Figure \@ref(fig:layout)H). This method was firstly implemented in `r pkg_paup` [@wilgenbusch_inferring_2003].



**Cladogram.** To visualize a cladogram\index{cladogram} that is without branch length scaling and only displays the tree structure,  `branch.length` is set to "none" and it works for all types of layouts (Figures \@ref(fig:layout)I-L).



**Timescaled layout.** For a timescaled tree\index{time-scaled tree}, the most recent sampling date must be specified via the `mrsd` parameter, and `ggtree()` will scale the tree by sampling (tip) and divergence (internal node) time, and a timescale axis will be displayed under the tree by default. Users can use the `r CRANpkg("deeptime")` package to add geologic timescale (e.g., periods and eras) to a `ggtree()` plot. 


(ref:timescaledscap) Timescaled layout.

(ref:timescaledcap) **Timescaled layout.** The *x*-axis is the timescale (in units of the year). The divergence time in this example was inferred by `r pkg_beast` using the molecular clock model. 


```{r timescaled, fig.cap="(ref:timescaledcap)", fig.scap="(ref:timescaledscap)", out.extra='', fig.height=4.5}
beast_file <- system.file("examples/MCC_FluA_H3.tree", 
                          package="ggtree")
beast_tree <- read.beast(beast_file)
ggtree(beast_tree, mrsd="2013-01-01") + theme_tree2()
```


**Two-dimensional tree layout.** A two-dimensional tree\index{two-dimensional tree} is a projection of the phylogenetic tree in a space defined by the associated phenotype (numerical or categorical trait, on the _y_-axis) and tree branch scale (*e.g.*, evolutionary distance, divergent time, on the _x_-axis). The phenotype can be a measure of certain biological characteristics of the taxa and hypothetical ancestors in the tree. This layout is useful to track the virus phenotypes or other behaviors (*y*-axis) changing with the virus evolution (*x*-axis). In fact, the analysis of phenotypes or genotypes over evolutionary time have been widely used for study of influenza virus evolution [@neher_prediction_2016], though such analysis diagrams are not tree-like, *i.e.*, no connection between data points, unlike our two-dimensional tree layout that connects data points with the corresponding tree branches. Therefore, this new layout we provided will make such data analysis easier and more scalable for large sequence datasets.

In this example, we used the previous timescaled tree of H3 human and swine influenza viruses (Figure \@ref(fig:timescaled); data published in [@liang_expansion_2014]) and scaled the *y*-axis based on the predicted *N*-linked glycosylation sites (NLG) for each of the taxon and ancestral sequences of hemagglutinin proteins. The NLG sites were predicted using the [NetNGlyc 1.0 Server](http://www.cbs.dtu.dk/services/NetNGlyc/). To scale the *y*-axis, the parameter `yscale` in the `ggtree()` function is set to a numerical or categorical variable. If `yscale` is a categorical variable as in this example, users should specify how the categories are to be mapped to numerical values via the `yscale_mapping` variables.

(ref:2dscap) Two-dimensional tree layout.

(ref:2dcap) **Two-dimensional tree layout.** The trunk and other branches are highlighted in red (for swine) and blue (for humans). The *x*-axis is scaled to the branch length (in units of year) of the timescaled tree. The *y*-axis is scaled to the node attribute variable, in this case, the number of predicted *N*-linked glycosylation sites (NLG) on the hemagglutinin protein. Colored circles indicate the different types of tree nodes. Note that nodes assigned the same *x*- (temporal) and *y*- (NLG) coordinates are superimposed in this representation and appear as one node, which is shaded based on the colors of all the nodes at that point.


```{r 2d, fig.cap="(ref:2dcap)", fig.width=8.5, fig.height=5, fig.scap="(ref:2dscap)", out.extra='', out.width='100%'}
NAG_file <- system.file("examples/NAG_inHA1.txt", package="ggtree")

NAG.df <- read.table(NAG_file, sep="\t", header=FALSE, 
                     stringsAsFactors = FALSE)
NAG <- NAG.df[,2]
names(NAG) <- NAG.df[,1]

## separate the tree by host species
tip <- as.phylo(beast_tree)$tip.label
beast_tree <- groupOTU(beast_tree, tip[grep("Swine", tip)], 
                       group_name = "host")

p <- ggtree(beast_tree, aes(color=host), mrsd="2013-01-01", 
            yscale = "label", yscale_mapping = NAG) + 
  theme_classic() + theme(legend.position='none') +
  scale_color_manual(values=c("blue", "red"), 
                     labels=c("human", "swine")) +
  ylab("Number of predicted N-linked glycosylation sites")

## (optional) add more annotations to help interpretation
p + geom_nodepoint(color="grey", size=3, alpha=.8) +
  geom_rootpoint(color="black", size=3) +
  geom_tippoint(size=3, alpha=.5) + 
  annotate("point", 1992, 5.6, size=3, color="black") +
  annotate("point", 1992, 5.4, size=3, color="grey") +
  annotate("point", 1991.6, 5.2, size=3, color="blue") +
  annotate("point", 1992, 5.2, size=3, color="red") + 
  annotate("text", 1992.3, 5.6, hjust=0, size=4, label="Root node") +
  annotate("text", 1992.3, 5.4, hjust=0, size=4, 
           label="Internal nodes") +
  annotate("text", 1992.3, 5.2, hjust=0, size=4,
           label="Tip nodes (blue: human; red: swine)")
```


As shown in Figure \@ref(fig:2d), a two-dimensional tree is good at visualizing the change of phenotype over the evolution in the phylogenetic tree. In this example, it is shown that the H3 gene of the human influenza A virus maintained a high level of *N*-linked glycosylation sites (n=8 to 9) over the last two decades and dropped significantly to 5 or 6 in a separate viral lineage transmitted to swine populations and established there. It was indeed hypothesized that the human influenza virus with a high level of glycosylation on the viral hemagglutinin protein provides a better shielding effect to protect the antigenic sites from exposure to the herd immunity, and thus has a selective advantage in human populations that maintain a high level of herd immunity against the circulating human influenza virus strains. For the viral lineage that newly jumped across the species barrier and transmitted to the swine population, the shielding effect of the high-level surface glycan oppositely imposes selective disadvantage because the receptor-binding domain may also be shielded which greatly affects the viral fitness of the lineage that newly adapted to a new host species. Another example of a two-dimensional tree can be found in Figure \@ref(fig:phenogram).


## Displaying Tree Components

### Displaying treescale (evolution distance) {#geom-trescale}

To show treescale, the user can use `geom_treescale()` layer (Figures \@ref(fig:treescale)A-C).

```{r fig.width=4, fig.height=4, fig.align="center", eval=F}
ggtree(tree) + geom_treescale()
```

`geom_treescale()` supports the following parameters:

+ *x* and *y* for treescale position
+ *width* for the length of the treescale
+ *fontsize* for the size of the text
+ *linesize* for the size of the line
+ *offset* for relative position of the line and the text
+ *color* for color of the treescale


```{r eval=F}
ggtree(tree) + geom_treescale(x=0, y=45, width=1, color='red')
ggtree(tree) + geom_treescale(fontsize=6, linesize=2, offset=1)
```


We can also use `theme_tree2()` to display the treescale by adding *x axis* (Figure \@ref(fig:treescale)D).


```{r fig.width=3, fig.height=3, fig.align="center", eval=F}
ggtree(tree) + theme_tree2()
```


(ref:treescalescap) Display treescale.

(ref:treescalecap) **Display treescale.** `geom_treescale()` automatically add a scale bar for evolutionary distance (A). Users can modify the color, width, and position of the scale (B) as well as the size of the scale bar and text and their relative position (C). Another possible solution is to enable the *x*-axis which is useful for the timescaled tree (D).

```{r treescale, fig.width=8, fig.height=6, echo=F, fig.cap="(ref:treescalecap)", fig.scap="(ref:treescalescap)", out.width='100%'}

cowplot::plot_grid(
    ggtree(tree) + geom_treescale(),
    ggtree(tree)+geom_treescale(x=0, y=45, width=1, color='red'),
    ggtree(tree)+geom_treescale(fontsize=6, linesize=2, offset=1),
    ggtree(tree) + theme_tree2(),
    ncol=2, labels=LETTERS[1:4])
```


Treescale is not restricted to evolution distance, `r Biocpkg('treeio')` can rescale the tree with other numerical variables (details described in [session 2.4](#rescale-treeio)), and `r Biocpkg("ggtree")` allows users to specify a numerical variable to serve as branch length for visualization (details described in [session 4.3](#rescale-tree)).


### Displaying nodes/tips {#geom-nodepoint}

Showing all the internal nodes and tips in the tree can be done by adding a layer of points using `geom_nodepoint()`,  `geom_tippoint()`, or `geom_point()` (Figure \@ref(fig:nodeTip)).


```{r fig.width=3, fig.height=3, fig.align="center", eval=F}
ggtree(tree) + 
    geom_point(aes(shape=isTip, color=isTip), size=3)

p <- ggtree(tree) + 
    geom_nodepoint(color="#b5e521", alpha=1/4, size=10) 
p + geom_tippoint(color="#FDAC4F", shape=8, size=3)
```


(ref:nodeTipscap) Display external and internal nodes.

(ref:nodeTipcap) **Display external and internal nodes.** `geom_point()` automatically add symbolic points of all nodes (A). `geom_nodepoint()` adds symbolic points for internal nodes and `geom_tippoint()` adds symbolic points for external nodes (B).


```{r nodeTip, fig.width=8, fig.height=3, echo=F, fig.cap="(ref:nodeTipcap)", fig.scap="(ref:nodeTipscap)", out.width='100%'}
p1 <- ggtree(tree) + geom_point(aes(shape=isTip, color=isTip), size=3)

p <- ggtree(tree) + geom_nodepoint(color="#b5e521", alpha=1/4, size=10)
p2 <- p + geom_tippoint(color="#FDAC4F", shape=8, size=3)

plot_list(p1, p2, ncol=2, tag_levels='A')
```

### Displaying labels

Users can use `geom_text()` or `geom_label()` to display the node (if available) and tip labels simultaneously or `geom_tiplab()` to only display tip labels (Figure \@ref(fig:tiplab)A).


```{r fig.width=3, fig.height=3, warning=FALSE, fig.align="center", eval=FALSE}
p + geom_tiplab(size=3, color="purple")
```

The `geom_tiplab()` layer not only supports using *text* or *label* geom to display labels, but
it also supports *image* geom to label tip with image files (see [Chapter 7](#chapter7)). A corresponding
geom, `geom_nodelab()` is also provided for displaying node labels. 


For *circular* and *unrooted* layouts, `r Biocpkg('ggtree')` supports rotating node labels according to the angles of the branches (Figure \@ref(fig:tiplab)B).

```{r fig.width=6, fig.height=6, warning=FALSE, fig.align="center", eval=FALSE}
ggtree(tree, layout="circular") + geom_tiplab(aes(angle=angle), color='blue')
```



For long tip labels, the label may be truncated. There are several ways to solve this issue (see [FAQ: Tip label truncated](#faq-label-truncated)). Another solution to solve this issue is to display tip labels as *y*-axis labels (Figure \@ref(fig:tiplab)C). However, it only works for rectangular and dendrogram layouts and users need to use `theme()` to adjust tip labels in this case\index{taxa label}.


```{r fig.width=6, fig.height=6, warning=FALSE, fig.align="center", eval=FALSE}
ggtree(tree) + geom_tiplab(as_ylab=TRUE, color='firebrick')
```


(ref:tiplabscap) Display tip labels.

(ref:tiplabcap) **Display tip labels.** `geom_tiplab()` supports displaying tip labels (A). For the circular, fan, or unrooted tree layouts, the labels can be rotated to fit the angle of the branches (B). For dendrogram/rectangular layout, tip labels can be displayed as *y*-axis labels (C).


```{r tiplab, fig.width=13.5, fig.height=5.5, echo=F, fig.cap="(ref:tiplabcap)", fig.scap="(ref:tiplabscap)", out.width='100%'}
p1 <- p + geom_tiplab(size=3, color="purple")
p2 <- ggtree(tree, layout="circular") + geom_tiplab(aes(angle=angle), color='blue')
p2 = ggplotify::as.ggplot(p2 + ggimage::theme_transparent(), scale=1.3, hjust=-.1, vjust=.05)
p3 <- ggtree(tree) + geom_tiplab(as_ylab=TRUE, color='firebrick')
plot_list(p1, p2, p3, ncol=3, tag_levels='A', widths=c(1.1, 2, 1))
```


By default, the positions to display text are based on the node positions; we can change them to be based on the middle of the branch/edge (by setting `aes(x = branch)`), which is very useful when annotating transition from the parent node to the child node.

### Displaying root-edge

The `ggtree()` doesn't plot the root-edge by default. Users can use `geom_rootedge()` to automatically display the root-edge (Figure \@ref(fig:rootedge)A). If there is no root edge information, `geom_rootedge()` will display nothing by default (Figure \@ref(fig:rootedge)B). Users can set the root-edge to the tree (Figure \@ref(fig:rootedge)C) or specify `rootedge` in `geom_rootedge()` (Figure \@ref(fig:rootedge)D). A long root length is useful to increase readability of the circular tree (see also [FAQ: Enlarge center space](#faq-enlarge-center-space)).


```{r eval=F}
## with root-edge = 1
tree1 <- read.tree(text='((A:1,B:2):3,C:2):1;')
ggtree(tree1) + geom_tiplab() + geom_rootedge()

## without root-edge
tree2 <- read.tree(text='((A:1,B:2):3,C:2);')
ggtree(tree2) + geom_tiplab() + geom_rootedge()

## setting root-edge
tree2$root.edge <- 2
ggtree(tree2) + geom_tiplab() + geom_rootedge()

## specify the length of root edge for just plotting
## this will ignore tree$root.edge
ggtree(tree2) + geom_tiplab() + geom_rootedge(rootedge = 3)
```


(ref:rootedgescap) Display root-edge.

(ref:rootedgecap) **Display root-edge.** `geom_rootedge()` supports displaying root-edge if the root edge was presented (A). It shows nothing if there is no root-edge (B). In this case, users can manually set the root edge for the tree (C) or just specify the length of the root for plotting (D).


```{r rootedge, fig.width=6, fig.height=4, echo=F, fig.cap="(ref:rootedgecap)", fig.scap="(ref:rootedgescap)"}
## with root edge = 1
tree1 <- read.tree(text='((A:1,B:2):3,C:2):1;')
p1 = ggtree(tree1) + geom_tiplab() + geom_rootedge()

## without root edge
tree2 <- read.tree(text='((A:1,B:2):3,C:2);')
p2 = ggtree(tree2) + geom_tiplab() + geom_rootedge()

## setting root edge
tree2$root.edge <- 2
p3 = ggtree(tree2) + geom_tiplab() + geom_rootedge()

## specify length of root edge for just plotting
## this will ignore tree$root.edge
p4 = ggtree(tree2) + geom_tiplab() + geom_rootedge(rootedge = 3)
cowplot::plot_grid(p1, p2, p3, p4, ncol=2, labels = LETTERS[1:4])
```


### Color tree

In `r Biocpkg("ggtree")` [@yu_two_2018], coloring phylogenetic tree is easy, by using `aes(color=VAR)` to map the color of the tree based on a specific variable (both numerical and categorical variables are supported, see Figure \@ref(fig:colortree))\index{color tree}.


(ref:colortreescap) Color tree by continuous or discrete feature.

(ref:colortreecap) **Color tree by continuous or discrete feature.** Edges are colored by values associated with the child nodes.


```{r colortree, fig.width=5, fig.height=5, fig.cap="(ref:colortreecap)", fig.scap="(ref:colortreescap)"}
ggtree(beast_tree, aes(color=rate)) +
    scale_color_continuous(low='darkgreen', high='red') +
    theme(legend.position="right")
```

Users can use any feature (if available), including clade posterior and _d~N~/d~S~_, _etc._, to scale the color of the tree. If the feature is a continuous numerical value, `r Biocpkg("ggtree")` provides a `continuous` parameter to support plotting continuous state transition in edges. Here, we use an example^[<http://www.phytools.org/eqg2015/asr.html>] to demonstrate this functionality (Figure \@ref(fig:continuousColor)A). If you want to add a thin black border in tree branches, you can place a tree with black and slightly thicker branches below your tree to emulate edge outlines as demonstrated in Figure \@ref(fig:continuousColor)B.



(ref:continuousColorscap) Continuous state transition in edges.

(ref:continuousColorcap) **Continuous state transition in edges.** Edges are colored by the values from ancestral trait to offspring.

 
```{r continuousColor, fig.width=12, fig.height=6,  fig.cap="(ref:continuousColorcap)", fig.scap="(ref:continuousColorscap)", out.width='100%'}
library(ggtree)
library(treeio)
library(tidytree)
library(ggplot2)
library(TDbook)
## ref: http://www.phytools.org/eqg2015/asr.html
##
## load `tree_anole` and `df_svl` from 'TDbook'
svl <- as.matrix(df_svl)[,1]
fit <- phytools::fastAnc(tree_anole, svl, vars=TRUE, CI=TRUE)

td <- data.frame(node = nodeid(tree_anole, names(svl)),
               trait = svl)
nd <- data.frame(node = names(fit$ace), trait = fit$ace)

d <- rbind(td, nd)
d$node <- as.numeric(d$node)
tree <- full_join(tree_anole, d, by = 'node')

p1 <- ggtree(tree, aes(color=trait), layout = 'circular', 
        ladderize = FALSE, continuous = 'colour', size=2) +
    scale_color_gradientn(colours=c("red", 'orange', 'green', 'cyan', 'blue')) +
    geom_tiplab(hjust = -.1) + 
    xlim(0, 1.2) + 
    theme(legend.position = c(.05, .85)) 

p2 <- ggtree(tree, layout='circular', ladderize = FALSE, size=2.8) + 
    geom_tree(aes(color=trait), continuous = 'colour', size=2) +  
    scale_color_gradientn(colours=c("red", 'orange', 'green', 'cyan', 'blue')) +
    geom_tiplab(aes(color=trait), hjust = -.1) + 
    xlim(0, 1.2) + 
    theme(legend.position = c(.05, .85)) 

plot_list(p1, p2, ncol=2, tag_levels="A")    
```

Besides, we can use a two-dimensional tree (as demonstrated in Figure \@ref(fig:2d)) to visualize phenotype on the vertical dimension to create the phenogram Figure \@ref(fig:phenogram). We can use the `r CRANpkg("ggrepel")` package to repel tip labels to avoid overlapping as demonstrated in Figure \@ref(fig:repelTip)\index{tree layout}.


(ref:phenogramscap) Phenogram.

(ref:phenogramcap) **Phenogram.** Projecting the tree into a space defined by time (or genetic distance) on the horizontal axis and phenotype on the vertical dimension.


```{r phenogram, fig.width=6, fig.height=8, fig.cap="(ref:phenogramcap)", fig.scap="(ref:phenogramscap)"}
ggtree(tree, aes(color=trait), continuous = 'colour', yscale = "trait") + 
    scale_color_viridis_c() + theme_minimal()
```


### Rescale tree

Most of the phylogenetic trees are scaled by evolutionary distance (substitution/site). In `r Biocpkg("ggtree")`, users can rescale a phylogenetic tree by any numerical variable inferred by evolutionary analysis (*e.g.*,  _d~N~/d~S~_)\index{tree branch}. 


This example displays a time tree (Figure \@ref(fig:rescaleTree)A) and the branches were rescaled by substitution rate inferred by BEAST (Figure \@ref(fig:rescaleTree)B). 

```{r rescaleBeast, fig.width=10, fig.height=5}
library("treeio")
beast_file <- system.file("examples/MCC_FluA_H3.tree", package="ggtree")
beast_tree <- read.beast(beast_file)
beast_tree
p1 <- ggtree(beast_tree, mrsd='2013-01-01') + theme_tree2() +
    labs(caption="Divergence time")
p2 <- ggtree(beast_tree, branch.length='rate') + theme_tree2() +
    labs(caption="Substitution rate")
```

The following example draws a tree inferred by CodeML (Figure \@ref(fig:rescaleTree)C), and the branches can be rescaled by using _d~N~/d~S~_ values (Figure \@ref(fig:rescaleTree)D).

```{r rescaleCodeml, fig.width=10, fig.height=5}
mlcfile <- system.file("extdata/PAML_Codeml", "mlc", package="treeio")
mlc_tree <- read.codeml_mlc(mlcfile)
p3 <- ggtree(mlc_tree) + theme_tree2() +
    labs(caption="nucleotide substitutions per codon")
p4 <- ggtree(mlc_tree, branch.length='dN_vs_dS') + theme_tree2() +
    labs(caption="dN/dS tree")
```


(ref:rescaleTreescap) Rescale tree branches.

(ref:rescaleTreecap) **Rescale tree branches.** A time-scaled tree inferred by BEAST (A) and its branches were rescaled by substitution rate (B). A tree was inferred by CodeML (C) and the branches were rescaled by _d~N~/d~S~_ values (D).


```{r rescaleTree, fig.width=8, fig.height=6, echo=FALSE,fig.cap="(ref:rescaleTreecap)", fig.scap="(ref:rescaleTreescap)", out.width='100%'}
plot_list(p1, p2, p3, p4, ncol=2, tag_levels='A')
```



This provides a very convenient way to allow us to explore the relationship between tree associated data and tree structure through visualization. 
In addition to specifying `branch.length` in tree visualization, users can change branch length stored in tree object by using `rescale_tree()` function provided by the `r Biocpkg("treeio")` package [@wang_treeio_2020], and the following command will display a tree that is identical to Figure \@ref(fig:rescaleTree)B. The `rescale_tree()` function was documented in [session 2.4](#rescale-treeio).

```{r rescaleBeast2, eval=F}
beast_tree2 <- rescale_tree(beast_tree, branch.length='rate')
ggtree(beast_tree2) + theme_tree2()
```


### Modify components of a theme


The `theme_tree()`\index{theme} defined a totally blank canvas, while `theme_tree2()` adds
phylogenetic distance (via *x*-axis). These two themes all accept a parameter of
`bgcolor` that defined the background color. Users can use any [theme components](http://ggplot2.tidyverse.org/reference/theme.html) to the `theme_tree()` or `theme_tree2()` functions to modify them  (Figure \@ref(fig:theme)).


```{r eval=F}
set.seed(2019)
x <- rtree(30)
ggtree(x, color="#0808E5", size=1) + theme_tree("#FEE4E9")
ggtree(x, color="orange", size=1) + theme_tree('grey30')
```

(ref:themescap) Tree themes.

(ref:themecap) **Three themes.** All ggplot2 theme components can be modified, and all the ggplot2 themes can be applied to `ggtree()` output. 


```{r theme, fig.width=8, fig.height=3, fig.align="center",  echo=FALSE,fig.cap="(ref:themecap)", fig.scap="(ref:themescap)", out.width="100%"}

library(ggimage)
set.seed(2019)
x <- rtree(30)

cowplot::plot_grid(
ggtree(x, color="#0808E5", size=1) + theme_tree("#FEE4E9"),
ggtree(x, color="orange", size=1) + theme_tree('grey30'),
    ncol=2)
```

Users can also use an image file as the tree background, see example in [Appendix B](#ggimage-bgimage).

## Visualize a List of Trees

The `r Biocpkg("ggtree")` supports `multiPhylo` and `treedataList` objects and a list of trees can be viewed simultaneously. The trees will visualize one on top of another and can be plotted in different panels through `facet_wrap()` or `facet_grid()` functions (Figure \@ref(fig:multiPhylo))\index{multiple trees}. 

(ref:multiPhyloscap) Visualizing multiPhylo object.

(ref:multiPhylocap) **Visualizing multiPhylo object.** The `ggtree()` function supports visualizing multiple trees stored in the `multiPhylo` or `treedataList` objects.


```{r multiPhylo, fig.width=12, fig.height=4,fig.cap="(ref:multiPhylocap)", fig.scap="(ref:multiPhyloscap)", out.width='100%'}
## trees <- lapply(c(10, 20, 40), rtree)
## class(trees) <- "multiPhylo"
## ggtree(trees) + facet_wrap(~.id, scale="free") + geom_tiplab()

f <- system.file("extdata/r8s", "H3_r8s_output.log", package="treeio")
r8s <- read.r8s(f)
ggtree(r8s) + facet_wrap( ~.id, scale="free") + theme_tree2()
```

One hundred bootstrap trees can also be viewed simultaneously (Figure \@ref(fig:bp100)). This allows researchers to explore a large set of phylogenetic trees to find consensus and distinct trees. The consensus tree can be summarized via a density tree (Figure \@ref(fig:densiTree)). 

(ref:bp100scap) Visualizing one hundred bootstrap trees simultaneously.

(ref:bp100cap) **Visualizing one hundred bootstrap trees simultaneously.** 


```{r bp100, fig.width=20, fig.height=20, fig.cap="(ref:bp100cap)", fig.scap="(ref:bp100scap)", out.width='100%'}
btrees <- read.tree(system.file("extdata/RAxML", 
                                "RAxML_bootstrap.H3", 
                                package="treeio")
                    )
ggtree(btrees) + facet_wrap(~.id, ncol=10)
```

### Annotate one tree with values from different variables

To annotate one tree (the same tree) with the values from different variables, one can plot them separately and use `r CRANpkg("patchwork")` or `r CRANpkg("aplot")` to combine them side-by-side. 

Another solution is to utilize the ability to plot a list of trees by `r Biocpkg("ggtree")`, and then add annotation layers for the selected variable at a specific panel via the [subset](#geom2) aesthetic mapping supported by `r Biocpkg("ggtree")` or using the `td_filter()` as demonstrated in Figure \@ref(fig:onetreefacet). The `.id` is the conserved variable that is internally used to store the IDs of different trees. 


(ref:onetreefacetscap) Annotate one tree with values from different variables.

(ref:onetreefacetcap) **Annotate one tree with values from different variables.** Using `subset` aesthetic mapping (as in TREE1 panel) or `td_filter()` (as in TREE2 panel) to filter variables to be displayed on the specific panel.

```{r onetreefacet, warning=FALSE, fig.width=8, fig.height=4,fig.cap="(ref:onetreefacetcap)", fig.scap="(ref:onetreefacetscap)", out.width='100%'}
set.seed(2020)
x <- rtree(30)
d <- data.frame(label=x$tip.label, var1=abs(rnorm(30)), var2=abs(rnorm(30)))
tree <- full_join(x, d, by='label')
trs <- list(TREE1 = tree, TREE2 = tree)
class(trs) <- 'treedataList'
ggtree(trs) + facet_wrap(~.id) + 
  geom_tippoint(aes(subset=.id == 'TREE1', colour=var1)) + 
  scale_colour_gradient(low='blue', high='red') +  
  ggnewscale::new_scale_colour()  + 
  geom_tippoint(aes(colour=var2), data=td_filter(.id == "TREE2")) + 
  scale_colour_viridis_c()
``` 


### DensiTree {#densitree}

Another way to view the bootstrap trees is to merge them to form a density tree using `ggdensitree()`\index{multiple trees} function (Figure \@ref(fig:densiTree)). This will help us identify consensus and differences among a large set of trees. The trees will be stacked on top of each other and the structures of the trees will be rotated to ensure the consistency of the tip order. The tip order is determined by the `tip.order` parameter and by default (`tip.order = 'mode'`) the tips are ordered by the most commonly seen topology. The user can pass in a character vector to specify the tip order, or pass in an integer, N, to order the tips by the order of the tips in the Nth tree. Passing `mds` to `tip.order` will order the tips based on MDS (Multidimensional Scaling) of the path length between the tips, or passing `mds_dist` will order the tips based on MDS of the distance between the tips. 



(ref:densiTreescap) DensiTree.

(ref:densiTreecap) **DensiTree.** Trees are stacked on top of each other and the structures of the trees are rotated to ensure the consistency of the tip order.

```{r densiTree, fig.width=12, fig.height=7.5, fig.cap="(ref:densiTreecap)", fig.scap="(ref:densiTreescap)", out.width='100%'}
ggdensitree(btrees, alpha=.3, colour='steelblue') + 
    geom_tiplab(size=3) + hexpand(.35)
```



## Summary {#summary4}

Visualizing phylogenetic trees with `r Biocpkg("ggtree")` is easy by using a single command `ggtree(tree)`. The `r Biocpkg("ggtree")` package provides several geometric layers to display tree components such as tip labels, symbolic points for both external and internal nodes, root-edge, *etc*. Associated data can be used to rescale branch lengths, color the tree, and be displayed on the tree. All these can be done by the `r CRANpkg("ggplot2")` grammar of graphic syntax, which makes it very easy to overlay layers and customize the tree graph (via `r CRANpkg("ggplot2")` themes and scales). The `r Biocpkg("ggtree")` package also provides several layers that are specifically designed for tree annotation which will be introduced in [Chapter 5](#chapter5). The `r Biocpkg("ggtree")` package makes the presentation of trees and associated data extremely easy. Simple graphs are easy to generate, while complex graphs are simply superimposed layers and are also easy to generate. 




<!--chapter:end:04_ggtree_visualization.Rmd-->

\newpage

# Phylogenetic Tree Annotation {#chapter5}


```{r include=FALSE}
library("ape")
library("ggplot2")
library("cowplot")
library("treeio")
library("ggtree")
```                                                                                                                                                                     


## Visualizing and Annotating Tree Using Grammar of Graphics

The `r Biocpkg("ggtree")` [@yu_ggtree:_2017] is designed for a more general-purpose or a specific type of tree visualization and annotation. It supports the grammar of graphics\index{grammar of graphics} implemented in `r CRANpkg("ggplot2")` and users can freely visualize/annotate a tree by combining several annotation layers. 

(ref:ggtreeNHXscap) Annotating tree using grammar of graphics.

(ref:ggtreeNHXcap) **Annotating tree using the grammar of graphics.** The NHX tree was annotated using the grammar of graphic syntax by combining different layers using the `+` operator. Species information was labeled in the middle of the branches. Duplication events were shown on the most recent common ancestor and clade bootstrap values were displayed near to it.


```{r echo=F, message=F, warning=F, out.width='100%'}
library(ggtree)
treetext <- "(((ADH2:0.1[&&NHX:S=human], ADH1:0.11[&&NHX:S=human]):
  0.05 [&&NHX:S=primates:D=Y:B=100],ADHY:
  0.1[&&NHX:S=nematode],ADHX:0.12 [&&NHX:S=insect]):
  0.1[&&NHX:S=metazoa:D=N],(ADH4:0.09[&&NHX:S=yeast],
  ADH3:0.13[&&NHX:S=yeast], ADH2:0.12[&&NHX:S=yeast],
  ADH1:0.11[&&NHX:S=yeast]):0.1[&&NHX:S=Fungi])[&&NHX:D=N];"
tree <- read.nhx(textConnection(treetext))
p = ggtree(tree) + geom_tiplab() + 
  geom_label(aes(x=branch, label=S), fill='lightgreen') + 
  geom_label(aes(label=D), fill='steelblue') + 
  geom_text(aes(label=B), hjust=-.5)
p <- p + xlim(NA, 0.28)
```


```{r echo=T, eval=F}
library(ggtree)
treetext = "(((ADH2:0.1[&&NHX:S=human], ADH1:0.11[&&NHX:S=human]):
0.05 [&&NHX:S=primates:D=Y:B=100],ADHY:
0.1[&&NHX:S=nematode],ADHX:0.12 [&&NHX:S=insect]):
0.1[&&NHX:S=metazoa:D=N],(ADH4:0.09[&&NHX:S=yeast],
ADH3:0.13[&&NHX:S=yeast], ADH2:0.12[&&NHX:S=yeast],
ADH1:0.11[&&NHX:S=yeast]):0.1[&&NHX:S=Fungi])[&&NHX:D=N];"
tree <- read.nhx(textConnection(treetext))
ggtree(tree) + geom_tiplab() + 
  geom_label(aes(x=branch, label=S), fill='lightgreen') + 
  geom_label(aes(label=D), fill='steelblue') + 
  geom_text(aes(label=B), hjust=-.5)
```

```{r ggtreeNHX, warning=FALSE, fig.cap="(ref:ggtreeNHXcap)", fig.scap="(ref:ggtreeNHXscap)", out.extra='', echo=F}
print(p)
```


Here, as an example, we visualized the tree with several layers to display annotation stored in NHX tags, including a layer of `geom_tiplab()` to display tip labels (gene name in this case), a layer using `geom_label()` to show species information (`S` tag) colored by light green, a layer of duplication event information (`D` tag) colored by steelblue and another layer using `geom_text()` to show bootstrap value (`B` tag).

Layers defined in `r CRANpkg("ggplot2")` can be applied to `r Biocpkg("ggtree")` directly as demonstrated in Figure \@ref(fig:ggtreeNHX) of using `geom_label()` and `geom_text()`. But `r CRANpkg("ggplot2")` does not provide graphic layers that are specifically designed for phylogenetic tree annotation. For instance, layers for tip labels, tree branch scale legend, highlight, or labeling clade are all unavailable. To make tree annotation more flexible, several layers have been implemented in `r Biocpkg("ggtree")` (Table \@ref(tab:geoms)), enabling different ways of annotation on various parts/components of a phylogenetic tree.

```{r geoms, echo=FALSE, message=FALSE}
geoms <- matrix(c(
  "geom_balance", "Highlights the two direct descendant clades of an internal node",
  "geom_cladelab", "Annotates a clade with bar and text label (or image)",
  "geom_facet", "Plots associated data in a specific panel (facet) and aligns the plot with the tree",
  "geom_hilight", "Highlights selected clade with rectangular or round shape",
  "geom_inset", "Adds insets (subplots) to tree nodes",
  "geom_label2", "The modified version of geom_label, with subset aesthetic supported",
  "geom_nodepoint", "Annotates internal nodes with symbolic points",
  "geom_point2", "The modified version of geom_point, with subset aesthetic supported",
  "geom_range", "Bar layer to present uncertainty of evolutionary inference",
  "geom_rootpoint", "Annotates root node with symbolic point",
  "geom_rootedge", "Adds root-edge to a tree", 
  "geom_segment2", "The modified version of geom_segment, with subset aesthetic supported",
  "geom_strip", "Annotates associated taxa with bar and (optional) text label",
  "geom_taxalink", "Links related taxa",
  "geom_text2", "The modified version of geom_text, with subset aesthetic supported",
  "geom_tiplab", "The layer of tip labels",
  "geom_tippoint", "Annotates external nodes with symbolic points",
  "geom_tree", "Tree structure layer, with multiple layouts supported",
  "geom_treescale", "Tree branch scale legend"
), ncol=2, byrow=TRUE)
geoms <- as.data.frame(geoms)
colnames(geoms) <- c("Layer", "Description")
knitr::kable(geoms, caption = "Geom layers defined in ggtree.", booktabs = T) %>%
  kable_styling(latex_options = c("striped", "hold_position"), full_width = T)
```

## Layers for Tree Annotation

### Colored strips

The `r Biocpkg("ggtree")` [@yu_ggtree:_2017] implements `geom_cladelab()` layer to annotate a selected clade with a bar indicating the clade with a corresponding label\index{geom\textunderscore cladelab}.

The `geom_cladelab()` layer accepts a selected internal node number and labels the corresponding clade automatically (Figure \@ref(fig:cladelabel)A). To get the internal node number, please refer to [Chapter 2](#accesor-tidytree). 


```{r eval=F}
set.seed(2015-12-21)
tree <- rtree(30)
p <- ggtree(tree) + xlim(NA, 8)

p + geom_cladelab(node=45, label="test label") +
    geom_cladelab(node=34, label="another clade")
```

Users can set the parameter, `align = TRUE`, to align the clade label, `offset`, to adjust the position and color to set the color of the bar and label text, *etc.* (Figure \@ref(fig:cladelabel)B). 


```{r eval=F}
p + geom_cladelab(node=45, label="test label", align=TRUE,  
                  offset = .2, textcolor='red', barcolor='red') +
    geom_cladelab(node=34, label="another clade", align=TRUE, 
                  offset = .2, textcolor='blue', barcolor='blue')
```

Users can change the `angle` of the clade label text and relative position from text to bar via the parameter `offset.text`. The size of the bar and text can be changed via the parameters `barsize` and `fontsize`, respectively (Figure \@ref(fig:cladelabel)C).

```{r eval=F}
p + geom_cladelab(node=45, label="test label", align=TRUE, angle=270, 
            hjust='center', offset.text=.5, barsize=1.5, fontsize=8) +
    geom_cladelab(node=34, label="another clade", align=TRUE, angle=45)
```

Users can also use `geom_label()` to label the text and can set the background color by `fill` parameter (Figure \@ref(fig:cladelabel)D).

```{r eval=F}
p + geom_cladelab(node=34, label="another clade", align=TRUE, 
                  geom='label', fill='lightblue')
```


(ref:cladelabelscap) Labelling clades.

(ref:cladelabelcap) **Labeling clades.** Default (A); aligning and coloring clade bar and text (B); changing size and angle (C) and using `geom_label()` with background color in the text (D).

```{r cladelabel, echo=FALSE, fig.width=12, fig.height=7.6, fig.cap="(ref:cladelabelcap)", fig.scap="(ref:cladelabelscap)", out.width='100%'}
set.seed(2015-12-21)
tree <- rtree(30)
p <- ggtree(tree) + xlim(NA, 8)

p1 = p + geom_cladelab(node=45, label="test label") +
    geom_cladelab(node=34, label="another clade")


p2 = p + geom_cladelab(node=45, label="test label", align=T, textcolor='red', barcolor='red') +
    geom_cladelab(node=34, label="another clade", align=T, textcolor='blue', barcolor='blue')

p3 = p + geom_cladelab(node=45, label="test label", align=T, angle=270, 
  hjust='center', offset.text=.5, barsize=1.5, fontsize=8) +
    geom_cladelab(node=34, label="another clade", align=T, angle=45)

p4 = p + geom_cladelab(node=34, label="another clade", align=T, geom='label', fill='lightblue')

plot_grid(p1, p2, p3, p4, ncol=2, labels = LETTERS[1:4])
```


In addition, `geom_cladelab()` allows users to use the image or phylopic to annotate the clades, and supports using aesthetic mapping to automatically annotate the clade with bar and text label or image (*e.g.*, mapping variable to color the clade labels) (Figure \@ref(fig:cladelabaes)).

```{r eval=F}
dat <- data.frame(node = c(45, 34), 
            name = c("test label", "another clade"))
# The node and label is required when geom="text" 
## or geom="label" or geom="shadowtext".
p1 <- p + geom_cladelab(data = dat, 
        mapping = aes(node = node, label = name, color = name), 
        fontsize = 3)

dt <- data.frame(node = c(45, 34), 
                 image = c("7fb9bea8-e758-4986-afb2-95a2c3bf983d", 
                          "0174801d-15a6-4668-bfe0-4c421fbe51e8"), 
                 name = c("specie A", "specie B"))

# when geom="phylopic" or geom="image", the image of aes is required.
p2 <- p + geom_cladelab(data = dt, 
                mapping = aes(node = node, label = name, image = image), 
                geom = "phylopic", imagecolor = "black", 
                offset=1, offset.text=0.5)

# The color or size of image also can be mapped.
p3 <- p + geom_cladelab(data = dt, 
              mapping = aes(node = node, label = name, 
                          image = image, color = name), 
              geom = "phylopic", offset = 1, offset.text=0.5)
```


(ref:cladelabaesscap) Labeling clades using aesthetic mapping.

(ref:cladelabaescap) **Labeling clades using aesthetic mapping.** The geom_cladelab() layer allows users to use aesthetic mapping to annotate the clades (A); it supports using images or phylopic to annotate clades (B); mapping variable to change color or size of the text or image is also supported (C).


```{r cladelabaes, echo=FALSE, fig.width=12, fig.height=5, fig.cap="(ref:cladelabaescap)", fig.scap="(ref:cladelabaesscap)", out.width='100%'}
dat <- data.frame(node=c(45, 34), name=c("test label", "another clade"))
f5 <- p + geom_cladelab(data=dat, mapping=aes(node=node, label=name, color=name), fontsize = 3) 
dt <- data.frame(node = c(45, 34),                                                                                                                            
                 image = c("7fb9bea8-e758-4986-afb2-95a2c3bf983d", "0174801d-15a6-4668-bfe0-4c421fbe51e8"),
                 name = c("specie A", "specie B"))
f6 <- p + geom_cladelab(data=dt, mapping = aes(node = node, label = name, image = image), geom = "phylopic", imagecolor = "black", offset=1, offset.text=0.5)
f7 <- p + geom_cladelab(data=dt, mapping = aes(node = node, label = name, image = image, color = name), geom = "phylopic", offset = 1, offset.text=0.5)  
plot_list(f5, f6, f7, ncol=3, tag_levels='A') 
```


The `geom_cladelab()` layer also supports unrooted tree layouts (Figure \@ref(fig:striplabel)A).

```{r fig.wdith=7, fig.height=7, fig.align='center', warning=FALSE, message=FALSE, eval=F}
ggtree(tree, layout="daylight") + 
  geom_cladelab(node=35, label="test label", angle=0, 
                  fontsize=8, offset=.5, vjust=.5)  + 
  geom_cladelab(node=55, label='another clade', 
                  angle=-95, hjust=.5, fontsize=8)
```



The `geom_cladelab()` is designed for labeling Monophyletic (Clade) while there are related taxa that do not form a clade. In `r Biocpkg("ggtree")`, we provide another layer, `geom_strip()`, to add a strip/bar to indicate the association with an optional label for Polyphyletic or Paraphyletic (Figure \@ref(fig:striplabel)B).

```{r eval=F}
p + geom_tiplab() + 
  geom_strip('t10', 't30', barsize=2, color='red', 
            label="associated taxa", offset.text=.1) + 
  geom_strip('t1', 't18', barsize=2, color='blue', 
            label = "another label", offset.text=.1)
```

(ref:striplabelscap) Labeling associated taxa.

(ref:striplabelcap) **Labeling associated taxa.** The `geom_cladelab()` is designed for labeling Monophyletic and supports unrooted layouts (A). The `geom_strip()` is designed for labeling all types of associated taxa, including Monophyletic, Polyphyletic, and Paraphyletic (B).

```{r striplabel, fig.width=13.5, fig.height=6.5, echo=FALSE, warning=FALSE, fig.cap="(ref:striplabelcap)", fig.scap="(ref:striplabelscap)", out.width='100%'}

pg <- ggtree(tree, layout="daylight")
p5 <- pg + geom_cladelab(node=35, label="test label", angle=0, fontsize=8, offset=.5, vjust=.5)  + 
  geom_cladelab(node=55, label='another clade', angle=-95, hjust=.5, fontsize=8)

p6 <- p + geom_tiplab() + 
  geom_strip('t10', 't30', barsize=2, color='red', 
            label="associated taxa", offset.text=.1) + 
  geom_strip('t1', 't18', barsize=2, color='blue', 
            label = "another label", offset.text=.1)

plot_grid(p5, p6, ncol=2, labels=LETTERS[1:2])  
```


### Highlight clades

The `r Biocpkg("ggtree")` implements the `geom_hilight()` layer, which accepts an internal node number and adds a layer of a rectangle to highlight the selected clade (Figure \@ref(fig:hilight))^[If you want to plot the tree above the highlighting area, visit [FAQ](#faq-under-the-tree) for details.]\index{geom\textunderscore hilight}.

```{r eval=F, fig.width=5, fig.height=5, fig.align="center", warning=FALSE}
nwk <- system.file("extdata", "sample.nwk", package="treeio")
tree <- read.tree(nwk)
ggtree(tree) + 
    geom_hilight(node=21, fill="steelblue", alpha=.6) +
    geom_hilight(node=17, fill="darkgreen", alpha=.6) 

ggtree(tree, layout="circular") + 
    geom_hilight(node=21, fill="steelblue", alpha=.6) +
    geom_hilight(node=23, fill="darkgreen", alpha=.6)
```


The `geom_hilight` layer also supports highlighting clades for unrooted layout trees with round ('encircle') or rectangular ('rect') shape (Figure \@ref(fig:hilight)C).


```{r eval=FALSE, fig.width=5, fig.height=5, fig.align='center', warning=FALSE, message=FALSE}
## type can be 'encircle' or 'rect'
pg + geom_hilight(node=55, linetype = 3) + 
  geom_hilight(node=35, fill='darkgreen', type="rect")
```


Another way to highlight selected clades is by setting the clades with different colors and/or line types as demonstrated in Figure \@ref(fig:scaleClade).


In addition to `geom_hilight()`, `r Biocpkg("ggtree")` also implements `geom_balance()`
which is designed to highlight neighboring subclades of a given internal node (Figure \@ref(fig:hilight)D).



```{r fig.width=4, fig.height=5, fig.align='center', warning=FALSE, eval=F}
ggtree(tree) +
  geom_balance(node=16, fill='steelblue', color='white', alpha=0.6, extend=1) +
  geom_balance(node=19, fill='darkgreen', color='white', alpha=0.6, extend=1) 
```


The `geom_hilight()` layer supports using aesthetic mapping to automatically highlight clades as demonstrated in Figures \@ref(fig:hilight)E-F. For plot in Cartesian coordinates (*e.g.*, rectangular layout), the rectangle can be rounded (Figure \@ref(fig:hilight)E) or filled with gradient colors (Figure \@ref(fig:hilight)F).

```{r eval=FALSE, fig.width=5, fig.height=5, fig.align='center', warning=FALSE, message=FALSE}
## using external data
d <- data.frame(node=c(17, 21), type=c("A", "B"))
ggtree(tree) + geom_hilight(data=d, aes(node=node, fill=type),
                            type = "roundrect")

## using data stored in the tree object
x <- read.nhx(system.file("extdata/NHX/ADH.nhx", package="treeio"))
ggtree(x) + geom_hilight(mapping=aes(subset = node %in% c(10, 12), 
                                    fill = S),
                        type = "gradient", gradient.direction = 'rt',
                        alpha = .8) +
  scale_fill_manual(values=c("steelblue", "darkgreen"))
```



(ref:hilightscap) Highlight selected clades.

(ref:hilightcap) **Highlight selected clades.** Rectangular layout (A), circular/fan (B), and unrooted layouts. Highlight neighboring subclades simultaneously (D). Highlight selected clades using associated data (E and F).


```{r hilight, echo = FALSE, fig.width=12, fig.height=8, warning=FALSE, fig.cap="(ref:hilightcap)", fig.scap="(ref:hilightscap)", out.width='100%'}
nwk <- system.file("extdata", "sample.nwk", package="treeio")
tree <- read.tree(nwk)
p1= ggtree(tree) + geom_hilight(node=21, fill="steelblue", alpha=.6) +
    geom_hilight(node=17, fill="darkgreen", alpha=.6) 

p2= ggtree(tree, layout="circular") + geom_hilight(node=21, fill="steelblue", alpha=.6) +
    geom_hilight(node=23, fill="darkgreen", alpha=.6)

p3 = pg + geom_hilight(node=55, linetype = 3) + 
  geom_hilight(node=35, fill='darkgreen', type='rect', linetype = 3)

p4 = ggtree(tree) +
  geom_balance(node=16, fill='steelblue', color='white', alpha=0.6, extend=1) +
  geom_balance(node=19, fill='darkgreen', color='white', alpha=0.6, extend=1) 

d <- data.frame(node=c(17, 21), type=c("A", "B"))
p5 <- ggtree(tree) + geom_hilight(data=d, aes(node=node, fill=type), type = "roundrect")

## using data stored in tree object
x <- read.nhx(system.file("extdata/NHX/ADH.nhx", package="treeio"))
p6 <- ggtree(x) + geom_hilight(mapping=aes(subset = node %in% c(10, 12), 
                                    fill = S),
                        type = "gradient", graident.direction = 'rt',
                        alpha = .8) +
  scale_fill_manual(values=c("steelblue", "darkgreen"))

plot_list(p1, p2, p3, p4, p5, p6, ncol=3, tag_levels='A')    
```


### Taxa connection

Some evolutionary events (*e.g.*, reassortment, horizontal gene transfer) cannot be modeled by a simple tree. The `r Biocpkg("ggtree")` provides the `geom_taxalink()` layer that allows drawing straight or curved lines between any of two nodes in the tree, allowing it to represent evolutionary events by connecting taxa. It works with rectangular (Figure \@ref(fig:taxalink)A), circular (Figure \@ref(fig:taxalink)B), and inward circular (Figure \@ref(fig:taxalink)C) layouts. The `geom_taxalink()` is not only useful for presenting evolutionary events, but it can also be used to combine evolutionary trees to present relationships or interactions between species [@ggtreeExtra_2021]\index{geom\textunderscore taxalink}.

The `geom_taxalink()` layout supports aesthetic mapping, which requires a `data.frame` that stores association information with/without meta-data as input (Figure \@ref(fig:taxalink)D).

(ref:taxalinkscap) Linking related taxa.

(ref:taxalinkcap) **Linking related taxa.** This can be used to indicate evolutionary events or relationships between species. Rectangular layout (A), circular layout (B), and inward circular layout (C and D). It supports aesthetic mapping to map variables to set line sizes and colors (D). 


```{r taxalink, fig.cap="(ref:taxalinkcap)", fig.scap="(ref:taxalinkscap)", fig.width=12, fig.height=10, warning=FALSE, out.width='100%'}
p1 <- ggtree(tree) + geom_tiplab() + geom_taxalink(taxa1='A', taxa2='E') + 
  geom_taxalink(taxa1='F', taxa2='K', color='red', linetype = 'dashed',
    arrow=arrow(length=unit(0.02, "npc")))

p2 <- ggtree(tree, layout="circular") + 
      geom_taxalink(taxa1='A', taxa2='E', color="grey", alpha=0.5, 
                offset=0.05, arrow=arrow(length=unit(0.01, "npc"))) + 
      geom_taxalink(taxa1='F', taxa2='K', color='red', 
                linetype = 'dashed', alpha=0.5, offset=0.05,
                arrow=arrow(length=unit(0.01, "npc"))) +
      geom_taxalink(taxa1="L", taxa2="M", color="blue", alpha=0.5, 
                offset=0.05, hratio=0.8, 
                arrow=arrow(length=unit(0.01, "npc"))) + 
      geom_tiplab()

# when the tree was created using reverse x, 
# we can set outward to FALSE, which will generate the inward curve lines.
p3 <- ggtree(tree, layout="inward_circular", xlim=150) +
      geom_taxalink(taxa1='A', taxa2='E', color="grey", alpha=0.5, 
                    offset=-0.2, outward=FALSE,
                    arrow=arrow(length=unit(0.01, "npc"))) +
      geom_taxalink(taxa1='F', taxa2='K', color='red', linetype = 'dashed', 
                    alpha=0.5, offset=-0.2, outward=FALSE,
                    arrow=arrow(length=unit(0.01, "npc"))) +
      geom_taxalink(taxa1="L", taxa2="M", color="blue", alpha=0.5, 
                    offset=-0.2, outward=FALSE,
                    arrow=arrow(length=unit(0.01, "npc"))) +
      geom_tiplab(hjust=1) 

dat <- data.frame(from=c("A", "F", "L"), 
                  to=c("E", "K", "M"), 
                  h=c(1, 1, 0.1), 
                  type=c("t1", "t2", "t3"), 
                  s=c(2, 1, 2))
p4 <- ggtree(tree, layout="inward_circular", xlim=c(150, 0)) +
          geom_taxalink(data=dat, 
                         mapping=aes(taxa1=from, 
                                     taxa2=to, 
                                     color=type, 
                                     size=s), 
                         ncp=10,
                         offset=0.15) + 
          geom_tiplab(hjust=1) +
          scale_size_continuous(range=c(1,3))
plot_list(p1, p2, p3, p4, ncol=2, tag_levels='A')
```

### Uncertainty of evolutionary inference

The `geom_range()` layer supports displaying interval (highest posterior density, confidence interval, range) as horizontal bars on tree nodes. The center of the interval will anchor to the corresponding node. The center by default is the mean value of the interval (Figure \@ref(fig:geomRange)A). We can set the `center` to the estimated mean or median value (Figure \@ref(fig:geomRange)B), or the observed value. As the tree branch and the interval may not be on the same scale, `r Biocpkg("ggtree")` provides `scale_x_range` to add a second *x*-axis for the range (Figure \@ref(fig:geomRange)C). Note that *x*-axis is disabled by the default theme, and we need to enable it if we want to display it (*e.g.*, using `theme_tree2()`)\index{geom\textunderscore range}.




(ref:geomRangescap) Displaying uncertainty of evolutionary inference.

(ref:geomRangecap) **Displaying uncertainty of evolutionary inference.** The center (mean value of the range (A) or estimated value (B)) is anchored to the tree nodes. A second *x*-axis was used for range scaling (C). 

```{r eval=FALSE}
file <- system.file("extdata/MEGA7", "mtCDNA_timetree.nex", package = "treeio")
x <- read.mega(file)
p1 <- ggtree(x) + geom_range('reltime_0.95_CI', color='red', size=3, alpha=.3)
p2 <- ggtree(x) + geom_range('reltime_0.95_CI', color='red', size=3, 
                              alpha=.3, center='reltime')  
p3 <- p2 + scale_x_range() + theme_tree2()
```

```{r geomRange, fig.cap="(ref:geomRangecap)", fig.scap="(ref:geomRangescap)", fig.width=12, fig.height=4, echo=F, out.width='100%'}
file <- system.file("extdata/MEGA7", "mtCDNA_timetree.nex", package = "treeio")
x <- read.mega(file)
p1 <- ggtree(x) + geom_range('reltime_0.95_CI', color='red', size=3, alpha=.3)
p2 <- ggtree(x) + geom_range('reltime_0.95_CI', color='red', size=3, alpha=.3, center='reltime') + coord_cartesian(ylim = c(1, 7))
 
p3 <- p2 + scale_x_range() + theme_tree2()
plot_grid(p1, p2, p3, ncol=3, labels = LETTERS[1:3])
```


## Tree Annotation with Output from Evolution Software


### Tree annotation using data from evolutionary analysis software

[Chapter 1](#chapter) introduced using `r Biocpkg("treeio")` package [@wang_treeio_2020] to parse different tree formats and commonly used software outputs to obtain phylogeny-associated data. These imported data, as `S4` objects, can be visualized directly using `r Biocpkg("ggtree")`. Figure \@ref(fig:ggtreeNHX) demonstrates a tree annotated using the information (species classification, duplication event, and bootstrap value) stored in the NHX\index{NHX} file. `r pkg_phyldog` and `pkg_revbayes` output NHX files that can be parsed by `r Biocpkg("treeio")` and visualized by `r Biocpkg("ggtree")` with annotation using their inference data.


Furthermore, the evolutionary data from the inference of `r pkg_beast`, `r pkg_mrbayes`, and `r pkg_revbayes`, *d~N~/d~S~* values inferred by `r pkg_codeml`, ancestral sequences\index{ancestral sequences} inferred by `r pkg_hyphy`, `r pkg_codeml`, or `r pkg_baseml` and short read placement by `r pkg_epa` and `r pkg_pplacer` can be used to annotate the tree directly. 

(ref:beastscap) Annotating `r pkg_beast` tree with _length\_95%\_HPD_ and posterior.

(ref:beastcap) **Annotating `r pkg_beast` tree with _length\_95%\_HPD_ and posterior.** Branch length credible intervals (95% HPD) were displayed as red horizontal bars and clade posterior values were shown on the middle of branches\index{BEAST}. 



```{r beast, fig.cap="(ref:beastcap)", fig.scap="(ref:beastscap)", fig.width=7, out.extra='', out.width='100%'}
file <- system.file("extdata/BEAST", "beast_mcc.tree", package="treeio")
beast <- read.beast(file)
ggtree(beast, aes(color=rate))  +
    geom_range(range='length_0.95_HPD', color='red', alpha=.6, size=2) +
    geom_nodelab(aes(x=branch, label=round(posterior, 2)), vjust=-.5, size=3) +
    scale_color_continuous(low="darkgreen", high="red") +
    theme(legend.position=c(.1, .8))
```


In Figure \@ref(fig:beast), the tree was visualized and annotated with posterior >0.9 and demonstrated length uncertainty (95% Highest Posterior Density (HPD) interval).

Ancestral sequences inferred by `r pkg_hyphy` can be parsed using `r Biocpkg("treeio")`, whereas the substitutions along each tree branch were automatically computed and stored inside the phylogenetic tree object (*i.e.*, `S4` object). The `r Biocpkg("ggtree")` package can utilize this information stored in the object to annotate the tree, as demonstrated in Figure \@ref(fig:hyphy)\index{HyPhy}.

(ref:hyphyscap) Annotating tree with amino acid substitution determined by ancestral sequences inferred by `r pkg_hyphy`.

(ref:hyphycap) **Annotating tree with amino acid substitution determined by ancestral sequences inferred by `r pkg_hyphy`.** Amino acid substitutions were displayed in the middle of branches.


```{r hyphy, fig.width=7.8, fig.height=3.5, warning=FALSE, fig.cap="(ref:hyphycap)", fig.scap="(ref:hyphyscap)", out.extra='', out.width='100%'}
nwk <- system.file("extdata/HYPHY", "labelledtree.tree", 
                   package="treeio")
ancseq <- system.file("extdata/HYPHY", "ancseq.nex", 
                      package="treeio")
tipfas <- system.file("extdata", "pa.fas", package="treeio")
hy <- read.hyphy(nwk, ancseq, tipfas)
ggtree(hy) + 
  geom_text(aes(x=branch, label=AA_subs), size=2, 
            vjust=-.3, color="firebrick")
```


`r pkg_paml`'s `r pkg_baseml` and `r pkg_codeml` can also be used to infer ancestral sequences, whereas `r pkg_codeml`\index{CodeML} can infer selection pressure. After parsing this information using `r Biocpkg("treeio")`, `r Biocpkg("ggtree")` can integrate this information into the same tree structure and be used for annotation as illustrated in Figure \@ref(fig:codeml)\index{PAML}.

(ref:codemlscap) Annotating tree with amino acid substitution and *d~N~/d~S~* inferred by `r pkg_codeml`.

(ref:codemlcap) **Annotating tree with amino acid substitution and *d~N~/d~S~* inferred by `r pkg_codeml`.** Branches were rescaled and colored by *d~N~/d~S~* values, and amino acid substitutions were displayed on the middle of branches.


```{r codeml, fig.cap="(ref:codemlcap)", fig.scap="(ref:codemlscap)", warning=FALSE, out.extra='', fig.height=4, out.width='100%'}
rstfile <- system.file("extdata/PAML_Codeml", "rst", 
                       package="treeio")
mlcfile <- system.file("extdata/PAML_Codeml", "mlc", 
                       package="treeio")
ml <- read.codeml(rstfile, mlcfile)
ggtree(ml, aes(color=dN_vs_dS), branch.length='dN_vs_dS') + 
  scale_color_continuous(name='dN/dS', limits=c(0, 1.5),
                         oob=scales::squish,
                         low='darkgreen', high='red') +
  geom_text(aes(x=branch, label=AA_subs), 
            vjust=-.5, color='steelblue', size=2) +
  theme_tree2(legend.position=c(.9, .3))
```


Not only all the tree data parsed by `r Biocpkg("treeio")` can be used to visualize and annotate the phylogenetic tree using `r Biocpkg("ggtree")`, but also other trees and tree-like objects defined in the R community are supported. The `r Biocpkg("ggtree")` plays a unique role in the R ecosystem to facilitate phylogenetic analysis, and it can be easily integrated into other packages and pipelines. For more details of working with other tree-like structures, please refer to [Chapter 9](#chapter9). In addition to direct support of tree objects, `r Biocpkg("ggtree")` also allows users to plot a tree with different types of external data (see also [Chapter 7](#chapter7) and [@yu_two_2018]).


## Summary {#summary5}


The `r Biocpkg("ggtree")` package implements the grammar of graphics for annotating phylogenetic trees. Users can use the `r CRANpkg("ggplot2")` syntax to combine different annotation layers to produce complex tree annotation. If you are familiar with `r CRANpkg("ggplot2")`, tree annotation with a high level of customization can be intuitive and flexible using `r Biocpkg("ggtree")`. The `r Biocpkg("ggtree")` can collect information in the `treedata` object or link external data to the structure of the tree. This will enable us to use the phylogenetic tree for data integration analysis and comparative studies, and will greatly expand the application of the phylogenetic tree in different fields.



<!--chapter:end:05_ggtree_annotation.Rmd-->

\newpage

# Visual Exploration of Phylogenetic Trees {#chapter6}


```{r include=FALSE}
library("ape")
library("ggplot2")
library("cowplot")
library("ggtree")
expand <- ggtree::expand
rotate <- ggtree::rotate
flip <- ggtree::flip
```


The `r Biocpkg("ggtree")` [@yu_ggtree:_2017] supports many ways of manipulating the tree visually, including viewing selected clade to explore large tree (Figure \@ref(fig:viewClade)), taxa clustering (Figure \@ref(fig:groupOTU)), rotating clade or tree (Figure \@ref(fig:rfClade)B and \@ref(fig:rotateTree)), zoom out or collapsing clades (Figure \@ref(fig:collapseExpand)A and \@ref(fig:scaleClade)), *etc.*. Details of the tree manipulation functions are summarized in Table \@ref(tab:treeman).


```{r treeman, echo=FALSE, out.extra='', message=FALSE}
treeman <- matrix(c(
  "collapse", "Collapse a selecting clade",
  "expand", "Expand collapsed clade",
  "flip", "Exchange position of 2 clades that share a parent node",
  "groupClade", "Grouping clades",
  "groupOTU", "Grouping OTUs by tracing back to the most recent common ancestor",
  "identify", "Interactive tree manipulation",
  "rotate", "Rotating a selected clade by 180 degrees",
  "rotate_tree", "Rotating circular layout tree by a specific angle",
  "scaleClade", "Zoom in or zoom out selecting clade",
  "open_tree", "Convert a tree to fan layout by specific open angle"
), ncol=2, byrow=TRUE)
treeman <- as.data.frame(treeman)
colnames(treeman) <- c("Function", "Description")
knitr::kable(treeman, caption = "Tree manipulation functions.", booktabs = T) %>%
  kable_styling(latex_options = c("striped", "hold_position"), full_width = T)
```



## Viewing Selected Clade



A clade is a monophyletic group that contains a single ancestor and all of its descendants. We can visualize a specifically selected clade via the `viewClade()` function as demonstrated in Figure \@ref(fig:viewClade)B. Another solution is to extract the selected clade as a new tree object as described in [session 2.5](#subsetting-tree-with-data). These functions are developed to help users explore a large tree.

(ref:viewCladescap) Viewing a selected clade of a tree.

(ref:viewCladecap) **Viewing a selected clade of a tree.** An example tree used to demonstrate how `r Biocpkg("ggtree")` supports exploring or manipulating phylogenetic tree visually (A). The `r Biocpkg("ggtree")` supports visualizing selected clade (B). A clade can be selected by specifying a node number or determined by the most recent common ancestor of selected tips.


```{r eval=F, fig.cap="(ref:viewCladecap)", fig.scap="(ref:viewCladescap)", out.extra=''}
library(ggtree)
nwk <- system.file("extdata", "sample.nwk", package="treeio")
tree <- read.tree(nwk)
p <- ggtree(tree) + geom_tiplab()
viewClade(p, MRCA(p, "I", "L"))
```


```{r viewClade, echo=F, fig.cap="(ref:viewCladecap)", message=F, warning=F, fig.scap="(ref:viewCladescap)", out.extra='', out.width='100%'}
library(ggtree)
nwk <- system.file("extdata", "sample.nwk", package="treeio")
tree <- read.tree(nwk)
p <- ggtree(tree) + geom_tiplab()
p2 <- viewClade(p, MRCA(p, "I", "L"))
plot_list(p, p2, ncol=2, tag_levels="A")
```


Some of the functions, *e.g.*, `viewClade()`, work with clade and accept a parameter of an internal node number. To get the internal node number, users can use the `MRCA()` function (as in Figure \@ref(fig:viewClade)) by providing two taxa names. The function will return the node number of input taxa's most recent common ancestor (MRCA). It works with a tree and graphic (*i.e.*, the `ggtree()` output) object. The `r CRANpkg("tidytree")` package also provides an `MRCA()` method to extract information from the MRCA node (see details in [session 2.1.3](#accesor-tidytree)).



## Scaling Selected Clade {#scale-clade}


The `r Biocpkg("ggtree")` provides another option to zoom out (or compress) selected clades via the `scaleClade()` function. In this way, we retain the topology and branch lengths of compressed clades. This helps to save the space to highlight those clades of primary interest in the study.

(ref:scaleCladescap) Scaling selected clade.

(ref:scaleCladecap) **Scaling selected clade.** Clades can be zoomed in (if `scale > 1`) to highlight or zoomed out to save space. 


```{r scaleClade, message=FALSE, fig.cap="(ref:scaleCladecap)", fig.scap="(ref:scaleCladescap)", out.extra='', out.width='100%'}
tree2 <- groupClade(tree, c(17, 21))
p <- ggtree(tree2, aes(color=group)) + theme(legend.position='none') +
  scale_color_manual(values=c("black", "firebrick", "steelblue"))
scaleClade(p, node=17, scale=.1) 
```


If users want to emphasize important clades, they can use the `scaleClade()` function by passing a numeric value larger than 1 to the  `scale` parameter. Then the selected clade will be zoomed in. Users can also use the `groupClade()` function to assign selected clades with different clade IDs which can be used to color these clades with different colors as shown in Figure \@ref(fig:scaleClade).


## Collapsing and Expanding Clade


It is a common practice to prune or collapse clades so that certain aspects of a tree can be emphasized. The `r Biocpkg("ggtree")` supports collapsing selected clades using the `collapse()` function as shown in Figure \@ref(fig:collapseExpand)A.


(ref:collapseExpandscap) Collapsing selected clades and expanding collapsed clades.

(ref:collapseExpandcap) **Collapsing selected clades and expanding collapsed clades.** Clades can be selected to collapse (A) and the collapsed clades can be expanded back (B) if necessary as `r Biocpkg("ggtree")` stored all information of species relationships. Green and red symbols were displayed on the tree to indicate the collapsed clades. 



```{r collapseClade, eval=F, fig.cap="(ref:collapseCladecap)", fig.scap="(ref:collapseCladescap)", out.extra=''}
p2 <- p %>% collapse(node=21) + 
  geom_point2(aes(subset=(node==21)), shape=21, size=5, fill='green')
p2 <- collapse(p2, node=23) + 
  geom_point2(aes(subset=(node==23)), shape=23, size=5, fill='red')
print(p2)
expand(p2, node=23) %>% expand(node=21)
```


```{r collapseExpand, echo=F, fig.cap="(ref:collapseExpandcap)", fig.scap="(ref:collapseExpandscap)", out.extra='', fig.width=8, fig.height=4, out.width='100%'}
p2 <- p %>% collapse(node=21) + 
  geom_point2(aes(subset=(node==21)), shape=21, size=5, fill='green')
p2 <- collapse(p2, node=23) + 
  geom_point2(aes(subset=(node==23)), shape=23, size=5, fill='red')
p3 <- expand(p2, node=23) %>% expand(node=21) 
plot_list(p2, p3, ncol=2, tag_levels = "A")
```

Here two clades were collapsed and labeled by the green circle and red square symbolic points. Collapsing is a common strategy to collapse clades that are too large for displaying in full or are not the primary interest of the study. In `r Biocpkg("ggtree")`, we can expand (*i.e.*, uncollapse) the collapsed branches back with the `expand()` function to show details of species relationships as demonstrated in Figure \@ref(fig:collapseExpand)B.

Triangles are often used to represent the collapsed clade and `r Biocpkg("ggtree")` also supports it. The `collapse()` function provides a "mode" parameter, which by default is "none" and the selected clade was collapsed as a "tip". Users can specify the `mode` to "max" that uses the farthest tip (Figure \@ref(fig:collapseMode)A), "min" that uses the closest tip (Figure \@ref(fig:collapseMode)B), and "mixed" that uses both (Figure \@ref(fig:collapseMode)C). 


```r
p2 <- p + geom_tiplab()
node <- 21
collapse(p2, node, 'max') %>% expand(node)
collapse(p2, node, 'min') %>% expand(node)
collapse(p2, node, 'mixed') %>% expand(node)
```

We can pass additional parameters to set the color and transparency of the triangles (Figure \@ref(fig:collapseMode)D).

```r
collapse(p, 21, 'mixed', fill='steelblue', alpha=.4) %>% 
  collapse(23, 'mixed', fill='firebrick', color='blue')
```  

We can combine [scaleClade](#scale-clade) with `collapse` to zoom in/out of the triangles (Figure \@ref(fig:collapseMode)E).

```r
scaleClade(p, 23, .2) %>% collapse(23, 'min', fill="darkgreen")  
```


(ref:collapseModescap) Collapse clade as a triangle.

(ref:collapseModecap) **Collapse clade as a triangle.** 'max' takes the position of most distant tip (A). 'min' takes the position of closest tip (B). 'mixed' takes the positions of both closest and distant tips (C), which looks more like the shape of the clade. Set color, fill, and alpha of the triangles (D). Combine with `scaleClade` to zoom out the triangle to save space (E).


```{r collapseMode, echo=F, fig.width=8, fig.height=8, fig.cap="(ref:collapseModecap)", fig.scap="(ref:collapseModescap)", out.width='100%'}
p2 <- p + geom_tiplab()
node <- 21
g1 = expand(collapse(p2, node, 'max'), node)
g2 = expand(collapse(p2, node, 'min'), node)
g3 = expand(collapse(p2, node, 'mixed'), node)

pg1 <- collapse(p, 21, 'mixed', fill='steelblue', alpha=.4) %>% 
  collapse(23, 'mixed', fill='firebrick', color='blue')

pg2 <- scaleClade(p, 23, .2) %>% collapse(23, 'min', fill="darkgreen")  

##pp = plot_list(g1,g2,g3, ncol=3, labels=LETTERS[1:3])
##gg <- plot_list(pg1, pg2, ncol=2, labels=LETTERS[4:5])
##plot_list(pp, gg, ncol=1)

plot_list(g1, g2, g3, pg1, pg2, design="AABBCC\nDDDEEE", tag_levels='A')
```



## Grouping Taxa {#group-taxa-vis}


The `groupClade()` function assigns the branches and nodes under different clades into different groups. It accepts an internal node or a vector of internal nodes to cluster clade/clades.

Similarly, the `groupOTU()` function assigns branches and nodes to different groups based on user-specified groups of operational taxonomic units (OTUs) that are not necessarily within a clade but can be monophyletic (clade), polyphyletic or paraphyletic. It accepts a vector of OTUs (taxa name) or a list of OTUs and will trace back from OTUs to their most recent common ancestor (MRCA) and cluster them together as demonstrated in Figure \@ref(fig:groupOTU).

A phylogenetic tree can be annotated by mapping different line types, sizes, colors, or shapes of the branches or nodes that have been assigned to different groups\index{groupOTU}. 

(ref:groupOTUscap) Grouping OTUs.

(ref:groupOTUcap) **Grouping OTUs.** OTU clustering based on their relationships. Selected OTUs and their ancestors up to the MRCA will be clustered together.



```{r groupOTU, message=FALSE, fig.cap="(ref:groupOTUcap)", fig.scap="(ref:groupOTUscap)", out.extra='', out.width='100%'}
data(iris)
rn <- paste0(iris[,5], "_", 1:150)
rownames(iris) <- rn
d_iris <- dist(iris[,-5], method="man")

tree_iris <- ape::bionj(d_iris)
grp <- list(setosa     = rn[1:50],
            versicolor = rn[51:100],
            virginica  = rn[101:150])

p_iris <- ggtree(tree_iris, layout = 'circular', branch.length='none')
groupOTU(p_iris, grp, 'Species') + aes(color=Species) +
  theme(legend.position="right")
```


We can group taxa at the tree level. The following code will produce an identical figure of Figure \@ref(fig:groupOTU) (see more details described in [session 2.2.3](#grouping-taxa)).

```r
tree_iris <- groupOTU(tree_iris, grp, "Species")
ggtree(tree_iris, aes(color=Species), layout = 'circular', 
        branch.length = 'none') + 
  theme(legend.position="right")
```


## Exploring Tree Structure

To facilitate exploring the tree structure, `r Biocpkg("ggtree")` supports rotating selected clade by 180 degrees using the `rotate()` function (Figure \@ref(fig:rfClade)B). Position of immediate descendant clades of the internal node can be exchanged via `flip()` function (Figure \@ref(fig:rfClade)C).

(ref:rotateCladescap) Exploring tree structure.

(ref:rotateCladecap) **Exploring tree structure.** A clade (indicated by a dark green circle) in a tree (A) can be rotated by 180&deg; (B) and the positions of its immediate descendant clades (colored by blue and red) can be exchanged (C).


```{r echo=T, eval=F}
p1 <- p + geom_point2(aes(subset=node==16), color='darkgreen', size=5)
p2 <- rotate(p1, 16)
flip(p2, 17, 21)
```          
```{r rfClade, fig.cap="(ref:rotateCladecap)", fig.scap="(ref:rotateCladescap)", out.extra='', fig.width=7, fig.height=3, echo=F, out.width='100%'}
p1 <- p + geom_tiplab() + 
        geom_point2(aes(subset=node==16), color='darkgreen', size=5)
p2 <- rotate(p1, 16)
p3 <- flip(p2, 17, 21)
plot_list(p1, p2, p3, ncol=3, tag_levels='A')
```




Most of the tree manipulation functions are working on clades, while `r Biocpkg("ggtree")` also provides functions to manipulate a tree, including `open_tree()` to transform a tree in either rectangular or circular layout to the fan layout, and `rotate_tree()` function to rotate a tree for specific angle in both circular or fan layouts, as demonstrated in Figures \@ref(fig:openTree) and \@ref(fig:rotateTree).



```{r eval=FALSE}
p3 <- open_tree(p, 180) + geom_tiplab()
print(p3)
```

(ref:openTreescap) Transforming a tree to fan layout.

(ref:openTreecap) **Transforming a tree to fan layout.** A tree can be transformed to a fan layout by `open_tree` with a specific `angle`.

```{r openTree, fig.cap="(ref:openTreecap)", fig.scap="(ref:openTreescap)",echo=FALSE, fig.width=6, fig.height=3.5, out.extra=''}
p3 <- open_tree(p, 180) + geom_tiplab() 
ggplot() + ylim(0.5, 1) + xlim(0, 1) + theme_tree() +
  annotation_custom(ggplotGrob(p3),
                    xmin=-.2, xmax=1.15, ymin=-.25, ymax=1.3)
```



```{r eval=FALSE}
rotate_tree(p3, 180)
```


(ref:rotateTreescap) Rotating tree.

(ref:rotateTreecap) **Rotating tree.** A circular/fan layout tree can be rotated by any specific `angle`.


```{r rotateTree, echo=FALSE, fig.cap="(ref:rotateTreecap)", fig.scap="(ref:rotateTreescap)", fig.width=6, fig.height=3.2, out.extra=''}
ggplot() + ylim(0.5, 1) + xlim(0, 1)  + theme_tree() +
  annotation_custom(ggplotGrob(rotate_tree(p3, 180)),
                    xmin=-.15, xmax=1.15, ymin=.2, ymax=1.75) 
```



The following example rotates four selected clades (Figure \@ref(fig:rotategif)). It is easy to traverse all the internal nodes and rotate them one-by-one.

(ref:rotategifscap) Rotate selected clades.

(ref:rotategifcap) **Rotate selected clades.** Four clades were randomly selected to rotate (indicated by the red symbol).

<!--

{r eval=F, echo=!knitr::is_latex_output()}
set.seed(2016-05-29)
x <- rtree(50)
p <- ggtree(x) + geom_tiplab()
for (n in reorder(x, 'postorder')$edge[,1] %>% unique) {
    p <- rotate(p, n)
    print(p + geom_point2(aes(subset=(node == n)), color='red'))
}
```


{r rotategif, fig.width=8, fig.height=9.6, echo=FALSE, eval=!knitr::is_latex_output()}
knitr::include_graphics("img/rotate_clade.gif")
```

-->

```{r rotategif, fig.width=15, fig.height=6, fig.cap="(ref:rotategifcap)", fig.scap="(ref:rotategifscap)"}
set.seed(2016-05-29)
x <- rtree(50)
p <- ggtree(x) + geom_tiplab()

## nn <- unique(reorder(x, 'postorder')$edge[,1]) 
## to traverse all the internal nodes

nn <- sample(unique(reorder(x, 'postorder')$edge[,1]), 4)

pp <- lapply(nn, function(n) {
    p <- rotate(p, n)
    p + geom_point2(aes(subset=(node == n)), color='red', size=3)
})

plot_list(gglist=pp, tag_levels='A', nrow=1)
```

<!--
{r eval=FALSE, echo=!knitr::is_latex_output()}
set.seed(123)
tr <- rtree(50)
p <- ggtree(tr, layout='circular') + geom_tiplab()

for (angle in seq(0, 270, 10)) {
    print(open_tree(p, angle=angle) + ggtitle(paste("open angle:", angle)))
}
```

{r fangif, fig.width=8, fig.height=9.6, echo=FALSE, fig.cap="(ref:fangifcap)", fig.scap="(ref:fangifscap)", eval=!knitr::is_latex_output()}
knitr::include_graphics("img/fan_layout.gif")
```

-->

Figure \@ref(fig:fangif) demonstrates the usage of `open_tree()` with different open angles.

(ref:fangifscap) Open tree with different angles.

(ref:fangifcap) **Open tree with different angles.** 


```{r fangifCode, eval=FALSE}
set.seed(123)
tr <- rtree(50)
p <- ggtree(tr, layout='circular') 
angles <- seq(0, 270, length.out=6)

pp <- lapply(angles, function(angle) {
  open_tree(p, angle=angle) + ggtitle(paste("open angle:", angle))
})

plot_list(gglist=pp, tag_levels='A', nrow=2)
```

```{r fangif, fig.width=6, fig.height=4, message=FALSE, fig.cap="(ref:fangifcap)", fig.scap="(ref:fangifscap)"}
set.seed(123)
tr <- rtree(50)
p <- ggtree(tr, layout='circular') 
angles <- seq(0, 270, length.out=6)

pp <- lapply(angles, function(angle) {
  open_tree(p, angle=angle) + ggtitle(paste("open angle:", angle))
})

g <- plot_list(gglist=pp, tag_levels='A', nrow=2)
ggplotify::as.ggplot(g, vjust=-.1,scale=1.1)
```


Figure \@ref(fig:rotatetreegif) illustrates a rotating tree with different angles.

<!--
{r eval=FALSE, echo=!knitr::is_latex_output()}
for (angle in seq(0, 270, 10)) {
    print(rotate_tree(p, angle) + ggtitle(paste("rotate angle:", angle)))
}
```

{r rotatetreegif, fig.width=8, fig.height=9.6, echo=FALSE, eval=!knitr::is_latex_output(), fig.cap="(ref:rotatetreegifcap)", fig.scap="(ref:rotatetreegifscap)"}
knitr::include_graphics("img/rotate_tree.gif")
```

-->

(ref:rotatetreegifscap) Rotate tree with different angles.

(ref:rotatetreegifcap) **Rotate tree with different angles.** 



```{r rotatetreegif, fig.width=8, fig.height=6, echo=FALSE, message=FALSE, fig.cap="(ref:rotatetreegifcap)", fig.scap="(ref:rotatetreegifscap)"}
p <- p + geom_tippoint(aes(subset = node == 1), colour = 'red', size=3)
pp <- lapply(angles, function(angle) {
  rotate_tree(p, angle=angle) + ggtitle(paste("rotate angle:", angle))
})

plot_list(gglist=pp, tag_levels='A', nrow=2)
```


Interactive tree manipulation is also possible via the `identify()` method (see details described in [Chapter 12](#identify)).



## Summary {#summary6}

A good visualization tool can not only help users to present the data, but it should also be able to help users to explore the data. Data exploration can allow users to better understand the data and also help discover hidden patterns. The `r Biocpkg("ggtree")` provides a set of functions to allow visually manipulating phylogenetic trees and exploring tree structures with associated data. Exploring data in the evolutionary context may help discover new systematic patterns and generate new hypotheses.


<!--chapter:end:06_ggtree_manipulation.Rmd-->

\newpage

# Plotting tree with data {#chapter7}

```{r include=F}
library(knitr)
opts_chunk$set(message=FALSE, warning=FALSE, eval=TRUE, echo=TRUE, cache=TRUE)
```

Integrating user data to annotate a phylogenetic tree can be done at different
levels. The `r Biocpkg("treeio")` package [@wang_treeio_2020] implements `full_join()` methods to combine tree data to phylogenetic tree object.
The `r CRANpkg("tidytree")` package supports linking tree data to phylogeny
using tidyverse verbs (see also [Chapter 2](#chapter2)).
The `r Biocpkg("ggtree")` package [@yu_two_2018] supports mapping external data to phylogeny for
visualization and annotation on the fly. Although the feature of linking external data is overlapping among these packages, they have different application scopes. For example, in addition to the `treedata` object, `r Biocpkg("ggtree")` also supports several other tree objects (see [Chapter 9](#chapter9)), including `phylo4d`, `phyloseq`, and `obkData` that were designed to contain domain-specific data. The design of these objects did not consider supporting linking external data to the object (it can not be done at the tree object level). We can visualize trees from these objects using `r Biocpkg("ggtree")` and link external data at the visualization level [@yu_two_2018].

The `r Biocpkg("ggtree")` package provides two general methods for mapping and visualizing associated external data on phylogenies. [Method 1](#attach-operator) allows external data to be mapped on the tree structure and used as visual characteristics in the tree and data visualization. [Method 2](#facet_plot) plots the data with the tree side-by-side using different geometric functions after reordering the data based on the tree structure. These two methods integrate data with phylogeny for further exploration and comparison in the evolutionary biology context. The `r Biocpkg("ggtreeExtra")` provides a better implementation of the Method 2 proposed in `r Biocpkg("ggtree")` (see also [Chapter 10](#chapter10)) and works with both rectangular and circular layouts [@ggtreeExtra_2021].

## Mapping Data to The tree Structure {#attach-operator}

In `r Biocpkg("ggtree")`, we implemented an operator, `%<+%`, to attach annotation data to a `ggtree` graphic object. Any data that contains a column of "node" or the first column of taxa labels can be integrated using the `%<+%` operator. Multiple datasets can be attached progressively. When the data are attached, all the information stored in the data serves as numerical/categorical node attributes and can be directly used to visualize the tree by scaling the attributes as different colors or line sizes, labeling the tree using the original values of the attributes or parsing them as [math expression](#faq-formatting-label), [emoji](#phylomoji) or [silhouette image](#ggimage). The following example uses the `%<+%` operator to integrate taxon (`df_tip_data`) and internal node (`df_inode_data`) information and map the data to different colors or shapes of symbolic points and labels (Figure \@ref(fig:attacher)). The tip data contains `imageURL` that links to online figures of the species, which can be parsed and used as tip labels in `r Biocpkg("ggtree")` (see [Chapter 8](#chapter8))\index{data integration}. 

(ref:attacherscap) Example of attaching multiple datasets.

(ref:attachercap) **Example of attaching multiple datasets**. External datasets including tip data (e.g., trophic habit and body weight) and node data (e.g., clade posterior and vernacular name) were attached to the `ggtree` graphic via the `%<+%` operator and the data was used to annotate the tree. 

```{r attacher, fig.width=9.5, fig.height=6.2, warning=FALSE, message=FALSE, fig.cap="(ref:attachercap)", fig.scap="(ref:attacherscap)", out.width='100%'}
library(ggimage)
library(ggtree)
library(TDbook)

# load `tree_boots`, `df_tip_data`, and `df_inode_data` from 'TDbook'
p <- ggtree(tree_boots) %<+% df_tip_data + xlim(-.1, 4)
p2 <- p + geom_tiplab(offset = .6, hjust = .5) +
    geom_tippoint(aes(shape = trophic_habit, color = trophic_habit, 
                size = mass_in_kg)) + 
    theme(legend.position = "right") + 
    scale_size_continuous(range = c(3, 10))

p2 %<+% df_inode_data + 
    geom_label(aes(label = vernacularName.y, fill = posterior)) + 
    scale_fill_gradientn(colors = RColorBrewer::brewer.pal(3, "YlGnBu"))
```

Although the data integrated by the `%<+%` operator in `r Biocpkg("ggtree")` is for tree visualization, the data attached to the `ggtree` graphic object can be converted to `treedata` object that contains the tree and the attached data (see [session 7.5](#ggtree_object)).




## Aligning Graph to the Tree Based on the Tree Structure {#facet_plot}

For associating phylogenetic tree with different types of plot produced by user's data, `r Biocpkg("ggtree")` provides `geom_facet()` layer and `facet_plot()` function which accept an input `data.frame` and a `geom` layer to draw the input data. The data will be displayed in an additional panel of the plot. The `geom_facet()` (or `facet_plot`) is a general solution for linking the graphic layer to a tree. The function internally re-orders the input data based on the tree structure and visualizes the data at the specific panel by the geometric layer. Users are free to visualize several panels to plot different types of data as demonstrated in Figure \@ref(fig:phyloseq) and to use different geometric layers to plot the same dataset (Figure \@ref(fig:jv2017)) or different datasets on the same panel.

The `geom_facet()` is designed to work with most of the `geom` layers defined in `r CRANpkg("ggplot2")` and other `r CRANpkg("ggplot2")`-based packages. A list of the geometric layers that work seamlessly with `geom_facet()` and `facet_plot()` can be found in Table \@ref(tab:facet-geom). As the `r CRANpkg("ggplot2")` community keeps expanding and more `geom` layers will be implemented in either `r CRANpkg("ggplot2")` or other extensions, `geom_facet()` and `facet_plot()` will gain more power to present data in the future. Note that different `geom` layers can be combined to present data on the same panel and the combinations of different `geom` layers create the possibility to present more complex data with phylogeny (see also Figures \@ref(fig:jv2017) and \@ref(fig:gggenes)). Users can progressively add multiple panels to present and compare different datasets in the evolutionary context (Figure \@ref(fig:plottree)). Detailed descriptions can be found in the [supplemental file](https://github.com/GuangchuangYu/plotting_tree_with_data/) of [@yu_two_2018]\index{geom\textunderscore facet}.


(ref:plottreescap) Example of plotting SNP and trait data.

(ref:plottreecap) **Example of plotting SNP and trait data**. The 'location' information was attached to the tree and used to color tip symbols (Tree panel), and other datasets. SNP and Trait data were visualized as dot chart (SNP panel) and bar chart (Trait panel). 


```{r plottree, fig.width=12, fig.height=7, message=F, fig.cap="(ref:plottreecap)", fig.scap="(ref:plottreescap)", out.width='100%'}
library(ggtree)
library(TDbook)

## load `tree_nwk`, `df_info`, `df_alleles`, and `df_bar_data` from 'TDbook'
tree <- tree_nwk
snps <- df_alleles
snps_strainCols <- snps[1,] 
snps<-snps[-1,] # drop strain names
colnames(snps) <- snps_strainCols

gapChar <- "?"
snp <- t(snps)
lsnp <- apply(snp, 1, function(x) {
        x != snp[1,] & x != gapChar & snp[1,] != gapChar
    })
lsnp <- as.data.frame(lsnp)
lsnp$pos <- as.numeric(rownames(lsnp))
lsnp <- tidyr::gather(lsnp, name, value, -pos)
snp_data <- lsnp[lsnp$value, c("name", "pos")]

## visualize the tree 
p <- ggtree(tree) 

## attach the sampling information data set 
## and add symbols colored by location
p <- p %<+% df_info + geom_tippoint(aes(color=location))

## visualize SNP and Trait data using dot and bar charts,
## and align them based on tree structure
p + geom_facet(panel = "SNP", data = snp_data, geom = geom_point, 
               mapping=aes(x = pos, color = location), shape = '|') +
    geom_facet(panel = "Trait", data = df_bar_data, geom = geom_col, 
                aes(x = dummy_bar_value, color = location, 
                fill = location), orientation = 'y', width = .6) +
    theme_tree2(legend.position=c(.05, .85))
```

Companion functions to adjust [panel widths](#facet_widths) and [rename panel names](#facet_labeller) are described in [session 12.1](#facet-utils). Removing the panel name is also possible and an example was presented in Figure \@ref(fig:gggenes). We can also use `r CRANpkg("aplot")` or `r CRANpkg("patchwork")` to create composite plots as described in [session 7.5](#composite_plot). 

The `geom_facet()` (or `facet_plot()`) internally used `ggplot2::facet_grid()` and only works with Cartesian coordinate system. To align the graph to the tree for the polar system (e.g., for circular or fan layouts), we developed another Bioconductor package, `r Biocpkg("ggtreeExtra")`. The `r Biocpkg("ggtreeExtra")` package provides the `geom_fruit()` layer that works similar to `geom_facet()` (details described in [Chapter 10](#chapter10)). The `geom_fruit()` is a better implementation of the Method 2 proposed in [@yu_two_2018].

## Visualize a Tree with an Associated Matrix {#gheatmap}


The `gheatmap()` function is designed to visualize the phylogenetic tree with a heatmap of an associated matrix (either numerical or categorical). The `geom_facet()` layer is a general solution for plotting data with the tree, including heatmap. The `gheatmap()` function is specifically designed for plotting heatmap with a tree and provides a shortcut for handling column labels and color palettes. Another difference is that `geom_facet()` only supports rectangular and slanted tree layouts, while `gheatmap()` supports rectangular, slanted, and circular (Figure \@ref(fig:mgheatmap)) layouts\index{heatmap}. 

In the following example, we visualized a tree of H3 influenza viruses with their associated genotypes (Figure \@ref(fig:gheatmap)A).

```{r fig.width=8, fig.height=6, fig.align="center", warning=FALSE, message=FALSE, eval=F}
beast_file <- system.file("examples/MCC_FluA_H3.tree", package="ggtree")
beast_tree <- read.beast(beast_file)

genotype_file <- system.file("examples/Genotype.txt", package="ggtree")
genotype <- read.table(genotype_file, sep="\t", stringsAsFactor=F)
colnames(genotype) <- sub("\\.$", "", colnames(genotype))
p <- ggtree(beast_tree, mrsd="2013-01-01") + 
    geom_treescale(x=2008, y=1, offset=2) + 
    geom_tiplab(size=2)
gheatmap(p, genotype, offset=5, width=0.5, font.size=3, 
        colnames_angle=-45, hjust=0) +
    scale_fill_manual(breaks=c("HuH3N2", "pdm", "trig"), 
        values=c("steelblue", "firebrick", "darkgreen"), name="genotype")
```

The `width` parameter is to control the width of the heatmap. It supports another parameter `offset` for controlling the distance between the tree and the heatmap, such as allocating space for tip labels.


For a timescaled tree, as in this example, it's more common to use *x*-axis by using `theme_tree2`. But with this solution, the heatmap is just another layer and will change the *x*-axis. To overcome this issue, we implemented `scale_x_ggtree()` to set the *x*-axis more reasonably (Figure \@ref(fig:gheatmap)B).


```{r fig.width=8, fig.height=6, fig.align="center", warning=FALSE, eval=F}
p <- ggtree(beast_tree, mrsd="2013-01-01") + 
    geom_tiplab(size=2, align=TRUE, linesize=.5) + 
    theme_tree2()
gheatmap(p, genotype, offset=8, width=0.6, 
        colnames=FALSE, legend_title="genotype") +
    scale_x_ggtree() + 
    scale_y_continuous(expand=c(0, 0.3))
```


(ref:gheatmapscap) Example of plotting matrix with `gheatmap()`.

(ref:gheatmapcap) **Example of plotting matrix with `gheatmap()`**. A H3 influenza tree with a genotype table visualized as a heatmap (A). Tips were aligned and with a tailored *x*-axis for divergence times (tree) and genomic segments (heatmap) (B).


```{r gheatmap, fig.width=8, fig.height=12, warning=FALSE, message=FALSE, echo=F,fig.cap="(ref:gheatmapcap)", fig.scap="(ref:gheatmapscap)", out.width='90%'}
beast_file <- system.file("examples/MCC_FluA_H3.tree", package="ggtree")
beast_tree <- read.beast(beast_file)

genotype_file <- system.file("examples/Genotype.txt", package="ggtree")
genotype <- read.table(genotype_file, sep="\t", stringsAsFactor=F)
colnames(genotype) <- sub("\\.$", "", colnames(genotype))
p1 <- ggtree(beast_tree, mrsd="2013-01-01") + 
    geom_treescale(x=2008, y=1, offset=2) + 
    geom_tiplab(size=2)
g1 <- gheatmap(p1, genotype, offset=5, width=0.5, font.size=3, 
        colnames_angle=-45, hjust=0) +
    scale_fill_manual(breaks=c("HuH3N2", "pdm", "trig"), 
        values=c("steelblue", "firebrick", "darkgreen"), name="genotype")+ 
    vexpand(.03, -1)



p2 <- ggtree(beast_tree, mrsd="2013-01-01") + 
    geom_tiplab(size=2, align=TRUE, linesize=.5) + 
    theme_tree2()
g2 <- gheatmap(p2, genotype, offset=8, width=0.6, 
        colnames=FALSE, legend_title="genotype") +
    scale_x_ggtree() + 
    scale_y_continuous(expand=c(0, 0.3))

plot_list(g1, g2, ncol=1, tag_levels='A')
```


### Visualize a tree with multiple associated matrices {#gheatmap-ggnewscale}

Of course, we can use multiple `gheatmap()` function calls to align several associated matrices with the tree. However, `r CRANpkg("ggplot2")` doesn't allow us to use multiple `fill` scales^[See also discussion in <https://github.com/GuangchuangYu/ggtree/issues/78> and <https://groups.google.com/d/msg/bioc-ggtree/VQqbF79NAWU/IjIvpQOBGwAJ>].

To solve this issue, we can use the `r CRANpkg("ggnewscale")` package to create new `fill` scales. Here is an example of using `r CRANpkg("ggnewscale")` with `gheatmap()`.


(ref:mgheatmapscap) Example of plotting multiple matrix with `gheatmap()`.

(ref:mgheatmapcap) **Example of plotting multiple matrix with `gheatmap()`**. A data frame (with 'first' and 'second' columns) was visualized as a discrete heatmap and another data frame (with 'A', 'B' and 'C' columns) was visualized as a continuous heatmap with corresponding discrete and continuous palette of colors (Figure \@ref(fig:mgheatmap)). 

```{r mgheatmap, fig.width=10, fig.height=8, fig.cap="(ref:gheatmapcap)", fig.scap="(ref:gheatmapscap)", out.width='100%'}

nwk <- system.file("extdata", "sample.nwk", package="treeio")

tree <- read.tree(nwk)
circ <- ggtree(tree, layout = "circular")

df <- data.frame(first=c("a", "b", "a", "c", "d", "d", "a", 
                        "b", "e", "e", "f", "c", "f"),
                 second= c("z", "z", "z", "z", "y", "y", 
                        "y", "y", "x", "x", "x", "a", "a"))
rownames(df) <- tree$tip.label

df2 <- as.data.frame(matrix(rnorm(39), ncol=3))
rownames(df2) <- tree$tip.label
colnames(df2) <- LETTERS[1:3]


p1 <- gheatmap(circ, df, offset=.8, width=.2,
               colnames_angle=95, colnames_offset_y = .25) +
    scale_fill_viridis_d(option="D", name="discrete\nvalue")


library(ggnewscale)
p2 <- p1 + new_scale_fill()
gheatmap(p2, df2, offset=15, width=.3,
         colnames_angle=90, colnames_offset_y = .25) +
    scale_fill_viridis_c(option="A", name="continuous\nvalue")
```

## Visualize a Tree with Multiple Sequence Alignments {#msaplot}

The `msaplot()` accepts a tree (output of `ggtree()`) and a fasta file, then it can visualize the tree with sequence alignment. We can specify the `width` (relative to the tree) of the alignment and adjust the relative position by `offset`, which is similar to the `gheatmap()` function (Figure \@ref(fig:msaplot)A)\index{MSA}.

```{r eval=F}
library(TDbook)

# load `tree_seq_nwk` and `AA_sequence` from 'TDbook'
p <- ggtree(tree_seq_nwk) + geom_tiplab(size=3)
msaplot(p, AA_sequence, offset=3, width=2)
```



A specific slice of the alignment can also be displayed by specifying the `window` parameter (Figure \@ref(fig:msaplot)B)..

```{r fig.width=7, fig.height=7, fig.align='center', warning=FALSE, eval=F}
p <- ggtree(tree_seq_nwk, layout='circular') + 
    geom_tiplab(offset=4, align=TRUE) + xlim(NA, 12)
msaplot(p, AA_sequence, window=c(120, 200))
```


(ref:msaplotscap) Example of plotting multiple sequence alignment with a tree.

(ref:msaplotcap) **Example of plotting multiple sequence alignments with a tree**. Whole MSA sequences were visualized with a tree in rectangular layout (A). Circular layout with a slice of alignment window (B).  


```{r msaplot, fig.width=14, fig.height=7, warning=FALSE, echo=F, fig.cap="(ref:msaplotcap)", fig.scap="(ref:msaplotscap)", out.width='100%'}
library(ggtree)
library(TDbook)

p <- ggtree(tree_seq_nwk) + geom_tiplab(size=3) + 
    theme(legend.position="none")
g1 = msaplot(p, AA_sequence, offset=3, width=2)

p2 <- ggtree(tree_seq_nwk, layout='circular') + 
    geom_tiplab(offset=4, align=TRUE) + xlim(NA, 12) + 
    theme(legend.position="none")
g2 = msaplot(p2, AA_sequence, window=c(120, 200))  
plot_list(g1, g2, ncol=2, tag_levels='A')
```

To better support visualizing multiple sequence alignments with a tree and other associated data, we developed the `r Biocpkg("ggmsa")` package with the ability to label the sequences and color the sequences with different color schemes [@yu_cp_2020]. The `ggmsa()` output is compatible with `geom_facet()` and `ggtreeExtra::geom_fruit()` and can be used to visualize a tree, multiple sequence alignments, and different types of associated data to explore their underlying linkages/associations. 

## Composite Plots {#composite_plot}

In addition to aligning graphs to a tree using `geom_facet()` or `ggtreeExtra::geom_fruit()` and special cases using the `gheatmap()` and `msaplot()` functions, users can use `r CRANpkg("cowplot")`, `r CRANpkg("patchwork")`, `r CRANpkg("gtable")`^[<https://github.com/YuLab-SMU/ggtree/issues/313>] or other packages to create composite plots. However, extra efforts need to be done to make sure all the plots are aligned properly. The [`ggtree::get_taxa_name()`](#tiporder) function is quite useful for users to re-order their data based on the tree structure. To remove this obstacle, we created an R package `r CRANpkg("aplot")` that can re-order the internal data of a `ggplot` object and create composite plots that align properly with a tree\index{composite plots}.


In the following example, we have a tree with two associated datasets.

```{r}
library(ggplot2)
library(ggtree)

set.seed(2019-10-31)
tr <- rtree(10)

d1 <- data.frame(
    # only some labels match
    label = c(tr$tip.label[sample(5, 5)], "A"),
    value = sample(1:6, 6))

d2 <- data.frame(
    label = rep(tr$tip.label, 5),
    category = rep(LETTERS[1:5], each=10),
    value = rnorm(50, 0, 3)) 

g <- ggtree(tr) + geom_tiplab(align=TRUE) + hexpand(.01)

p1 <- ggplot(d1, aes(label, value)) + geom_col(aes(fill=label)) + 
    geom_text(aes(label=label, y= value+.1)) +
    coord_flip() + theme_tree2() + theme(legend.position='none')
 
p2 <- ggplot(d2, aes(x=category, y=label)) + 
    geom_tile(aes(fill=value)) + scale_fill_viridis_c() + 
    theme_minimal() + xlab(NULL) + ylab(NULL)
```



<!-- 
We can extract coordinates from `ggtree` object using `r CRANpkg("dplyr")` verbs implemented in `r CRANpkg("tidytree")`, and merge the y-coordinates to our datasets.

``` r
library(dplyr)
library(tidytree) 

d <- filter(g, isTip) %>% select(c(label, y))

dd1 <- left_join(d1, d, by='label')
dd2 <- left_join(d2, d, by='label') 
```

Now we can visualize our datasets using the y-coordinates that match corresponding labels in the `ggtree` object. 

-->



<!-- 
If we combine these two plots with `ggtree` using either `r CRANpkg("cowplot")` or `r Githubpkg("thomasp85", "patchwork")`, they do not align properly. 

To address this issue, `r Biocpkg("ggtree")` provides a `ylim2()` function to reconcile y limits^[the implementation was inspired by <https://thackl.github.io/ggtree-composite-plots>]. 

``` r message=TRUE
p1 <- p1 + ylim2(g)  
p2 <- p2 + ylim2(g)
```

Now we can plot our tree and the data side by side, and perfectly aligned.


## library(patchwork) 
## g + p1 + p2 + plot_annotation(tag_levels="A")

library(cowplot) 
plot_grid(g, p1, p2, ncol=3, align='h', 
    labels=LETTERS[1:3], rel_widths = c(1, .5, .8))


The `ylim2()` is not designed specific for `r Biocpkg("ggtree")`, it works fine with `ggplot` object. Another function `xlim2()` that works for x limits is also provided. See [session 10.5](#axis_align) for more details.

-->


If we align them using `r CRANpkg("cowplot")`, the composite plots are not aligned properly as we anticipated (Figure \@ref(fig:composite)A).

```r
cowplot::plot_grid(g, p2, p1, ncol=3) 
```

Using `r CRANpkg("aplot")`, it will do all the dirty work for us and all the subplots are aligned properly as demonstrated in Figure \@ref(fig:composite)B.

```r
library(aplot)
p2 %>% insert_left(g) %>% insert_right(p1, width=.5) 
```


(ref:compositescap) Example of aligning tree with data side by side to create composite plot.

(ref:compositecap) **Example of aligning tree with data side-by-side to create composite plot**. `r CRANpkg("cowplot")`` just places the subplots together (A), while `r CRANpkg("aplot")` does extra work to make sure that tree-associated subplots are properly ordered according to the tree structure (B). Note: The 'A' category in the bar plot that is not matched with the tree was removed.

```{r composite, echo = FALSE, fig.width=12, fig.height=10, fig.cap="(ref:compositecap)", fig.scap="(ref:compositescap)", out.width='100%'}
pg1 <- cowplot::plot_grid(g, p2, p1, ncol=3)
library(aplot)
pg2 <- p2 %>% insert_left(g) %>% insert_right(p1, width=.5)
pg2 <- ggplotify::as.ggplot(pg2)
cowplot::plot_grid(pg1, pg2, ncol=1, labels=c("A", "B")) 
```

<!--

## The `ggtree` object {#ggtree_object}


to be finished.



## Update tree view with a new tree

In previous example, we have a _`p`_ object that stored the tree viewing of 13 tips and internal nodes highlighted with specific colored big dots. If users want to apply this pattern (we can imaging a more complex one) to a new tree, you don't need to build the tree step by step. `ggtree` provides an operator, _`%<%`_, for applying the visualization pattern to a new tree.

For example, the pattern in the _`p`_ object will be applied to a new tree with 50 tips as shown below:
``` r fig.width=3, fig.height=3, fig.align="center"}
p %<% rtree(50)
```
-->


## Summary {#summary7}


Although there are many software packages that support visualizing phylogenetic trees, plotting a tree with data is often missing or with only limited support. Some of the packages define `S4` classes to store phylogenetic tree with domain-specific data, such as `r CRANpkg("OutbreakTools")` [@jombart_outbreaktools_2014] defined `obkData` for storing tree with epidemiology data and `r Biocpkg("phyloseq")` [@mcmurdie_phyloseq_2013] defines `phyloseq` for storing tree with microbiome data. These packages are capable of presenting some of the data stored in the object on the tree. However, not all the associated data are supported. For example, species abundance stored in the `phyloseq` object is not supported to be visualized using the `r Biocpkg("phyloseq")` package. These packages did not provide any utilities to integrate external data for tree visualization. None of these packages support visualizing external data and aligning the plot to a tree based on the tree structure. 


The `r Biocpkg("ggtree")` package provides two general solutions for integrating data. Method 1, the `%<+%` operator, can integrate external and internal node data and map the data as a visual characteristic to visualize the tree and other datasets used in `geom_facet()` or `ggtreeExtra::geom_fruit()`. Method 2, the `geom_facet` layer or `ggtreeExtra::geom_fruit()`, has no restriction of input data as long as there is a `geom` function available to plot the data (*e.g.*, species abundance displayed by `geom_density_ridges` as demonstrated in Figure \@ref(fig:phyloseq)). Users are free to combine different panels and combine different `geom` layers in the same panel (Figure \@ref(fig:jv2017)). 

\newpage

The `r Biocpkg("ggtree")` package has many unique features that cannot be found in other implementations [@yu_two_2018]:

1. Integrating node/edge data to the tree can be mapped to visual characteristics of the tree or other datasets (Figure \@ref(fig:attacher)).
2. Capable of parsing expressions (math symbols or text formatting), emoji, and image files ([Chapter 8](#chapter8)). 
3. No pre-definition of input data types or how the data should be plotted in `geom_facet()` (Table \@ref(tab:facet-geom)).
4. Combining different `geom` functions to visualize associated data is supported (Figure \@ref(fig:jv2017)).
5. Visualizing different datasets on the same panel is supported.
6. Data integrated by `%<+%` can be used in `geom_facet()` layer.
7. Able to add further annotations to specific layers.
8. Modular design by separating tree visualization, data integration (Method 1), and graph alignment (Method 2).


Modular design is a unique feature for `r Biocpkg("ggtree")` to stand out from other packages. The tree can be visualized with data stored in the tree object or external data linked by the `%<+%` operator, and fully annotated with multiple layers of annotations (Figures \@ref(fig:attacher) and \@ref(fig:jv2017)), before passing it to `geom_facet()` layer. The `geom_facet()` layer can be called progressively to add multiple panels or multiple layers on the same panels (Figure \@ref(fig:jv2017)). This creates the possibility of plotting a full annotated tree with complex data panels that contain multiple graphic layers.

The `r Biocpkg("ggtree")` package fits the `R` ecosystem and extends the abilities to integrate and present data with trees to existing phylogenetic packages. As demonstrated in Figure \@ref(fig:phyloseq), we can plot species abundance distributions with the `phyloseq` object. This cannot be easily done without `r Biocpkg("ggtree")`. With `r Biocpkg("ggtree")`, we are able to attach additional data to tree objects using the `%<+%` operator and align graphs to a tree using the `geom_facet()` layer. Integrating `r Biocpkg("ggtree")` into existing workflows will extend the abilities and broaden the applications to present phylogeny-associated data, especially for comparative studies.


<!--chapter:end:07_ggtree_tree_with_data.Rmd-->

\newpage

# Annotating Tree with Silhouette Images and Sub-plots {#chapter8}

```{r init, include=F}
library(knitr)
opts_chunk$set(message=FALSE, warning=FALSE, eval=TRUE, echo=TRUE, cache=TRUE)

library(ggimage)
library(ggplot2)
library(ggtree)
```

## Annotating Tree with Images {#ggimage}

We usually use text to label taxa, *i.e.* displaying taxa names. If the text is the image file name (either local or remote), `r Biocpkg("ggtree")` can read the image and display the actual image as the label of the taxa (Figure \@ref(fig:frogimage)). The `geom_tiplab()` and `geom_nodelab()` are capable to render silhouette images with supports from in-house developed package, `r CRANpkg("ggimage")`\index{ggimage}. 

Online tools such as `r pkg_itol` [@letunic_interactive_2007] and `r pkg_evolview` [@he_evolview_2016] support displaying subplots on a phylogenetic tree. However, only bar and pie charts are supported by these tools. Users may want to visualize node-associated data with other visualization methods, such as violin plot [@grubaugh_genomic_2017], venn diagram [@lott_covenntree:_2015], sequence logo, *etc.*, and display them on the tree. In `r Biocpkg("ggtree")`, all kinds of subplots are supported, as we can export all subplots to image files and use them to label corresponding nodes on the tree.

(ref:frogimagescap) Labelling taxa with images.

(ref:frogimagecap) **Labelling taxa with images.** Users need to specify `geom = "image"` and map the image file names onto the `image` aesthetics. 


```{r frogimage, fig.width=8, fig.height=6, message=F, warning=F, dev='png', dpi=150, fig.cap="(ref:frogimagecap)", fig.scap="(ref:frogimagescap)", out.width='100%'}
library(ggimage)
library(ggtree)

nwk <- paste0("((((bufonidae, dendrobatidae), ceratophryidae),",
          "(centrolenidae, leptodactylidae)), hylidae);")

imgdir <- system.file("extdata/frogs", package = "TDbook")

x = read.tree(text = nwk)
ggtree(x) + xlim(NA, 7) + ylim(NA, 6.2) +
    geom_tiplab(aes(image=paste0(imgdir, '/', label, '.jpg')), 
                geom="image", offset=2, align=2, size=.2)  + 
    geom_tiplab(geom='label', offset=1, hjust=.5) + 
    geom_image(x=.8, y=5.5, image=paste0(imgdir, "/frog.jpg"), size=.2)
```

## Annotating Tree with Phylopic {#phylopic}

[Phylopic](phylopic.org) contains more than 3200 silhouettes and covers almost all life forms. The `r Biocpkg("ggtree")` package supports using phylopic^[<https://twitter.com/guangchuangyu/status/593443854541434882>] to annotate the tree by setting `geom="phylopic"` and mapping phylopic UID to the `image` aesthetics. The `r CRANpkg("ggimage")` package supports querying phylopic UID from the scientific name, which is very handy for annotating tree with phylopic. In the following example, tip labels were used to query phylopic UID, and phylopic images were used to label the tree as another layer of tip labels. Most importantly, we can color or resize the images using numerical/categorical variables, and here the values of body mass were used to encode the color of the images (Figure \@ref(fig:phylopic))\index{Phylopic}. 


<!--
#```
tree <- ape::read.nexus("data/tree.nex")
phylopic_info <- data.frame(node = c(124, 113, 110, 96, 89, 70),
                            phylopic = c("c4ac9ea6-b465-4ed0-a5de-9fe4eebd3ef9",
                                        "5388a472-994a-48e1-86de-d988c6019e72",
                                        "615c82cf-fabe-49f8-b571-e8117edfa212",
                                        "63ff1b70-6b6e-4412-b4d2-b2e2fb51aa95",
                                        "d65d5abd-df8b-4509-912c-e42f6c34861f",
                                        "6d54acc7-9e1e-4b79-be88-4904cf58fbb5"),
                            species = c("galagoids", "lemurs", "tarsiers",
                                        "cebids", "hominoids", "cercopithecoids"))
pg <- ggtree(tree)
pg <- pg %<+% phylopic_info + 
  geom_nodelab(aes(image=phylopic, color=species, subset=!is.na(species)), 
              geom="phylopic", alpha = .6) + 
  theme(legend.position=c(.2, .8))
#```

## optional: download the phylopic images
ggimage::download_phylopic(d$uid, destdir="data/phylopic", quiet=TRUE)

## to enable using downloaded files
## otherwise, geom_tiplab will try to read the online images
options(phylopic_dir = "data/phylopic")


-->


```{r ggimage_phylopic, eval=FALSE}
library(ggtree)
newick <- paste0("((Pongo_abelii,(Gorilla_gorilla_gorilla,(Pan_paniscus,",
          "Pan_troglodytes)Pan,Homo_sapiens)Homininae)Hominidae,",
          "Nomascus_leucogenys)Hominoidea;")

tree <- read.tree(text=newick)

d <- ggimage::phylopic_uid(tree$tip.label)
d$body_mass <- c(52, 114, 47, 45, 58, 6)

p <- ggtree(tree) %<+% d + 
  geom_tiplab(aes(image=uid, colour=body_mass), geom="phylopic", offset=2.5) +
  geom_tiplab(aes(label=label), offset = .2) + xlim(NA, 7) +
  scale_color_viridis_c()
```

<!--  (A). The UID can be searched using scientific names of the taxa (B) -->


(ref:phylopicscap) Labelling taxa with phylopic images. 

(ref:phylopiccap) **Labelling taxa with phylopic images.** The `r Biocpkg("ggtree")` will automatically download phylopic figures by querying provided UID. The figures can be colored using numerical or categorical values.


```{r phylopic, fig.width=7.17, figh.height=4.3, fig.cap="(ref:phylopiccap)", fig.scap="(ref:phylopicscap)", echo=FALSE}
# print(p)
# cowplot::plot_grid(pg, p, ncol=2, labels=LETTERS[1:2]) 
knitr::include_graphics("img/phylopic.png")
```

## Annotating Tree with Sub-plots {#subplots}


The `r Biocpkg("ggtree")` package provides a layer, `geom_inset()`, for adding subplots to a phylogenetic tree. The input is a named list of `ggplot` graphic objects (can be any kind of chart). These objects should be named by node numbers. Users can also use `r CRANpkg("ggplotify")` to convert plots generated by other functions (even implemented by base graphics) to `ggplot` objects, which can then be used in the `geom_inset()` layer. To facilitate adding bar and pie charts (*e.g.*, summarized stats of results from ancestral reconstruction) to the phylogenetic tree, `r Biocpkg("ggtree")` provides the `nodepie()` and `nodebar()` functions to create a list of pie or bar charts\index{ggimage}.

### Annotate with bar charts


This example uses `ape::ace()` function to estimate ancestral character states. The likelihoods of the stats were visualized as stacked bar charts which were overlayed onto internal nodes of the tree using the `geom_inset()` layer (Figure \@ref(fig:pieInset)A)\index{geom\textunderscore inset}. 


(ref:barInsetscap) Annotate internal nodes with barplots.

(ref:barInsetcap) **Annotate internal nodes with barplots.** 



```{r barInset, fig.width=10, fig.height=9.6, fig.cap="(ref:barInsetcap)", fig.scap="(ref:barInsetscap)", out.width='100%'}
library(phytools)
data(anoletree)
x <- getStates(anoletree,"tips")
tree <- anoletree

cols <- setNames(palette()[1:length(unique(x))],sort(unique(x)))
fitER <- ape::ace(x,tree,model="ER",type="discrete")
ancstats <- as.data.frame(fitER$lik.anc)
ancstats$node <- 1:tree$Nnode+Ntip(tree)

## cols parameter indicate which columns store stats
bars <- nodebar(ancstats, cols=1:6)
bars <- lapply(bars, function(g) g+scale_fill_manual(values = cols))

tree2 <- full_join(tree, data.frame(label = names(x), stat = x ), by = 'label')
p <- ggtree(tree2) + geom_tiplab() +
    geom_tippoint(aes(color = stat)) + 
    scale_color_manual(values = cols) +
    theme(legend.position = "right") + 
    xlim(NA, 8)
p1 <- p + geom_inset(bars, width = .08, height = .05, x = "branch") 
```


The `x` position can be one of `r squote('node')` or `r squote('branch')` and can be adjusted by the parameters, `hjust` and `vjust`, for horizontal and vertical adjustment, respectively. The `width` and `height` parameters restrict the size of the inset plots. 



### Annotate with pie charts

Similarly, users can use the `nodepie()` function to generate a list of pie charts and place these charts to annotate corresponding nodes (Figure \@ref(fig:pieInset)B). Both `nodebar()` and `nodepie()` accept a parameter of `alpha` to allow transparency. 

(ref:pieInsetscap) Annotate internal nodes with bar or pie charts.

(ref:pieInsetcap) **Annotate internal nodes with bar or pie charts.** Using bar charts (A) or pie charts (B) to display summary statistics of internal nodes. 



```{r pieInset, fig.width=16, fig.height=9.6, fig.cap="(ref:pieInsetcap)", fig.scap="(ref:pieInsetscap)", out.width='100%'}
pies <- nodepie(ancstats, cols = 1:6)
pies <- lapply(pies, function(g) g+scale_fill_manual(values = cols))
p2 <- p + geom_inset(pies, width = .1, height = .1) 

plot_list(p1, p2, guides='collect', tag_levels='A')
```


### Annotate with mixed types of charts

The `geom_inset()` layer accepts a list of `r squote('ggplot')` graphic objects and these input objects are not restricted to pie or bar charts. They can be any kind of charts or hybrid of these charts. The `geom_inset()` is not only useful to display ancestral stats, but also applicable to visualize different types of data that are associated with selected nodes in the tree. Here, we use a mixture of pie and bar charts to annotate the tree as an example (Figure \@ref(fig:barpieInset))\index{geom\textunderscore inset}.

(ref:barpieInsetscap) Annotate internal nodes with different types of subplots.

(ref:barpieInsetcap) **Annotate internal nodes with different types of subplots.** 



```{r barpieInset, fig.width=10, fig.height=9.6, fig.cap="(ref:barpieInsetcap)", fig.scap="(ref:barpieInsetscap)", out.width='100%'}
pies_and_bars <- pies
i <- sample(length(pies), 20)
pies_and_bars[i] <- bars[i]
p + geom_inset(pies_and_bars, width=.08, height=.05)
```




## Have Fun with Phylomoji {#phylomoji}

Phylomoji is a phylogenetic tree of emoji. It is fun^[<https://twitter.com/hashtag/phylomoji?src=hash>] and very useful for education of the evolution concept. The `r Biocpkg("ggtree")` supports producing phylomoji since 2015^[<https://twitter.com/guangchuangyu/status/662095056610811904> and <https://twitter.com/guangchuangyu/status/667337429704011777>]. Here, we will use `r Biocpkg("ggtree")` to recreate the following phylomoji figure^[<https://twitter.com/OxyMLZ/status/1055586178651451392>] (Figure \@ref(fig:phylomoji1))\index{emojifont}:

[![](img/phylomoji.png)](https://twitter.com/OxyMLZ/status/1055586178651451392)


(ref:phylomoji1scap) Parsing label as emoji.

(ref:phylomoji1cap) **Parsing label as emoji.** Text (*e.g.*, node or tip labels) can be parsed as emoji. 


```{r eval=FALSE}
library(ggplot2)
library(ggtree)

tt = '((snail,mushroom),(((sunflower,evergreen_tree),leaves),green_salad));'
tree = read.tree(text = tt)
d <- data.frame(label = c('snail','mushroom', 'sunflower',
                          'evergreen_tree','leaves', 'green_salad'),
                group = c('animal', 'fungi', 'flowering plant',
                          'conifers', 'ferns', 'mosses'))

p <- ggtree(tree, linetype = "dashed", size=1, color='firebrick') %<+% d + 
  xlim(0, 4.5) + ylim(0.5, 6.5) +
  geom_tiplab(parse="emoji", size=15, vjust=.25) +
  geom_tiplab(aes(label = group), geom="label", x=3.5, hjust=1)
```

```{r phylomoji1, fig.width=7, fig.height=5, warning=F, fig.cap="(ref:phylomoji1cap)", fig.scap="(ref:phylomoji1scap)", out.width='100%', echo=FALSE}
knitr::include_graphics("img/phylomoji-ggtree.png")

#if (knitr::is_html_output()) {
#  print(p)
#} else {
#  knitr::include_graphics("img/phylomoji-ggtree.png")
#} 
```


Note that the output may depend on what emoji fonts are installed in your system^[Google Noto emoji fonts was installed in my system].

With `r Biocpkg("ggtree")`, it is easy to generate phylomoji. The emoji is treated as text, like 'abc'. We can use emojis to label taxa, clade, color and rotate emoji with any given color and angle. This functionality is internally supported by the `r CRANpkg("emojifont")` package.

### Emoji in circular/fan layout tree

It also works with circular and fan layouts as demonstrated in Figure \@ref(fig:emojifan). 

```{r fig.width=6, fig.height=6, warning=F, dev='png', eval=FALSE}
p <- ggtree(tree, layout = "circular", size=1) +  
  geom_tiplab(parse="emoji", size=10, vjust=.25)
print(p)

## fan layout  
p2 <- open_tree(p, angle=200) 
print(p2)

p2 %>% rotate_tree(-90)
```

(ref:emojifanscap) Phylomoji in cirular and fan layouts.

(ref:emojifancap) **Phylomoji in cirular and fan layouts.** 


```{r emojifan, fig.width=9.2, fig.height=7.3, warning=F, echo=F, fig.cap="(ref:emojifancap)", fig.scap="(ref:emojifanscap)", out.width='100%'}
if (FALSE) {
p <- ggtree(tree, layout = "circular", size=1) +  
  geom_tiplab(parse="emoji", size=10, vjust=.25)

p2 <- open_tree(p, angle=200)
 
p2x <- ggplot() + ylim(0.5, 1) + xlim(0, 1) + theme_tree() +
  annotation_custom(ggplotGrob(p2), 
                    xmin=-.1, xmax=1.1, ymin=-.25, ymax=1.25)

p3 <- p2 %>% rotate_tree(-90) 
 
p3x <- ggplot() + ylim(0, 1) + xlim(0.5, 1) + theme_tree() +
  annotation_custom(ggplotGrob(p3), 
                    ymin=-.1, ymax=1.1, xmin=-.25, xmax=1.25)

a <- plot_list(p, labels='A')
b <- plot_list(p2x, labels='B')
c <- plot_list(p3x, labels='C')
g <- ggplot() + xlim(0,1) + ylim(0,1) 

gg <- g + annotation_custom(ggplotGrob(c), xmin=.5, xmax=1, ymin=0, ymax=1) + 
  annotation_custom(ggplotGrob(b), xmin=0.02, xmax=.5, ymin=0, ymax=.3) + 
  annotation_custom(ggplotGrob(a), xmin=0, xmax=.5, ymin=.4, ymax=1) +
  theme_void()

ggsave(gg, filename = "img/phylomoji-ggtree-circular.png", 
      width=9.2, height=7.3, bg='white')

}


knitr::include_graphics("img/phylomoji-ggtree-circular.png")

# print(gg)
#if (knitr::is_html_output()) {
#  print(gg)
#} else {
#  knitr::include_graphics("img/phylomoji-ggtree-circular.png")
#}
```


Another example using `r Biocpkg("ggtree")` and `r CRANpkg("emojifont")` to produce phylogeny of plant emojis can be found in a scientific article [@escudero_grand_2020].


### Emoji to label clades


Parsing clade labels as emojis is also supported in the `geom_cladelab()` layer. For example, in a phylogenetic tree of influenza viruses, we can use emojis to label clades to represent host species similar to Figure \@ref(fig:emojiclade)\index{emojifont}. 

(ref:emojicladescap) Emoji to label clades.

(ref:emojicladecap) **Emoji to label clades.** 


```{r emojiclade, fig.width=6, fig.height=5, fig.cap="(ref:emojicladecap)", fig.scap="(ref:emojicladescap)", out.width='100%'}
set.seed(123)
tr <- rtree(30)

dat <- data.frame(
           node = c(41, 53, 48),
           name = c("chicken", "duck", "family")
       )

p <- ggtree(tr) + 
     xlim(NA, 5.2) +
     geom_cladelab(
         data = dat,
         mapping = aes(
             node = node, 
             label = name, 
             color = name
         ),
         parse = "emoji",
         fontsize = 12,
         align = TRUE,
         show.legend = FALSE
     ) +
     scale_color_manual(
         values = c(
             chicken="firebrick", 
             duck="steelblue", 
             family = "darkkhaki"
         )
     )
p
```



### Apple Color Emoji

Although `R`'s graphical devices don't support `AppleColorEmoji` font on MacOS, it's still possible to use it. We can export the `plot` to a `svg` file and render it in `Safari` (Figure \@ref(fig:applemoji)).

```r
library(ggtree)
tree_text <- paste0("(((((cow, (whale, dolphin)), (pig2, boar)),",
                    "camel), fish), seedling);")
x <- read.tree(text=tree_text)
library(ggimage)
p <-  ggtree(x, size=2) + geom_tiplab(size=20, parse='emoji') +
    xlim(NA, 7) + ylim(NA, 8.5) 

svglite::svglite("emoji.svg", width = 10, height = 7)
print(p)
dev.off()

# or use `grid.export()` 
# ps = gridSVG::grid.export("emoji.svg", addClass=T)
```


(ref:applemojiscap) Use Apple Color Emoji in `ggtree`.

(ref:applemojicap) **Use Apple Color Emoji in `ggtree`.** The tip labels were parsed as emojis using `AppleColorEmoji` font in Safari. 



```{r applemoji, out.width="100%", echo=F, fig.scap="(ref:applemojiscap)", fig.cap="(ref:applemojicap)"}
knitr::include_graphics("img/apple_emoji.png", auto_pdf = TRUE)
```

### Phylomoji in ASCII art

Producing phylomoji as an ASCII art is also possible. Users can refer to [Appendix D](#ascii-tree) for details.

## Summary {#summary8}

The `r Biocpkg("ggtree")` supports parsing labels, including tip labels, internal node labels, and clade labels, as images, math expression, and emoji, in case the labels can be parsed as image file names, `plotmath` expression, or emoji names, respectively. It can be fun, but it's also very useful for scientific research. The use of images on phylogenetic trees can help to present species-related characteristics, including morphological, anatomical, and even macromolecular structures. Moreover, `r Biocpkg("ggtree")` supports summarizing statistical inferences (*e.g.*, biogeographic range reconstruction and posterior distribution) or associated data of the nodes as subplots to be displayed on a phylogenetic tree. 



<!--chapter:end:08_ggtree_with_silhouette.Rmd-->

\newpage

# ggtree for Other Tree-like Objects {#chapter9}

## ggtree for Phylogenetic Tree Objects

The `r Biocpkg("treeio")` packages [@wang_treeio_2020] allow parsing evolutionary inferences from several software outputs and linking external data to the tree structure. It serves as an infrastructure to bring evolutionary data to the R community. The `r Biocpkg("ggtree")` package [@yu_ggtree:_2017] works seamlessly with `r Biocpkg("treeio")` to visualize tree-associated data to annotate the tree. The `r Biocpkg("ggtree")` package is a general tool for tree visualization and annotation and it fits the ecosystem of R packages. Most of the S3/S4 tree objects defined by other R packages are also supported by `r Biocpkg("ggtree")`, including `phylo` ([session 4.2](#visualizing-phylogenetic-tree-with-ggtree)), `multiPhylo` ([session 4.4](#visualize-a-list-of-trees)), `phylo4`, `phylo4d`, `phyloseq`, and `obkData`. With `r Biocpkg("ggtree")`, we are able to generate more complex tree graphs which is not possible or easy to do with other packages. For example, the visualization of the `phyloseq` object in Figure \@ref(fig:phyloseq) is not supported by the `r Biocpkg("phyloseq")` package. The `r Biocpkg("ggtree")` package also extends the possibility of linking external data to these tree objects [@yu_two_2018].


### The phylo4 and phylo4d objects {#phylobase}

The `phylo4` and `phylo4d` are defined in the `r CRANpkg("phylobase")` package. The `phylo4` object is an S4 version of `phylo`, while `phylo4d` extends `phylo4` with a data frame that contains trait data. The `r CRANpkg("phylobase")` package provides a `plot()` method, which is internally called the `treePlot()` function, to display the tree with the data. However, there are some restrictions of the `plot()` method, it can only plot numeric values for tree-associated data as bubbles and cannot generate figure legend. `Phylobase` doesn't implement a visualization method to display categorical values. Using associated data as visual characteristics such as color, size, and shape, is also not supported. Although it is possible to color the tree using associated data, it requires users to extract the data and map them to the color vector manually followed by passing the color vector to the `plot` method. This is tedious and error-prone since the order of the color vector needs to be consistent with the edge list stored in the object.


The `r Biocpkg("ggtree")` package supports `phylo4d` object and all the associated data stored in the `phylo4d` object can be used directly to annotate the tree (Figure \@ref(fig:fp4d)).

(ref:fp4dscap) Visualizing `phylo4d` data using ggtree.

(ref:fp4dcap) **Visualizing `phylo4d` data using ggtree.** Reproduce the output of the `plot()` method provided in the `r CRANpkg("phylobase")` package (A). Visualize the trait data as a heatmap which is not supported in the `r CRANpkg("phylobase")` package (B).

```{r fp4d, warning=F, fig.width=10, fig.height=6.2, fig.cap="(ref:fp4dcap)", fig.scap="(ref:fp4dscap)", out.width="90%"}
library(phylobase)
data(geospiza_raw)
g1 <- as(geospiza_raw$tree, "phylo4")
g2 <- phylo4d(g1, geospiza_raw$data, missing.data="warn")

d1 <- data.frame(x = seq(1.1, 2, length.out = 5),
                lab = names(geospiza_raw$data))

p1 <- ggtree(g2) + geom_tippoint(aes(size = wingL), x = d1$x[1], shape = 1) + 
    geom_tippoint(aes(size = tarsusL), x = d1$x[2], shape = 1) + 
    geom_tippoint(aes(size = culmenL), x = d1$x[3], shape = 1) + 
    geom_tippoint(aes(size = beakD),   x = d1$x[4], shape = 1) + 
    geom_tippoint(aes(size = gonysW),  x = d1$x[5], shape = 1) + 
    scale_size_continuous(range = c(3,12), name="") + 
    geom_text(aes(x = x, y = 0, label = lab), data = d1, angle = 45) +
    geom_tiplab(offset = 1.3) + xlim(0, 3) +
    theme(legend.position = c(.1, .75)) + vexpand(.05, -1) 

## users can use `as.treedata(g2)` to convert `g2` to a `treedata` object
## and use `get_tree_data()` function to extract the associated data 

p2 <- gheatmap(ggtree(g1), data=geospiza_raw$data, colnames_angle=45) + 
  geom_tiplab(offset=1) + hexpand(.2) + vexpand(.05, -1) + 
  theme(legend.position = c(.1, .75))

aplot::plot_list(p1, p2, ncol=2, tag_levels='A')    
```


### The phylog object {#phylog}

The `phylog` is defined in the `r CRANpkg("ade4")` package. The package is designed for analyzing ecological data and provides `newick2phylog()`, `hclust2phylog()`, and `taxo2phylog()` functions to create phylogeny from Newick string, hierarchical clustering result, or a taxonomy (see also the `r Biocpkg("MicrobiotaProcess")` package described in [Chapter 11](#chapter11)). The `phylog` object is also supported by `r Biocpkg("ggtree")` as demonstrated in Figure \@ref(fig:phylog).

(ref:phylogscap) Visualizing a `phylog` tree object.

(ref:phylogcap) **Visualizing a `phylog` tree object.** 


```{r phylog, fig.width=7, fig.height=4.8, fig.cap="(ref:phylogcap)", fig.scap="(ref:phylogscap)", out.width='100%'}
library(ade4)
data(taxo.eg)
tax <- as.taxo(taxo.eg[[1]])
names(tax) <- c("genus", "family", "order")
print(tax)
tax.phy <- taxo2phylog(as.taxo(taxo.eg[[1]]))
print(tax.phy)

ggtree(tax.phy) + geom_tiplab() + 
  geom_nodelab(geom='label') + hexpand(.05)
```


### The phyloseq object {#phyloseq}

The `phyloseq` class defined in the `r Biocpkg("phyloseq")` package was designed for storing microbiome data, including a phylogenetic tree, associated sample data, and taxonomy assignment. It can import data from popular pipelines, such as `r pkg_qiime` [@kuczynski_using_2011], `r pkg_mothur` [@schloss_introducing_2009], `r Biocpkg("dada2")` [@callahan_dada2_2016] and `r pkg_pyrotagger` [@kunin_pyrotagger_2010], *etc*. The `r Biocpkg("ggtree")` supports visualizing the phylogenetic tree stored in the `phyloseq` object and related data can be used to annotate the tree as demonstrated in Figures \@ref(fig:reproducephyloseq) and \@ref(fig:phyloseq).

(ref:reproducephyloseqscap) Visualizing a `phyloseq` tree object.

(ref:reproducephyloseqcap) **Visualizing a `phyloseq` tree object.** This example mimics the output of the `plot_tree()` function provided in the `r Biocpkg("phyloseq")` package. 

```{r reproducephyloseq, fig.height=7, fig.width=9.5, message=FALSE, fig.cap="(ref:reproducephyloseqcap)", fig.scap="(ref:reproducephyloseqscap)", out.extra='', warning=FALSE,out.width='100%'}
library(phyloseq)
library(scales)

data(GlobalPatterns)
GP <- prune_taxa(taxa_sums(GlobalPatterns) > 0, GlobalPatterns)
GP.chl <- subset_taxa(GP, Phylum=="Chlamydiae")

ggtree(GP.chl) + 
  geom_nodelab(aes(label=label), hjust=-.05, size=3.5) +

  geom_point(aes(x=x+hjust, color=SampleType, shape=Family, 
                size=Abundance), na.rm=TRUE) +
  geom_tiplab(aes(label=Genus), hjust=-.35) +                
  scale_size_continuous(trans=log_trans(5)) +
  theme(legend.position="right") + hexpand(.4)
```


Figure \@ref(fig:reproducephyloseq) reproduces the output of the `phyloseq::plot_tree()` function. Users of `r Biocpkg("phyloseq")` will find `r Biocpkg("ggtree")` useful for visualizing microbiome data and for further annotation since `r Biocpkg("ggtree")` supports high-level annotation using the grammar of graphics and can add tree data layers that are not available in `r Biocpkg("phyloseq")`.

(ref:phyloseqscap) Phylogenetic tree with OTU abundance densities.

(ref:phyloseqcap) **Phylogenetic tree with OTU abundance densities.** Tips were colored by Phylum, and the corresponding abundances across different samples were visualized as density ridgelines and sorted according to the tree structure.


```{r phyloseq, fig.height=6.6, fig.width=7, message=FALSE, fig.cap="(ref:phyloseqcap)", fig.scap="(ref:phyloseqscap)", out.extra='', warning=FALSE, out.width='100%'}
library(ggridges)

data("GlobalPatterns")
GP <- GlobalPatterns
GP <- prune_taxa(taxa_sums(GP) > 600, GP)
sample_data(GP)$human <- get_variable(GP, "SampleType") %in% 
  c("Feces", "Skin") 

mergedGP <- merge_samples(GP, "SampleType")
mergedGP <- rarefy_even_depth(mergedGP,rngseed=394582)
mergedGP <- tax_glom(mergedGP,"Order") 

melt_simple <- psmelt(mergedGP) %>% 
  filter(Abundance < 120) %>% 
  select(OTU, val=Abundance)

ggtree(mergedGP) + 
  geom_tippoint(aes(color=Phylum), size=1.5) +
  geom_facet(mapping = aes(x=val,group=label, 
                           fill=Phylum),
            data = melt_simple, 
            geom = geom_density_ridges,
            panel="Abundance",  
            color='grey80', lwd=.3) +
  guides(color = guide_legend(ncol=1))          
```



This example uses microbiome data provided in the `r Biocpkg("phyloseq")` package and density ridgeline is employed to visualize species abundance data. The `geom_facet()` layer automatically re-arranges the abundance data according to the tree structure, visualizes the data using the specified `geom` function, *i.e.*, `geom_density_ridges()`, and aligns the density curves with the tree as demonstrated in Figure \@ref(fig:phyloseq). Note that data stored in the `phyloseq` object is visible to `ggtree()` and can be used directly in tree visualization (`Phylum` was used to color tips and density ridgelines in this example). The source code of this example was firstly published in the supplemental file of [@yu_two_2018].


<!-- 
### The obkData object {#obkdata}

The `okbData` is defined in the `r CRANpkg("OutbreakTools")` package to store incidence-based outbreak data, including meta data of sampling and information of infected individuals such as age and onset of symptoms. The `ggtree` supports the `obkData` object and the information can be used to annotate the tree as shown in Figure \@ref(fig:outbreaktools).

(ref:outbreaktoolsscap) Visualizing obkData tree object.

(ref:outbreaktoolscap) **Visualizing obkData tree object.** *x*-axis was scaled by timeline of the outbreak and tips were colored by location of different individuals.


```r outbreaktools, fig.width=6.3, fig.height=7, fig.cap="(ref:outbreaktoolscap)", fig.scap="(ref:outbreaktoolsscap)", message=FALSE, out.extra=''}
library(OutbreakTools)
data(FluH1N1pdm2009)
attach(FluH1N1pdm2009)

x <- new("obkData", 
         individuals = individuals, 
         dna = dna,
         dna.individualID = samples$individualID, 
         dna.date = samples$date,
         trees = FluH1N1pdm2009$trees)
ggtree(x, mrsd="2009-09-30", as.Date=TRUE, right=TRUE) +
    geom_tippoint(aes(color=location), size=3, alpha=.75) +
    scale_color_brewer("location", palette="Spectral") +
    theme_tree2(legend.position='right')
```


-->

## ggtree for Dendrograms {#dendrogram}

A dendrogram is a tree diagram to display hierarchical clustering and classification/regression trees. In R, we can calculate a hierarchical clustering using the function `hclust()`\index{dendrogram}.

```{r}
hc <- hclust(dist(mtcars))
hc
```

The `hclust` object describes the tree produced by the clustering process. It can be converted to `dendrogram` object, which stores the tree as deeply-nested lists. 

```{r}
den <- as.dendrogram(hc)
den
```

The `r Biocpkg("ggtree")` package supports most of the hierarchical clustering objects defined in the R community, including `hclust` and `dendrogram` as well as `agnes`, `diana`, and `twins` that are defined in the `r CRANpkg("cluster")` package, and the `pvclust` object defined in the `r CRANpkg("pvclust")` package (Table \@ref(tab:tree-objects)). Users can use `ggtree(object)` to display its tree structure, and use other layers and utilities to customize the graph and of course, add annotations to the tree.

The `r Biocpkg("ggtree")` provides `layout_dendrogram()` to layout the tree top-down, and `theme_dendrogram()` to display tree height (similar to `theme_tree2()` for phylogenetic tree) as demonstrated in Figure \@ref(fig:ggtreehclust) (see also the example in [@yu_cp_2020]).


(ref:ggtreehclustscap) Visualizing dendrogram.

(ref:ggtreehclustcap) **Visualizing dendrogram.** Use `cutree()` to split the tree into several groups and `groupClade()` to assign this grouping information. The tree was displayed in the classic top-down layout with branches colored by the grouping information and the tips were colored and labeled by the number of cylinders. 

```{r echo=F}
MRCA = ggtree:::MRCA.ggtree
```


```{r ggtreehclust, fig.width=9, fig.height=5, fig.cap="(ref:ggtreehclustcap)", fig.scap="(ref:ggtreehclustscap)",out.width='100%'}
clus <- cutree(hc, 4)
g <- split(names(clus), clus)

p <- ggtree(hc, linetype='dashed')
clades <- sapply(g, function(n) MRCA(p, n))

p <- groupClade(p, clades, group_name='subtree') + aes(color=subtree)

d <- data.frame(label = names(clus), 
                  cyl = mtcars[names(clus), "cyl"])

p %<+% d + 
  layout_dendrogram() + 
  geom_tippoint(aes(fill=factor(cyl), x=x+.5), 
                size=5, shape=21, color='black') + 
  geom_tiplab(aes(label=cyl), size=3, hjust=.5, color='black') +
  geom_tiplab(angle=90, hjust=1, offset=-10, show.legend=FALSE) + 
  scale_color_brewer(palette='Set1', breaks=1:4) +
  theme_dendrogram(plot.margin=margin(6,6,80,6)) +
  theme(legend.position=c(.9, .6))
```

```{r echo=FALSE}
MRCA = tidytree::MRCA
```

## ggtree for Tree Graph {#igraph}

The tree graph (as  an `igraph` object) can be converted to a `phylo` object using `as.phylo()` method provided in the `r Biocpkg("treeio")` package (Table \@ref(tab:tree-objects)). The `r Biocpkg("ggtree")` supports directly visualizing tree graph as demonstrated in Figure \@ref(fig:treeGraph). Note that currently not all `igraph` objects can be supported by `r Biocpkg("ggtree")`. Currently, it can only be supported when it is a tree graph\index{tree graph}.


(ref:treeGraphscap) Visualizing a tree graph.

(ref:treeGraphcap) **Visualizing a tree graph.** The lines with arrows indicate the relationship between the parent node and the child node. All nodes were indicated by steelblue circle points. 


```{r treeGraph, fig.width=10, fig.height=5, fig.cap="(ref:treeGraphcap)", fig.scap="(ref:treeGraphscap)", out.width='100%'}
library(igraph)
g <- graph.tree(40, 3)
arrow_size <- unit(rep(c(0, 3), times = c(27, 13)), "mm")
ggtree(g, layout='slanted', arrow = arrow(length=arrow_size)) + 
  geom_point(size=5, color='steelblue', alpha=.6) + 
  geom_tiplab(hjust=.5,vjust=2) + layout_dendrogram()
```



## ggtree for Other Tree-like Structures

The `r Biocpkg("ggtree")` package can be used to visualize any data in a hierarchical structure. Here, we use the GNI (Gross National Income) numbers in 2014 as an example. After preparing an edge list, that is a matrix or data frame that contains two columns indicating the relationship of parent and child nodes, we can use the `as.phylo()` method provided by the `r Biocpkg("treeio")` package to convert the edge list to a `phylo` object. Then it can be visualized using `r Biocpkg("ggtree")` with associated data. In this example, the population was used to scale the size of circle points for each country (Figure \@ref(fig:gni2014)).



(ref:gni2014scap) Visualizing data in any hierarchical structure.

(ref:gni2014cap) **Visualizing data in any hierarchical structure.** Hierarchical data represented as nodes connected by edges can be converted to a `phylo` object and visualized by `r Biocpkg("ggtree")` to explore their relationships or other properties that are associated with the relationships\index{dendrogram}. 




```{r gni2014, fig.width=12, fig.height=10, fig.cap="(ref:gni2014cap)", fig.scap="(ref:gni2014scap)", out.width='100%'}
library(treeio)
library(ggplot2)
library(ggtree)

data("GNI2014", package="treemap")
n <- GNI2014[, c(3,1)]
n[,1] <- as.character(n[,1])
n[,1] <- gsub("\\s\\(.*\\)", "", n[,1])

w <- cbind("World", as.character(unique(n[,1])))

colnames(w) <- colnames(n)
edgelist <- rbind(n, w)

y <- as.phylo(edgelist)
ggtree(y, layout='circular') %<+% GNI2014 + 
    aes(color=continent) + geom_tippoint(aes(size=population), alpha=.6) + 
    geom_tiplab(aes(label=country), offset=.05, size=3) +
    xlim(NA, 3)
```

## Summary {#summary9}

The `r Biocpkg("ggtree")` supports various tree objects defined in the R language and extension packages, which makes it very easy to integrate `r Biocpkg("ggtree")` into existing pipelines. Moreover, `r Biocpkg("ggtree")` allows external data integration and exploration of these data on the tree, which will greatly promote the data visualization and result in interpretation in the downstream analysis of existing pipelines. Most importantly, the support for converting edge list to a tree object enables more tree-like structures to be incorporated into the framework of `r Biocpkg("treeio")` and `r Biocpkg("ggtree")`. This will enable more tree-like structures and related heterogeneous data in different disciplines to be integrated and visualized through `r Biocpkg("treeio")` and `r Biocpkg("ggtree")`, which facilitates integrated analysis and comparative analysis to discover more systematic patterns and insights. 



<!--chapter:end:09_ggtree_tree_objects.Rmd-->

# (PART\*) Part III: ggtree extensions {-}

\newpage

# ggtreeExtra for Presenting Data on a Circular Layout {#chapter10}

## Introduction


The `r Biocpkg("ggtree")` package [@yu_ggtree:_2017] provides programmable visualization and annotation of [phylogenetic trees](#chapter5) and [other tree-like structures](#chapter9). It supports visualizing tree data in multiple layers or with the tree side-by-side (see also [Chapter 7](#chapter7) and [@yu_two_2018]). Although `r Biocpkg("ggtree")` supports [many layouts](#tree-layouts), the `geom_facet()` layer only works with `rectangular`, `roundrect`, `ellipse`, and `slanted` layouts to present tree data on different panels. There is no direct support in `r Biocpkg("ggtree")` to present data on the outer rings of a tree in `circular`, `fan`, and `radial` layouts. To solve this issue, we developed the `r Biocpkg("ggtreeExtra")` package, which allows users to align associated graph layers in outer rings of circular layout tree. In addition, it also works with a `rectangular` tree layout (Figure \@ref(fig:HMPplot2))\index{ggtreeExtra}. 


## Aligning Graphs to the Tree Based on a Tree Structure {#geom-fruit1}

The `r Biocpkg("ggtreeExtra")` package provides a layer function, `geom_fruit()`, to align graphs with the tree side-by-side. Similar to the `geom_facet()` layout described in [Chapter 7](#chapter7), `geom_fruit()` internally re-orders the input data based on the tree structure and visualizes the data using a specified geometric layer function with user-provided aesthetic mapping and non-variable setting. The graph will be displayed on the outer ring of the tree\index{geom\textunderscore fruit}. 


The `geom_fruit()` is designed to work with most `geom` layers defined in `r CRANpkg("ggplot2")` and its extensions. The position of the graph (*i.e.*, on the outer ring) is controlled by the `position` parameter, which accepts a `Position` object. The default value of the `position` parameter is `r squote('auto')` and the `geom_fruit()` layer will guess and determine (hopefully) a suitable position for the specified geometric layer. That means using `position_stackx()` for `geom_bar()`, `position_dodgex()` for `geom_violin()` and `geom_boxplot()`, and `position_identityx()` for others (*e.g.*, `geom_point()`, `geom_tile()`, *etc.*). A geometric layer that has a `position` parameter should be compatible with `geom_fruit()`, as it allows using position functions defined in the `r Biocpkg("ggtreeExtra")` package to adjust output layer positions. Besides, the `geom_fruit()` layer allows setting `axis` and background grid lines for the current layer using the `axis.params` and `grid.params` parameters, respectively\index{data integration}.


The following example uses microbiome\index{microbiome} data provided in the `r Biocpkg("phyloseq")` package and a boxplot is employed to visualize species abundance data. The `geom_fruit()` layer automatically rearranges the abundance data according to the circular tree structure and visualizes the data using the specific `geom` function (*i.e.*, `geom_boxplot()`). Visualizing this dataset using `geom_density_ridges()` with `geom_facet()` can be found in figure 1 of [@yu_two_2018].


(ref:psboxplotscap) Phylogenetic tree with OTU abundance distribution.

(ref:psboxplotcap) **Phylogenetic tree with OTU abundance distribution**. Species abundance distribution was aligned to the tree and visualized as boxplots. The Phylum information was used to color symbolic points on the tree and also species abundance distributions.

```{r psbox, fig.width=9, fig.height=7, message=FALSE, fig.cap="(ref:psboxplotcap)", fig.scap="(ref:psboxplotscap)", out.extra='', warning=FALSE, out.width="100%"}
library(ggtreeExtra)
library(ggtree)
library(phyloseq)
library(dplyr)

data("GlobalPatterns")
GP <- GlobalPatterns
GP <- prune_taxa(taxa_sums(GP) > 600, GP)
sample_data(GP)$human <- get_variable(GP, "SampleType") %in%
                              c("Feces", "Skin")
mergedGP <- merge_samples(GP, "SampleType")
mergedGP <- rarefy_even_depth(mergedGP,rngseed=394582)
mergedGP <- tax_glom(mergedGP,"Order")

melt_simple <- psmelt(mergedGP) %>%
               filter(Abundance < 120) %>%
               select(OTU, val=Abundance)

p <- ggtree(mergedGP, layout="fan", open.angle=10) + 
     geom_tippoint(mapping=aes(color=Phylum), 
                   size=1.5,
                   show.legend=FALSE)
p <- rotate_tree(p, -90)

p <- p +
     geom_fruit(
         data=melt_simple,
         geom=geom_boxplot,
         mapping = aes(
                     y=OTU,
                     x=val,
                     group=label,
                     fill=Phylum,
                   ),
         size=.2,
         outlier.size=0.5,
         outlier.stroke=0.08,
         outlier.shape=21,
         axis.params=list(
                         axis       = "x",
                         text.size  = 1.8,
                         hjust      = 1,
                         vjust      = 0.5,
                         nbreak     = 3,
                     ),
         grid.params=list()
     ) 
     
p <- p +
     scale_fill_discrete(
         name="Phyla",
         guide=guide_legend(keywidth=0.8, keyheight=0.8, ncol=1)
     ) +
     theme(
         legend.title=element_text(size=9), 
         legend.text=element_text(size=7) 
     )
p
```



## Aligning Multiple Graphs to the Tree for Multi-dimensional Data {#geom-fruit2}

We are able to add multiple `geom_fruit()`\index{geom\textunderscore fruit} layers to a tree and the circular layout is indeed more compact and efficient for multi-dimensional data. This example reproduces figure 2 of [@morgan2013HMP]. The data is provided by GraPhlAn [@GraPhlAn], which contained the relative abundance of the microbiome at different body sites. This example demonstrates the ability to add multiple layers (heat map and bar plot) to present different types of data (Figure \@ref(fig:HMPplot))\index{microbiome}. 


(ref:HMPscap) Presenting microbiome data (abundance and location) on a phylogenetic tree.

(ref:HMPcap) **Presenting microbiome data (abundance and location) on a phylogenetic tree.** The tree was annotated with symbolic points, highlighted clades, and clade labels. Two `geom_fruit()` layers were used to visualize location and abundance information.

```{r HMPplot, dev='png', dpi=300, fig.width=7, fig.height=7,  warning=FALSE, message=FALSE, fig.cap="(ref:HMPcap)", fig.scap="(ref:HMPscap)", out.extra='', warning=FALSE, out.width="100%"}
library(ggtreeExtra)
library(ggtree)
library(treeio)
library(tidytree)
library(ggstar)
library(ggplot2)
library(ggnewscale)
library(TDbook)

# load data from TDbook, including tree_hmptree, 
# df_tippoint (the abundance and types of microbes),
# df_ring_heatmap (the abundance of microbes at different body sites),
# and df_barplot_attr (the abundance of microbes of greatest prevalence)
tree <- tree_hmptree
dat1 <- df_tippoint
dat2 <- df_ring_heatmap
dat3 <- df_barplot_attr

# adjust the order
dat2$Sites <- factor(dat2$Sites, 
                    levels=c("Stool (prevalence)", "Cheek (prevalence)",
                             "Plaque (prevalence)","Tongue (prevalence)",
                             "Nose (prevalence)", "Vagina (prevalence)",
                             "Skin (prevalence)"))
dat3$Sites <- factor(dat3$Sites, 
                    levels=c("Stool (prevalence)", "Cheek (prevalence)",
                             "Plaque (prevalence)", "Tongue (prevalence)",
                             "Nose (prevalence)", "Vagina (prevalence)",
                             "Skin (prevalence)"))
# extract the clade label information. Because some nodes of tree are
# annotated to genera, which can be displayed with high light using ggtree.
nodeids <- nodeid(tree, tree$node.label[nchar(tree$node.label)>4])
nodedf <- data.frame(node=nodeids)
nodelab <- gsub("[\\.0-9]", "", tree$node.label[nchar(tree$node.label)>4])
# The layers of clade and hightlight
poslist <- c(1.6, 1.4, 1.6, 0.8, 0.1, 0.25, 1.6, 1.6, 1.2, 0.4,
             1.2, 1.8, 0.3, 0.8, 0.4, 0.3, 0.4, 0.4, 0.4, 0.6,
             0.3, 0.4, 0.3)
labdf <- data.frame(node=nodeids, label=nodelab, pos=poslist)

# The circular layout tree.
p <- ggtree(tree, layout="fan", size=0.15, open.angle=5) +
     geom_hilight(data=nodedf, mapping=aes(node=node),
                  extendto=6.8, alpha=0.3, fill="grey", color="grey50",
                  size=0.05) +
     geom_cladelab(data=labdf, 
                   mapping=aes(node=node, 
                               label=label,
                               offset.text=pos),
                   hjust=0.5,
                   angle="auto",
                   barsize=NA,
                   horizontal=FALSE, 
                   fontsize=1.4,
                   fontface="italic"
                   )

p <- p %<+% dat1 + geom_star(
                        mapping=aes(fill=Phylum, starshape=Type, size=Size),
                        position="identity",starstroke=0.1) +
        scale_fill_manual(values=c("#FFC125","#87CEFA","#7B68EE","#808080",
                                "#800080", "#9ACD32","#D15FEE","#FFC0CB",
                                "#EE6A50","#8DEEEE", "#006400","#800000",
                                "#B0171F","#191970"),
                           guide=guide_legend(keywidth = 0.5, 
                                        keyheight = 0.5, order=1,
                                        override.aes=list(starshape=15)),
                           na.translate=FALSE)+
        scale_starshape_manual(values=c(15, 1),
                           guide=guide_legend(keywidth = 0.5, 
                                        keyheight = 0.5, order=2),
                           na.translate=FALSE)+
        scale_size_continuous(range = c(1, 2.5),
                           guide = guide_legend(keywidth = 0.5, 
                                        keyheight = 0.5, order=3,
                                        override.aes=list(starshape=15)))
                                                    
p <- p + new_scale_fill() +
         geom_fruit(data=dat2, geom=geom_tile,
                  mapping=aes(y=ID, x=Sites, alpha=Abundance, fill=Sites),
                  color = "grey50", offset = 0.04,size = 0.02)+
         scale_alpha_continuous(range=c(0, 1),
                             guide=guide_legend(keywidth = 0.3, 
                                             keyheight = 0.3, order=5)) +
         geom_fruit(data=dat3, geom=geom_bar,
                    mapping=aes(y=ID, x=HigherAbundance, fill=Sites),
                    pwidth=0.38, 
                    orientation="y", 
                    stat="identity",
         ) +
         scale_fill_manual(values=c("#0000FF","#FFA500","#FF0000",
                                "#800000", "#006400","#800080","#696969"),
                           guide=guide_legend(keywidth = 0.3, 
                                        keyheight = 0.3, order=4))+
         geom_treescale(fontsize=2, linesize=0.3, x=4.9, y=0.1) +
         theme(legend.position=c(0.93, 0.5),
               legend.background=element_rect(fill=NA),
               legend.title=element_text(size=6.5),
               legend.text=element_text(size=4.5),
               legend.spacing.y = unit(0.02, "cm"),
             )
p
```

The shape of the tip points indicates the types of microbes (commensal microbes or potential pathogens). The transparency of the heatmap indicates the abundance of the microbes, and the colors of the heatmap indicate different sites of the human body. The bar plot indicates the relative abundance of the most prevalent species at the body sites. The node labels contain taxonomy information in this example, and the information was used to highlight and label corresponding clades using `geom_hilight()`\index{geom\textunderscore hilight} and `geom_cladelab()`\index{geom\textunderscore cladelab}, respectively.


The `geom_fruit()` layer supports rectangular layout. Users can either add a `geom_fruit()` layer to a rectangular tree (e.g., `ggtree(tree_object) + geom_fruit(...)`) or use `layout_rectangular()` to transform a circular layout tree to a rectangular layout tree as demonstrated in Figure \@ref(fig:HMPplot2).

(ref:HMP2scap) Illustration of using `geom_fruit()` in rectangular tree layout.

(ref:HMP2cap) **Illustration of using `geom_fruit()` in rectangular tree layout.** The figure was produced by transforming Figure \@ref(fig:HMPplot) using the rectangular layout. Transforming a rectangular layout tree to a circular layout tree is also supported.

```{r HMPplot2, dev='png', dpi=300, fig.width=7, fig.height=7, warning=FALSE, message=FALSE, fig.cap="(ref:HMP2cap)", fig.scap="(ref:HMP2scap)", out.extra='', warning=FALSE, out.width="100%"}
p + layout_rectangular() + 
    theme(legend.position=c(.05, .7))
```


## Examples for Population Genetics

The `r Biocpkg("ggtree")` [@yu_ggtree:_2017] and `r Biocpkg("ggtreeExtra")` packages are designed as general tools and can be applied to many research fields, such as infectious disease epidemiology, metagenome, population genetics, evolutionary biology, and ecology. We have introduced examples for metagenome research (Figure \@ref(fig:psbox) and Figure \@ref(fig:HMPplot)). In this session, we present examples for population genetics by reproducing figure 4 of [@Chowe:_2020] and figure 1 of [@RN46:_2015]. 


(ref:Cauriscap) Antifungal susceptibility and point mutations in drug targets in Candida Auris.

(ref:Cauricap) **Antifungal susceptibility and point mutations in drug targets in *Candida Auris* **.

(ref:Styphiscap) Population structure of the 1,832 S. Typhi isolates.

(ref:Styphicap) **Population structure of the 1,832 *S. Typhi* isolates**.

```{r Caurisplot, fig.width=7, fig.height=7, warning=FALSE, message=FALSE, fig.cap="(ref:Cauricap)", fig.scap="(ref:Cauriscap)", out.extra='', warning=FALSE, out.width="100%"}
library(ggtree)
library(ggtreeExtra)
library(ggplot2)
library(ggnewscale)
library(reshape2)
library(dplyr)
library(tidytree)
library(ggstar)
library(TDbook)

# load tr and dat from the TDbook package 
dat <- df_Candidaauris_data
tr <- tree_Candidaauris

countries <- c("Canada", "United States",
               "Colombia", "Panama",
               "Venezuela", "France",
               "Germany", "Spain",
               "UK", "India",
               "Israel", "Pakistan",
               "Saudi Arabia", "United Arab Emirates",
               "Kenya", "South Africa",
               "Japan", "South Korea",
               "Australia")
# For the tip points
dat1 <- dat %>% select(c("ID", "COUNTRY", "COUNTRY__colour"))
dat1$COUNTRY <- factor(dat1$COUNTRY, levels=countries)
COUNTRYcolors <- dat1[match(countries,dat$COUNTRY),"COUNTRY__colour"]

# For the heatmap layer
dat2 <- dat %>% select(c("ID", "FCZ", "AMB", "MCF"))
dat2 <- melt(dat2,id="ID", variable.name="Antifungal", value.name="type")
dat2$type <- paste(dat2$Antifungal, dat2$type)
dat2$type[grepl("Not_", dat2$type)] = "Susceptible"
dat2$Antifungal <- factor(dat2$Antifungal, levels=c("FCZ", "AMB", "MCF"))
dat2$type <- factor(dat2$type,
                    levels=c("FCZ Resistant",
                            "AMB Resistant",
                            "MCF Resistant",
                            "Susceptible"))

# For the points layer
dat3 <- dat %>% select(c("ID", "ERG11", "FKS1")) %>%
        melt(id="ID", variable.name="point", value.name="mutation")
dat3$mutation <- paste(dat3$point, dat3$mutation)
dat3$mutation[grepl("WT", dat3$mutation)] <- NA
dat3$mutation <- factor(dat3$mutation, 
                        levels=c("ERG11 Y132F", "ERG11 K143R",
                                 "ERG11 F126L", "FKS1 S639Y/P/F"))

# For the clade group
dat4 <- dat %>% select(c("ID", "CLADE"))
dat4 <- aggregate(.~CLADE, dat4, FUN=paste, collapse=",")
clades <- lapply(dat4$ID, function(x){unlist(strsplit(x,split=","))})
names(clades) <- dat4$CLADE

tr <- groupOTU(tr, clades, "Clade")
Clade <- NULL
p <- ggtree(tr=tr, layout="fan", open.angle=15, size=0.2, aes(colour=Clade)) +
     scale_colour_manual(
         values=c("black","#69B920","#9C2E88","#F74B00","#60C3DB"),
         labels=c("","I", "II", "III", "IV"),
         guide=guide_legend(keywidth=0.5,
                            keyheight=0.5,
                            order=1,
                            override.aes=list(linetype=c("0"=NA,
                                                         "Clade1"=1,
                                                         "Clade2"=1,
                                                         "Clade3"=1,
                                                         "Clade4"=1
                                                        )
                                             )
                           )
     ) + 
     new_scale_colour()

p1 <- p %<+% dat1 +
     geom_tippoint(aes(colour=COUNTRY),
                   alpha=0) +
     geom_tiplab(aes(colour=COUNTRY),
                   align=TRUE,
                   linetype=3,
                   size=1,
                   linesize=0.2,
                   show.legend=FALSE
                   ) +
     scale_colour_manual(
         name="Country labels",
         values=COUNTRYcolors,
         guide=guide_legend(keywidth=0.5,
                            keyheight=0.5,
                            order=2,
                            override.aes=list(size=2,alpha=1))
     )

p2 <- p1 +
      geom_fruit(
          data=dat2,
          geom=geom_tile,
          mapping=aes(x=Antifungal, y=ID, fill=type),
          width=0.1,
          color="white",
          pwidth=0.1,
          offset=0.15
      ) +
      scale_fill_manual(
           name="Antifungal susceptibility",
           values=c("#595959", "#B30000", "#020099", "#E6E6E6"),
           na.translate=FALSE,
           guide=guide_legend(keywidth=0.5,
                              keyheight=0.5,
                              order=3
                             )
      ) +
      new_scale_fill()

p3 <- p2 +
      geom_fruit(
          data=dat3,
          geom=geom_star,
          mapping=aes(x=mutation, y=ID, fill=mutation, starshape=point),
          size=1,
          starstroke=0,
          pwidth=0.1,
          inherit.aes = FALSE,
          grid.params=list(
                          linetype=3,
                          size=0.2
                      )

      ) +
      scale_fill_manual(
          name="Point mutations",
          values=c("#329901", "#0600FF", "#FF0100", "#9900CC"),
          guide=guide_legend(keywidth=0.5, keyheight=0.5, order=4,
                             override.aes=list(
                                    starshape=c("ERG11 Y132F"=15,
                                                "ERG11 K143R"=15,
                                                "ERG11 F126L"=15,
                                                "FKS1 S639Y/P/F"=1),
                                    size=2)
                            ),
          na.translate=FALSE,
      ) +
      scale_starshape_manual(
          values=c(15, 1),
          guide="none"
      ) +
      theme(
          legend.background=element_rect(fill=NA),
          legend.title=element_text(size=7), 
          legend.text=element_text(size=5.5),
          legend.spacing.y = unit(0.02, "cm")
      )
p3
```

In this example, Figure \@ref(fig:Caurisplot) shows the phylogenetic tree annotated with different colors to display different clades. The external heatmaps present the susceptibility to fluconazole (FCZ), amphotericin B (AMB), and micafungin (MCF). The external points display the point mutations in lanosterol 14-alpha-demethylase ERG11 (Y132F, K143R, and F126L) and beta-1,3-D-glucan synthase FKS1 (S639Y/P/F) associated with resistance [@Chowe:_2020]\index{geom\textunderscore fruit}.

```{r Styphiplot, fig.width=7, fig.height=7, warning=FALSE, message=FALSE, fig.cap="(ref:Styphicap)", fig.scap="(ref:Styphiscap)", out.extra='', warning=FALSE, out.width="100%"}
library(ggtreeExtra)
library(ggtree)
library(ggplot2)
library(ggnewscale)
library(treeio)
library(tidytree)
library(dplyr)
library(ggstar)
library(TDbook)

# load tree_NJIDqgsS and df_NJIDqgsS from TDbook
tr <- tree_NJIDqgsS
metada <- df_NJIDqgsS
metadata <- metada %>%
            select(c("id", "country", "country__colour", 
                    "year", "year__colour", "haplotype"))
metadata$haplotype[nchar(metadata$haplotype) == 0] <- NA

countrycolors <- metada %>%
                 select(c("country", "country__colour")) %>%
                 distinct()

yearcolors <- metada %>%
              select(c("year", "year__colour")) %>%
              distinct()
yearcolors <- yearcolors[order(yearcolors$year, decreasing=TRUE),]

metadata$country <- factor(metadata$country, levels=countrycolors$country)
metadata$year <- factor(metadata$year, levels=yearcolors$year)

p <- ggtree(tr, layout="fan", open.angle=15, size=0.1)

p <- p %<+% metadata

p1 <-p +
     geom_tippoint(
         mapping=aes(colour=country),
         size=1.5,
         stroke=0,
         alpha=0.4
     ) +
     scale_colour_manual(
         name="Country",
         values=countrycolors$country__colour,
         guide=guide_legend(keywidth=0.3,
                            keyheight=0.3,
                            ncol=2,
                            override.aes=list(size=2,alpha=1),
                            order=1)
     ) +
     theme(
         legend.title=element_text(size=5),
         legend.text=element_text(size=4),
         legend.spacing.y = unit(0.02, "cm")
     )

p2 <-p1 +
     geom_fruit(
         geom=geom_star,
         mapping=aes(fill=haplotype),
         starshape=26,
         color=NA,
         size=2,
         starstroke=0,
         offset=0,
     ) +
     scale_fill_manual(
         name="Haplotype",
         values=c("red"),
         guide=guide_legend(
                   keywidth=0.3,
                   keyheight=0.3,
                   order=3
               ),
         na.translate=FALSE
     )

p3 <-p2 +
     new_scale_fill() +
     geom_fruit(
         geom=geom_tile,
         mapping=aes(fill=year),
         width=0.002,
         offset=0.1
     ) +
     scale_fill_manual(
         name="Year",
         values=yearcolors$year__colour,
         guide=guide_legend(keywidth=0.3, keyheight=0.3, ncol=2, order=2)
     ) +
     theme(
           legend.title=element_text(size=6), 
           legend.text=element_text(size=4.5),
           legend.spacing.y = unit(0.02, "cm")
           )
p3
```


Figure \@ref(fig:Styphiplot) is a rooted maximum-likelihood tree of *S. Typhi* inferred from 22,145 SNPs [@RN46:_2015], the colors of the tip points represent the geographical origin of the isolates, and the red symbolic points indicate the haplotype of H58 lineage. The color of the external heatmap indicates the years of isolation [@RN46:_2015]\index{geom\textunderscore fruit}.


## Summary {#summary10}


<!--

`r Biocpkg("ggtreeExtra")` provides function, `geom_fruit` to align graphs to the tree. But the associated graphs will align in different position. So we also developed `geom_fruit_list` to add multiple layers in the same position. 




such as `geom_star` in `r CRANpkg("ggstar")`, which provides the regular polygon layer for easily discernible shapes based on the grammar of `r CRANpkg("ggplot2")`. 

-->

Compared to `geom_facet()`, `geom_fruit()` layer provided in `r Biocpkg("ggtreeExtra")` is a better implementation of Method 2 proposed by [@yu_two_2018]. The `geom_facet()` and `geom_fruit()` have the same design philosophy and have a similar user interface. They rely on other geometric layers to visualize the tree-associated data. These dependent layers are provided by `r CRANpkg("ggplot2")` and its extension packages, including `r Biocpkg("ggtree")`. As more and more layers are implemented by the `r CRANpkg("ggplot2")` community, the types of data and graphics that `geom_facet()` and `geom_fruit()` can present will also increase.





<!--chapter:end:10_ggtree_exts.Rmd-->

\newpage

# Other ggtree Extensions {#chapter11}

```{r include=F}
library(knitr)
opts_chunk$set(message=FALSE, warning=FALSE, eval=TRUE, echo=TRUE, cache=TRUE)
```

The `r Biocpkg("ggtree")` package is a general package for visualizing tree structures and associated data. If you have some special requirements that are not directly provided by `r Biocpkg("ggtree")`, you may need to use one of the extension packages built on top of `r Biocpkg("ggtree")`. For example, the `r CRANpkg("RevGadgets")` package for visualizing the output of the `r pkg_revbayes`, the `r Biocpkg("sitePath")` package for visualizing fixation events on phylogenetic pathways, and the `r Biocpkg("enrichplot")` package for visualizing hierarchical structure of the enriched pathways.  


```{r revdep}
rp <- BiocManager::repositories()
db <- utils::available.packages(repo=rp)
x <- tools::package_dependencies('ggtree', db=db, 
                                which = c("Depends", "Imports"), 
                                reverse=TRUE)
print(x)                                
```

There are `r length(unlist(x))` packages in CRAN or Bioconductor that depend on or import `r Biocpkg("ggtree")` and several packages on GitHub that extend `r Biocpkg("ggtree")`. Here we briefly introduce some extension packages, including `r Biocpkg("MicrobiotaProcess")` and `r Biocpkg("tanggle")`.



## Taxonomy Annotation Using MicrobiotaProcess {#MicrobiotaProcess}

The `r Biocpkg("MicrobiotaProcess")` package provides a LEfSe-like algorithm [@segata_metagenomic_2011] to discover microbiome biomarkers by comparing taxon abundance between different classes. It provides several methods to visualize the analysis result. The `ggdiffclade` is developed based on `r Biocpkg("ggtree")` [@yu_ggtree:_2017]. In addition to the `diff_analysis()` result, it also supports a data frame that contains a hierarchical relationship (*e.g.*, [taxonomy annotation](#MicrobiotaProcess-taxonomy) or KEGG annotation) with another data frame that contains taxa and factor information and/or pvalue. The following example demonstrates how to use data frames (*i.e.*, analysis results) to visualize the differential taxonomy tree. More details can be found on the vignette of the `r Biocpkg("MicrobiotaProcess")` package. 


(ref:CRCdiffscap) Visualize differential taxonomy clade.

(ref:CRCdiffcap) **Visualize differential taxonomy clade.** 

```{r CRCdiffclade, fig.width=7, fig.height=7, message=FALSE, fig.cap="(ref:CRCdiffcap)", fig.scap="(ref:CRCdiffscap)", out.extra='', warning=FALSE, message=FALSE, results='hide'}
library(MicrobiotaProcess)
library(ggplot2)
library(TDbook)

# load `df_difftax` and `df_difftax_info` from TDbook
taxa <- df_alltax_info
dt <- df_difftax

ggdiffclade(obj=taxa,
            nodedf=dt,
            factorName="DIAGNOSIS",
            layout="radial",
            skpointsize=0.6,
            cladetext=2,
            linewd=0.2,
            taxlevel=3,
            # This argument is to remove the branch of unknown taxonomy.
            reduce=TRUE) + 
     scale_fill_manual(values=c("#00AED7", "#009E73"))+
     guides(color = guide_legend(keywidth = 0.1, keyheight = 0.6,
                                 order = 3,ncol=1)) +
     theme(panel.background=element_rect(fill=NA),
           legend.position="right",
           plot.margin=margin(0,0,0,0),
           legend.spacing.y=unit(0.02, "cm"), 
           legend.title=element_text(size=7.5), 
           legend.text=element_text(size=5.5), 
           legend.box.spacing=unit(0.02,"cm")
        )
```

The data frame of this example is from the analysis result of `diff_analysis()` using public datasets [@kostic2012genomic]. The `colors` represent the features enriched in the relevant class groups. The size of circle points represents the `-log10(pvalue)`, *i.e.*, a larger point indicates a greater significance. In Figure \@ref(fig:CRCdiffclade), we can find that *Fusobacterium* sequences were enriched in carcinomas, while Firmicutes, Bacteroides, and Clostridiales were greatly reduced in tumors. These results were consistent with the original article [@kostic2012genomic]. The species of *Campylobacter* has been proven to be associated with colorectal cancer [@He289; @wu2013dysbiosis; @amer2017microbiome]. We can find in Figure \@ref(fig:CRCdiffclade) that *Campylobacter* was enriched in tumors, while its relative abundance is lower than *Fusobacterium*.  


## Visualizing Phylogenetic Network Using Tanggle

The `r Biocpkg("tanggle")` package provides functions to display a split network. It extends the `r Biocpkg("ggtree")` package [@yu_ggtree:_2017] to allow the visualization of phylogenetic networks (Figure \@ref(fig:phylonetworx)). 


(ref:phylonetworxscap) Phylogenetic network.

(ref:phylonetworxcap) **Phylogenetic network**.

```{r phylonetworx, fig.width=7, fig.height=7, message=FALSE, fig.cap="(ref:phylonetworxcap)", fig.scap="(ref:phylonetworxscap)", out.extra='', warning=FALSE}
library(ggplot2)
library(ggtree)
library(tanggle)

file <- system.file("extdata/trees/woodmouse.nxs", package = "phangorn")
Nnet <- phangorn::read.nexus.networx(file)

ggsplitnet(Nnet) +
    geom_tiplab2(aes(color=label), hjust=-.1)+
    geom_nodepoint(color='firebrick', alpha=.4) +
    scale_color_manual(values=rainbow(15)) +   
    theme(legend.position="none") +
    ggexpand(.1) + ggexpand(.1, direction=-1)
```                 


## Summary {#summary11}


The `r Biocpkg("ggtree")` is designed to support the grammar of graphics, allowing users to quickly explore phylogenetic data through visualization. When users have special needs and `r Biocpkg("ggtree")` does not provide them, it is highly recommended to develop extension packages to implement these missing functions. This is a good mechanism, and we also hope that `r Biocpkg("ggtree")` users can become a `r Biocpkg("ggtree")` community. In this way, more functions for special needs can be developed and shared among users. Everyone will benefit from it, and it's exciting that this is happening.


<!--chapter:end:11_ggtree_exts-others.Rmd-->

# (PART\*) Part IV: Miscellaneous topics {-}

\newpage

# ggtree Utilities {#chapter12}

## Facet Utilities {#facet-utils}

### facet_widths {#facet_widths}

Adjusting relative widths of facet panels is a common requirement, especially for using `geom_facet()`\index{geom\textunderscore facet} to visualize a tree with associated data. However, this is not supported by the `r CRANpkg("ggplot2")` package. To address this issue, `r Biocpkg("ggtree")` provides the `facet_widths()` function and it works with both `ggtree` and `ggplot` objects.   

```{r eval=F}
library(ggplot2)
library(ggtree)
library(reshape2)

set.seed(123)
tree <- rtree(30)

p <- ggtree(tree, branch.length = "none") + 
    geom_tiplab() + theme(legend.position='none')

a <- runif(30, 0,1)
b <- 1 - a
df <- data.frame(tree$tip.label, a, b)
df <- melt(df, id = "tree.tip.label")

p2 <- p + geom_facet(panel = 'bar', data = df, geom = geom_bar, 
                 mapping = aes(x = value, fill = as.factor(variable)), 
                 orientation = 'y', width = 0.8, stat='identity') + 
        xlim_tree(9)

facet_widths(p2, widths = c(1, 2))
```

It also supports using a name vector to set the widths of specific panels. The following code will display an identical figure to Figure \@ref(fig:facetWidth)A.

```r
facet_widths(p2, c(Tree = .5))
```


The `facet_widths()` function also works with other `ggplot` objects as demonstrated in Figure \@ref(fig:facetWidth)B.


```{r eval=FALSE}
p <- ggplot(iris, aes(Sepal.Width, Petal.Length)) + 
  geom_point() + facet_grid(.~Species)
facet_widths(p, c(setosa = .5))
```

(ref:facetWidthscap) Adjust relative widths of ggplot facets.

(ref:facetWidthcap) **Adjust relative widths of ggplot facets.** The `facet_widths()` function works with `ggtree` (A) as well as `ggplot` (B).

```{r facetWidth, echo=F, fig.width=6, fig.height=7, fig.scap="(ref:facetWidthscap)", fig.cap="(ref:facetWidthcap)"}
library(ggplot2)
library(ggtree)
library(reshape2)

set.seed(123)
tree <- rtree(30)

p <- ggtree(tree, branch.length = "none") + 
    geom_tiplab(size=3) + theme(legend.position='none')

a <- runif(30, 0,1)
b <- 1 - a
df <- data.frame(tree$tip.label, a, b)
df <- melt(df, id = "tree.tip.label")

p2 <- p + geom_facet(panel = 'bar', data = df, geom = geom_bar, 
                 mapping = aes(x = value, fill = as.factor(variable)), 
                 orientation = 'y', width = 0.8, stat='identity') + 
        xlim_tree(9)

pp = facet_widths(p2, widths = c(1, 2))

g <- ggplot(iris, aes(Sepal.Width, Petal.Length)) + 
  geom_point() + facet_grid(.~Species)
gg = facet_widths(g, c(setosa = .5))

#plot_grid(plot_grid(ggdraw(), pp, rel_widths=c(.04, 1)), 
#        gg, ncol=1, labels = LETTERS[1:2], rel_heights=c(1.5, 1))

plot_list(pp, gg, ncol=1, tag_levels='A', heights=c(1.5, 1))
```


### facet_labeller {#facet_labeller}

The `facet_labeller()` function was designed to relabel selected panels (Figure \@ref(fig:facetLab)), and it currently only works with `ggtree` objects (*i.e.*, `geom_facet()` outputs). A more versatile version that works with both `ggtree` and `ggplot` objects is implemented in the `r CRANpkg("ggfun")` package (*i.e.*, the `facet_set()` function).

```{r eval=F}
facet_labeller(p2, c(Tree = "phylogeny", bar = "HELLO"))
```

If you want to combine `facet_widths()` with `facet_labeller()`, you need to call `facet_labeller()` to relabel the panels before using `facet_widths()` to set the relative widths of each panel. Otherwise, it won't work since the output of `facet_widths()` is redrawn from `grid` object.

```{r eval=F}
facet_labeller(p2, c(Tree = "phylogeny")) %>% facet_widths(c(Tree = .4))
```

(ref:facetLabscap) Rename facet labels.

(ref:facetLabcap) **Rename facet labels.** Rename multiple labels simultaneously (A) or only for a specific one (B) are all supported. `facet_labeller()` can combine with `facet_widths()` to rename facet label and then adjust relative widths (B).


```{r facetLab, echo=FALSE,fig.width=6, fig.height=7, fig.scap="(ref:facetLabscap)", fig.cap="(ref:facetLabcap)"}
pg1 <- facet_labeller(p2, c(Tree = "phylogeny", bar = "HELLO")) 
pg2 <- facet_labeller(p2, c(Tree = "phylogeny")) %>% facet_widths(c(Tree = .4))
#plot_grid(plot_grid(ggdraw(), pg1, rel_widths=c(.04, 1)), 
#        plot_grid(ggdraw(), pg2, rel_widths=c(.04, 1)), 
#        ncol=1, labels = c("A", "B"))
 
plot_list(pg1, pg2, ncol=1, tag_levels='A')
```

## Geometric Layers {#geom2}


Subsetting is not supported in layers defined in `r CRANpkg("ggplot2")`, while it is quite useful in phylogenetic annotation since it allows us to annotate at specific node(s) (e.g., only label bootstrap values that are larger than 75)\index{grammar of graphics}.

In `r Biocpkg("ggtree")`, we provide several modified versions of layers defined in `r CRANpkg("ggplot2")` to support the `subset` aesthetic mapping, including:

+ `geom_segment2()`
+ `geom_point2()`
+ `geom_text2()`
+ `geom_label2()`


These layers works with both `r Biocpkg("ggtree")` and `r CRANpkg("ggplot2")` (Figure \@ref(fig:layer2)).


(ref:layer2scap) Geometric layers that support subsetting.

(ref:layer2cap) **Geometric layers that support subsetting.** These layers work with `ggplot2` (A) and `ggtree` (B).


```{r layer2, fig.width=11, fig.height=5, fig.cap="(ref:layer2cap)", fig.scap="(ref:layer2scap)", out.width="100%"}
library(ggplot2)
library(ggtree)
data(mpg)
p <- ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) +
   geom_point(mapping = aes(color = class)) + 
   geom_text2(aes(label=manufacturer, 
                  subset = hwy > 40 | displ > 6.5), 
                  nudge_y = 1) +
   coord_cartesian(clip = "off") +
   theme_light() +
   theme(legend.position = c(.85, .75))          

p2 <- ggtree(rtree(10)) + 
    geom_label2(aes(subset = node <5, label = label))

plot_list(p, p2, ncol=2, tag_levels='A')
```

## Layout Utilities

In [session 4.2](#tree-layouts), we introduce several layouts supported by `r Biocpkg("ggtree")`. The `r Biocpkg("ggtree")` package also provides several layout functions that can transform from one to another. Note that not all layouts are supported (see Table \@ref(tab:layoutLayerTab) and Figure \@ref(fig:layoutLayer))\index{tree layout}.

```{r layoutLayerTab, echo=FALSE}
layout.df = tibble::tribble(~Layout, ~Description,
    "layout_circular",      "transform rectangular layout to circular layout",
    "layout_dendrogram",    "transform rectangular layout to dendrogram layout",
    "layout_fan",           "transform rectangular/circular layout to fan layout",
    "layout_rectangular",   "transform circular/fan layout to rectangular layout",
    "layout_inward_circular",    "transform rectangular/circular layout to inward_circular layout"
    )

knitr::kable(layout.df, caption = "Layout transformers.", booktabs = T)
```


```{r eval=FALSE}
set.seed(2019)
x <- rtree(20)
p <- ggtree(x)
p + layout_dendrogram()
ggtree(x, layout = "circular") + layout_rectangular()
p + layout_circular()
p + layout_fan(angle=90)
p + layout_inward_circular(xlim=4) + geom_tiplab(hjust=1)
```


(ref:layoutLayerscap) Layout functions for transforming among different layouts.

(ref:layoutLayercap) **Layout functions for transforming among different layouts**. Default rectangular layout (A); transform rectangular to dendrogram layout (B); transform circular to rectangular layout (C); transform rectangular to circular layout (D); transform rectangular to fan layout (E); transform rectangular to inward circular layout (F).


```{r layoutLayer, echo=FALSE, fig.width=10.8, fig.height=7.5, message=FALSE, fig.cap="(ref:layoutLayercap)", fig.scap="(ref:layoutLayerscap)", out.width='100%'}
set.seed(2019)
x <- rtree(20)
p <- ggtree(x)

if (FALSE) {
pp1 <- cowplot::plot_grid(
    p,
    p + layout_dendrogram(),
    p + layout_circular() + layout_rectangular(),
    ncol=3, labels = LETTERS[1:3])

require(ggplotify)

pp2 <- cowplot::plot_grid(
    as.ggplot(p + layout_circular(), scale=1.2, hjust=-.1), 
    as.ggplot(p + layout_fan(angle=90), scale=1.2),
    as.ggplot(p + layout_inward_circular(xlim=4) + geom_tiplab(hjust=1), scale=1.2, hjust=.1),
    ncol=3, labels = LETTERS[4:6])

cowplot::plot_grid(pp1, pp2, ncol=1, rel_heights=c(2, 3))
}

plot_list(p, 
    p + layout_dendrogram(), 
    p + layout_circular() + layout_rectangular(), 
    as.ggplot(p + layout_circular(), scale=1.2, hjust=-.1), 
    as.ggplot(p + layout_fan(angle=90), scale=1.2),
    as.ggplot(p + layout_inward_circular(xlim=4) + geom_tiplab(hjust=1), scale=1.2, hjust=.1),
    ncol=3, heights=c(2, 3), tag_levels='A')
```




## Scale Utilities


The `r Biocpkg("ggtree")` package provides several scale functions to manipulate the *x*-axis, including the `scale_x_range()` documented in [session 5.2.4](#uncertainty-of-evolutionary-inference), `xlim_tree()`, `xlim_expand()`, `ggexpand()`, `hexpand()` and `vexpand()`.


### Expand x limit for a specific facet panel {#xlim_expand}

Sometimes we need to set `xlim` for a specific facet panel (*e.g.*, allocate more space for [long tip labels](#faq-label-truncated) at `Tree` panel). However, the `ggplot2::xlim()` function applies to all the panels. The `r Biocpkg("ggtree")` provides `xlim_expand()` to adjust `xlim` for user-specific facet panel. It accepts two parameters, `xlim`, and `panel`, and can adjust all individual panels as demonstrated in Figure \@ref(fig:xlimExpand)A. If you only want to adjust `xlim` of the `Tree` panel, you can use `xlim_tree()` as a shortcut.


```{r eval=FALSE}
set.seed(2019-05-02)
x <- rtree(30)
p <- ggtree(x) + geom_tiplab()
d <- data.frame(label = x$tip.label, 
                value = rnorm(30))
p2 <- p + geom_facet(panel = "Dot", data = d, 
            geom = geom_point, mapping = aes(x = value))
p2 + xlim_tree(6) + xlim_expand(c(-10, 10), 'Dot')
```



The `xlim_expand()` function also works with `ggplot2::facet_grid()`. As demonstrated in Figure \@ref(fig:xlimExpand)B, only the `xlim` of *virginica* panel was adjusted by `xlim_expand()`.


```{r eval=FALSE}
g <- ggplot(iris, aes(Sepal.Length, Sepal.Width)) + 
    geom_point() + facet_grid(. ~ Species, scales = "free_x") 
g + xlim_expand(c(0, 15), 'virginica')
```    

(ref:xlimExpandscap) Setting xlim for user-specific facet panels.

(ref:xlimExpandcap) **Setting xlim for user-specific facet panels.** Using `xlim_tree()` to set the Tree panel of the `ggtree` output (A) and `xlim_expand()` to set the Dot panel of the `ggtree` output (A) and the Virginica panel of the `ggplot` output (B).


```{r xlimExpand, echo=FALSE, fig.cap="(ref:xlimExpandcap)", fig.scap="(ref:xlimExpandscap)", fig.width=12, fig.height = 5, out.width='100%'}
set.seed(2019-05-02)
x <- rtree(30)
p <- ggtree(x) + geom_tiplab()
d <- data.frame(label = x$tip.label, 
                value = rnorm(30))
p2 <- p + geom_facet(panel = "Dot", data = d, 
            geom = geom_point, mapping = aes(x = value))
p2 <- p2 + xlim_expand(c(0, 6), 'Tree') + xlim_expand(c(-10, 10), 'Dot')            
g <- ggplot(iris, aes(Sepal.Length, Sepal.Width)) + 
    geom_point() + facet_grid(. ~ Species, scales = "free_x") 

#plot_grid(plot_grid(ggdraw(), p2, rel_widths=c(.04, 1)),
#    g + theme_grey() + xlim_expand(c(0, 15), 'virginica'),
#    ncol=2, labels=c("A", "B"))
plot_list(p2, g + theme_grey() + xlim_expand(c(0, 15), 'virginica'),
    ncol=2, tag_levels = 'A')
```

### Expand plot limit by the ratio of plot range {#ggexpand}

The `r CRANpkg("ggplot2")` package cannot automatically adjust plot limits and it is very common that long text was truncated. Users need to adjust x (y) limits manually via the `xlim()` (`ylim()`) command (see also [FAQ: Tip label truncated](#faq-label-truncated)). 

The `xlim()` (`ylim()`) is a good solution to this issue. However, we can make it more simple, by expanding the plot panel by a ratio of the axis range without knowing what the exact value is. 

We provide `hexpand()` function to expand x limit by specifying a fraction of the x range and it works for both directions (`direction=1` for right-hand side and `direction=-1` for left-hand side) (Figure \@ref(fig:hexpand)). Another version of `vexpand()` works with similar behavior for *y*-axis and the `ggexpand()` function works for both *x*- and *y*-axis (Figure \@ref(fig:phylonetworx)). 

(ref:hexpandscap) Expanding plot limits by a fraction of x or y range.

(ref:hexpandcap) **Expanding plot limits by a fraction of the x or y range.** Expand x limit at right-hand side by default (A), and expand x limit for left-hand side when direction = -1 and expand y limit at the upper side (B). 


```{r hexpand,fig.cap="(ref:hexpandcap)", fig.scap="(ref:hexpandscap)", fig.width=12, fig.height = 5, out.width='100%'}
x$tip.label <- paste0('to make the label longer_', x$tip.label)
p1 <- ggtree(x) + geom_tiplab() + hexpand(.4)
p2 <- ggplot(iris, aes(Sepal.Width, Petal.Width)) + 
    geom_point() + 
    hexpand(.2, direction = -1) +
    vexpand(.2)

plot_list(p1, p2, tag_levels="A", widths=c(.6, .4))
```

## Tree data utilities

### Filter tree data {#td_filter}

The `r Biocpkg("ggtree")` package defined [several geom layers](#geom2) that support subsetting tree data. However, many other geom layers that didn't provide this feature, are defined in `r CRANpkg("ggplot2")` and its extensions. To allow filtering tree data with these layers, `r Biocpkg("ggtree")` provides an accompanying function, `td_filter()` that returns a function that works similar to `dplyr::filter()` and can be passed to the `data` parameter in geom layers to filter `ggtree` plot data as demonstrated in Figure \@ref(fig:tdFilter).

(ref:tdfilterscap) Filtering ggtree plot data in geom layers.

(ref:tdfiltercap) **Filtering ggtree plot data in geom layers.** Only selected tips (offspring of the node indicated by the blue circle point) were labeled.

```{r tdFilter,fig.cap="(ref:tdfiltercap)", fig.scap="(ref:tdfilterscap)", fig.width=7, fig.height = 5}
library(tidytree)

set.seed(1997)
tree <- rtree(50)
p <- ggtree(tree) 
selected_nodes <- offspring(p, 67)$node
p + geom_text(aes(label=label), 
            data=td_filter(isTip & 
                        node %in% selected_nodes), 
            hjust=0) +
    geom_nodepoint(aes(subset = node ==67), 
                    size=5, color='blue')
```

### Flatten list-column tree data {#td_unnest}

The `ggtree` plot data is a tidy data frame where each row represents a unique node. If multiple values are associated with a node, the data can be stored as nested data (i.e., in a list-column).

```{r}
set.seed(1997)
tr <- rtree(5)
d <- data.frame(id=rep(tr$tip.label,2), 
                value=abs(rnorm(10, 6, 2)), 
                group=c(rep("A", 5),rep("B",5)))

require(tidyr)
d2  <- nest(d, value =value, group=group)
## d2 is a nested data
d2
```

Nested data is supported by the operator, `%<+%`, and can be mapped to the tree structure. If a geom layer can't directly support visualizing nested data, we need to flatten the data before applying the geom layer to display it. The `r Biocpkg("ggtree")` package provides a function, `td_unnest()`, which returns a function that works similar to `tidyr::unnest()` and can be used to flatten `ggtree` plot data as demonstrated in Figure \@ref(fig:tdUnnest)A.

All tree data utilities provide a `.f` parameter to pass a function to pre-operate the data. This creates the possibility to combine different tree data utilities as demonstrated in Figure \@ref(fig:tdUnnest)B. 

(ref:tdunnestscap) Flattening ggtree plot data.

(ref:tdunnestcap) **Flattening ggtree plot data.** List-columns can be flattened by `td_unnest()` and two circle points were displayed on each tip simultaneously (A). Different tree data utilities can be combined to work together, e.g., filter data by `td_filter()`, and then flatten it by `td_unnest()`) (B). 

```{r tdUnnest,fig.cap="(ref:tdunnestcap)", fig.scap="(ref:tdunnestscap)", fig.width=8, fig.height = 5, out.width='100%'}
p <- ggtree(tr) %<+% d2
p2 <- p + 
    geom_point(aes(x, y, size= value, colour=group), 
            data = td_unnest(c(value, group)), alpha=.4) +
    scale_size(range=c(3,10), limits=c(3, 10))

p3 <- p + 
    geom_point(aes(x, y, size= value, colour=group), 
            data = td_unnest(c(value, group), 
                        .f = td_filter(isTip & node==4)), 
            alpha=.4) +
    scale_size(range=c(3,10), limits=c(3, 10))

plot_list(p2, p3, tag_levels = 'A')
```


## Tree Utilities

### Extract tip order {#tiporder}

To create [composite plots](#composite_plot), users need to re-order their data manually before creating tree-associated graphs. The order of their data should be consistent with the tip order presented in the `ggtree()` plot. For this purpose, we provide the `get_taxa_name()` function to extract an ordered vector of tips based on the tree structure plotted by `ggtree()`. 

(ref:tiporderscap) An example tree for demonstraing `get_taxa_name()` function.

(ref:tipordercap) **An example tree for demonstrating `get_taxa_name()` function.**


```{r tiporder,fig.cap="(ref:tipordercap)", fig.scap="(ref:tiporderscap)", fig.width=5, fig.height = 5}
set.seed(123)
tree <- rtree(10)
p <- ggtree(tree) + geom_tiplab() + 
    geom_hilight(node = 12, extendto = 2.5)

x <- paste("Taxa order:", 
        paste0(get_taxa_name(p), collapse=', '))
p + labs(title=x)
```

The `get_taxa_name()` function will return a vector of ordered tip labels according to the tree structure displayed in Figure \@ref(fig:tiporder).

```{r}
get_taxa_name(p)
```

If users specify a node, the `get_taxa_name()` will extract the tip order of the selected clade (i.e., highlighted region in Figure \@ref(fig:tiporder)).


```{r}
get_taxa_name(p, node = 12)
```

### Padding taxa labels

The `label_pad()` function adds padding characters (default is ``) to taxa labels. 

```{r}
set.seed(2015-12-21)
tree <- rtree(5)
tree$tip.label[2] <- "long string for test"

d <- data.frame(label = tree$tip.label, 
                newlabel = label_pad(tree$tip.label),
                newlabel2 = label_pad(tree$tip.label, pad = " "))
print(d)
```


This feature is useful if we want to align tip labels to the end as demonstrated in Figure \@ref(fig:labelpad). Note that in this case, monospace font should be used to ensure the lengths of the labels displayed in the plot are the same.

(ref:labelpadscap) Align tip label to the end.

(ref:labelpadcap) **Align tip label to the end.** With a dotted line (A) and without a dotted line (B). 


```{r labelpad, fig.width=6.9, fig.height=3.4, fig.cap="(ref:labelpadcap)", fig.scap="(ref:labelpadscap)", out.width='100%'}
p <- ggtree(tree) %<+% d + xlim(NA, 5)
p1 <- p + geom_tiplab(aes(label=newlabel), 
                    align=TRUE, family='mono',
                    linetype = "dotted", linesize = .7) 
p2 <- p + geom_tiplab(aes(label=newlabel2), 
                    align=TRUE, family='mono',
                    linetype = NULL, offset=-.5) + xlim(NA, 5)
plot_list(p1, p2, ncol=2, tag_levels = "A")                            
```


## Interactive ggtree Annotation {#identify}


```{r echo=FALSE}
link = ifelse (knitr::is_latex_output(), "https://twitter.com/drandersgs/status/965996335882059776", "#plotly")

plotly_ggtree_link <- paste0("an [interactive phylogenetic tree](", link, ")")
```


The `r Biocpkg("ggtree")` package supports interactive tree annotation or manipulation by implementing an `identify()` method. Users can click on a node to highlight a clade, to label or rotate it, *etc*. Users can also use the `r CRANpkg("plotly")` package to convert a `ggtree` object to a `plotly` object to quickly create 
```{r results='asis', echo=FALSE}
cat(plotly_ggtree_link, '.', sep='')
```




```{r, eval = !knitr::is_latex_output(), child="ggtree-identity.Rmd"}
```


Video of using `identify()` to interactively manipulate a phylogenetic tree can be found on Youtube `r icons::icon_style(icons::fontawesome("youtube"), fill='red')` and Youku:

+ Highlighting clades: [Youtube `r icons::icon_style(icons::fontawesome("youtube"), fill='red')`](https://youtu.be/KcF8Ec38mzI) and [Youku](http://v.youku.com/v_show/id_XMTYyMzgyODYyOA).
+ Labelling  clades: [Youtube `r icons::icon_style(icons::fontawesome("youtube"), fill='red')`](https://youtu.be/SmcceRD_jxg) and [Youku](http://v.youku.com/v_show/id_XMTYyNDIzODA0NA). 
+ Rotating clades: [Youtube `r icons::icon_style(icons::fontawesome("youtube"), fill='red')`](https://youtu.be/lKNn4QlPO0E) and [Youku](http://v.youku.com/v_show/id_XMTYyMzgyODg2OA). 



<!--chapter:end:12_ggtree_utilities.Rmd-->

\newpage

# Gallery of Reproducible Examples {#chapter13}




## Visualizing pairwise nucleotide sequence distance with a phylogenetic tree {#hpv58}


This example reproduces figure 1 of [@chen_ancient_2017]. It extracts accession numbers from tip labels of the HPV58 tree and calculates pairwise nucleotide sequence distances. The distance matrix is visualized as dot and line plots. This example demonstrates the ability to add multiple layers to a specific panel. As illustrated in Figure \@ref(fig:jv2017), the `geom_facet()` function displays sequence distances as a dot plot and then adds a layer of line plot to the same panel, *i.e.*, sequence distance. In addition, the tree in `geom_facet()` can be fully annotated with multiple layers (clade labels, bootstrap support values, *etc.*). The source code is modified from the supplemental file of [@yu_two_2018].

```{r message=FALSE}
library(TDbook)
library(tibble)
library(tidyr)
library(Biostrings)
library(treeio)
library(ggplot2)
library(ggtree)

# loaded from TDbook package
tree <- tree_HPV58

clade <- c(A3 = 92, A1 = 94, A2 = 108, B1 = 156, 
            B2 = 159, C = 163, D1 = 173, D2 = 176)
tree <- groupClade(tree, clade)
cols <- c(A1 = "#EC762F", A2 = "#CA6629", A3 = "#894418", B1 = "#0923FA", 
         B2 = "#020D87", C = "#000000", D1 = "#9ACD32",D2 = "#08630A")

## visualize the tree with tip labels and tree scale
p <- ggtree(tree, aes(color = group), ladderize = FALSE) %>% 
    rotate(rootnode(tree)) + 
    geom_tiplab(aes(label = paste0("italic('", label, "')")), 
                parse = TRUE, size = 2.5) +
    geom_treescale(x = 0, y = 1, width = 0.002) + 
    scale_color_manual(values = c(cols, "black"), 
                na.value = "black", name = "Lineage",
                breaks = c("A1", "A2", "A3", "B1", "B2", "C", "D1", "D2")) +
    guides(color = guide_legend(override.aes = list(size = 5, shape = 15))) +
    theme_tree2(legend.position = c(.1, .88))
## Optional
## add labels for monophyletic (A, C and D) and paraphyletic (B) groups 
dat <- tibble(node = c(94, 108, 131, 92, 156, 159, 163, 173, 176,172),
              name = c("A1", "A2", "A3", "A", "B1", 
                        "B2", "C", "D1", "D2", "D"),
              offset = c(0.003, 0.003, 0.003, 0.00315, 0.003, 
                        0.003, 0.0031, 0.003, 0.003, 0.00315),
              offset.text = c(-.001, -.001, -.001, 0.0002, -.001, 
                        -.001, 0.0002, -.001, -.001, 0.0002),
              barsize = c(1.2, 1.2, 1.2, 2, 1.2, 1.2, 3.2, 1.2, 1.2, 2),
              extend = list(c(0, 0.5), 0.5, c(0.5, 0), 0, c(0, 0.5), 
                        c(0.5, 0), 0, c(0, 0.5), c(0.5, 0), 0)
            ) %>% 
       dplyr::group_split(barsize)

p <- p +
     geom_cladelab(
         data = dat[[1]],
         mapping = aes(
             node = node,
             label = name,
             color = group,
             offset = offset,
             offset.text = offset.text,
             extend = extend
         ),
         barsize = 1.2,
         fontface = 3,
         align = TRUE
     ) +
     geom_cladelab(
         data = dat[[2]],
         mapping = aes(
             node = node,
             label = name,
             offset = offset,
             offset.text =offset.text,
             extend = extend
         ),
         barcolor = "darkgrey",
         textcolor = "darkgrey",
         barsize = 2,
         fontsize = 5,
         fontface = 3,
         align = TRUE
     ) +
     geom_cladelab(
         data = dat[[3]],
         mapping = aes(
             node = node,
             label = name,
             offset = offset,
             offset.text = offset.text,
             extend = extend
         ),
         barcolor = "darkgrey",
         textcolor = "darkgrey",
         barsize = 3.2,
         fontsize = 5,
         fontface = 3,
         align = TRUE
     ) +
     geom_strip(65, 71, "italic(B)", color = "darkgrey", 
                offset = 0.00315, align = TRUE, offset.text = 0.0002, 
                barsize = 2, fontsize = 5, parse = TRUE)

## Optional
## display support values
p <- p + geom_nodelab(aes(subset = (node == 92), label = "*"), 
                    color = "black", nudge_x = -.001, nudge_y = 1) +
    geom_nodelab(aes(subset = (node == 155), label = "*"), 
                    color = "black", nudge_x = -.0003, nudge_y = -1) +
    geom_nodelab(aes(subset = (node == 158), label = "95/92/1.00"), 
                    color = "black", nudge_x = -0.0001, 
                    nudge_y = -1, hjust = 1) +
    geom_nodelab(aes(subset = (node == 162), label = "98/97/1.00"), 
                    color = "black", nudge_x = -0.0001, 
                    nudge_y = -1, hjust = 1) +
    geom_nodelab(aes(subset = (node == 172), label = "*"), 
                    color = "black", nudge_x = -.0003, nudge_y = -1) 
```

```{r eval=F}
## extract accession numbers from tip labels
tl <- tree$tip.label
acc <- sub("\\w+\\|", "", tl)
names(tl) <- acc

## read sequences from GenBank directly into R
## and convert the object to DNAStringSet
tipseq <- ape::read.GenBank(acc) %>% as.character %>% 
    lapply(., paste0, collapse = "") %>% unlist %>% 
    DNAStringSet
## align the sequences using muscle
tipseq_aln <- muscle::muscle(tipseq)
tipseq_aln <- DNAStringSet(tipseq_aln)
```

```{r echo=F}
## extract accession numbers from tip labels
tl <- tree$tip.label
acc <- sub("\\w+\\|", "", tl)
names(tl) <- acc

## writeXStringSet(tipseq_aln, file = "data/HPV58_aln.fas")
#tipseq_aln <- readDNAStringSet("data/HPV58_aln.fas")
tipseq_aln <- TDbook::dna_HPV58_aln %>% 
              as.character %>%
              lapply(., paste0, collapse = "") %>%
              unlist() %>%
              Biostrings::DNAStringSet()
```


(ref:jv2017scap) Phylogeny of HPV58 complete genomes with dot and line plots of pairwise nucleotide sequence distances.

(ref:jv2017cap) **Phylogeny of HPV58 complete genomes with dot and line plots of pairwise nucleotide sequence distances**. 


```{r jv2017, fig.width=12, fig.height=12, fig.cap="(ref:jv2017cap)", fig.scap="(ref:jv2017scap)", warning=FALSE, out.width='100%'}
## calculate pairwise hamming distances among sequences
tipseq_dist <- stringDist(tipseq_aln, method = "hamming")

## calculate the percentage of differences
tipseq_d <- as.matrix(tipseq_dist) / width(tipseq_aln[1]) * 100

## convert the matrix to a tidy data frame for facet_plot
dd <- as_tibble(tipseq_d)
dd$seq1 <- rownames(tipseq_d)
td <- gather(dd,seq2, dist, -seq1)
td$seq1 <- tl[td$seq1]
td$seq2 <- tl[td$seq2]

g <- p$data$group
names(g) <- p$data$label
td$clade <- g[td$seq2] 

## visualize the sequence differences using dot plot and line plot
## and align the sequence difference plot to the tree using facet_plot
p2 <- p + geom_facet(panel = "Sequence Distance", 
            data = td, geom = geom_point, alpha = .6, 
            mapping = aes(x = dist, color = clade, shape = clade)) +
    geom_facet(panel = "Sequence Distance", 
            data = td, geom = geom_path, alpha = .6, 
            mapping=aes(x = dist, group = seq2, color = clade)) + 
    scale_shape_manual(values = 1:8, guide = FALSE) 

print(p2)
```

## Displaying Different Symbolic Points for Bootstrap Values. {#symbolic-bootstrap}

We can cut the bootstrap values into several intervals, *e.g.*, to indicate whether the clade is of high, moderate, or low support. Then we can use these intervals as categorical variables to set different colors or shapes of symbolic points to indicate the bootstrap values belong to which category (Figure \@ref(fig:bpinterval)).

(ref:bpintervalscap) Partitioning bootstrap values.

(ref:bpintervalcap) **Partitioning bootstrap values**. Bootstrap values were divided into three categories and this information was used to color circle points.

```{r include = FALSE}
## phytools also have a read.newick function
read.newick <- treeio::read.newick
```

```{r bpinterval, fig.width=7.5, fig.height=8.6, fig.cap="(ref:bpintervalcap)", fig.scap="(ref:bpintervalscap)", out.width='100%'}
library(treeio)
library(ggplot2)
library(ggtree)
library(TDbook)

tree <- read.newick(text=text_RMI_tree, node.label = "support")
root <- rootnode(tree)  
ggtree(tree, color="black", size=1.5, linetype=1,  right=TRUE) + 
    geom_tiplab(size=4.5, hjust = -0.060, fontface="bold") +  xlim(0, 0.09) + 
    geom_point2(aes(subset=!isTip & node != root, 
                    fill=cut(support, c(0, 700, 900, 1000))), 
                    shape=21, size=4) + 
    theme_tree(legend.position=c(0.2, 0.2)) + 
    scale_fill_manual(values=c("white", "grey", "black"), guide='legend', 
                    name='Bootstrap Percentage(BP)', 
                    breaks=c('(900,1e+03]', '(700,900]', '(0,700]'), 
                    labels=expression(BP>=90,70 <= BP * " < 90", BP < 70))
```


## Highlighting Different Groups {#phylo-grouping}


This example reproduces Figure 1 of [@larsen_identification_2019]. It used `groupOTU()` to add grouping information of chicken CTLDcps. The branch line type and color are defined based on this grouping information. Two groups of CTLDcps are highlighted in different background colors using `geom_hilight` (red for Group II and green for Group V). The avian-specific expansion of Group V with the subgroups of A and B- are labeled using `geom_cladelab` (Figure \@ref(fig:treeLarsen)).



(ref:treeLarsenscap) Phylogenetic tree of CTLDcps.

(ref:treeLarsencap) **Phylogenetic tree of CTLDcps**. Using different background colors, line types and colors, and clade labels to distinguish groups.




```{r treeLarsen, fig.cap="(ref:treeLarsencap)", fig.scap="(ref:treeLarsenscap)", fig.width=7.5, fig.height=6.3, out.width='100%'}
library(TDbook)
mytree <- tree_treenwk_30.4.19

# Define nodes for coloring later on
tiplab <- mytree$tip.label
cls <- tiplab[grep("^ch", tiplab)] 
labeltree <- groupOTU(mytree, cls)

p <- ggtree(labeltree, aes(color=group, linetype=group), layout="circular") +
    scale_color_manual(values = c("#efad29", "#63bbd4")) +
    geom_nodepoint(color="black", size=0.1) +
    geom_tiplab(size=2, color="black")

p2 <- flip(p, 136, 110) %>% 
    flip(141, 145) %>% 
    rotate(141) %>% 
    rotate(142) %>% 
    rotate(160) %>% 
    rotate(164) %>% 
    rotate(131)

### Group V and II coloring 
dat <- data.frame(
           node = c(110, 88, 156,136),
           fill = c("#229f8a", "#229f8a", "#229f8a", "#f9311f")
       )
p3 <- p2 +
      geom_hilight(
          data = dat,
          mapping = aes(
              node = node,
              fill = I(fill)
          ),
          alpha = 0.2,
          extendto = 1.4
      )

### Putting on a label on the avian specific expansion 
p4 <- p3 +
      geom_cladelab(
          node = 113,
          label = "Avian-specific expansion",
          align = TRUE,
          angle = -35,
          offset.text = 0.05,
          hjust = "center",
          fontsize = 2,
          offset = .2,
          barsize = .2
      )
    
### Adding the bootstrap values with subset used to remove all bootstraps < 50  
p5 <- p4 +
      geom_nodelab(
          mapping = aes(
              x = branch,
              label = label,
              subset = !is.na(as.numeric(label)) & as.numeric(label) > 50
          ),
          size = 2,
          color = "black",
          nudge_y = 0.6
      )

### Putting labels on the subgroups 
p6 <- p5 +
      geom_cladelab(
          data = data.frame(
              node = c(114, 121),
              name = c("Subgroup A", "Subgroup B")
          ),
          mapping = aes(
              node = node,
              label = name
          ),
          align = TRUE,
          offset = .05,
          offset.text = .03,
          hjust = "center",
          barsize = .2,
          fontsize = 2,
          angle = "auto",
          horizontal = FALSE
      ) +
      theme(
          legend.position = "none",
          plot.margin = grid::unit(c(-15, -15, -15, -15), "mm")
      )
print(p6)
```
  
## Phylogenetic Tree with Genome Locus Structure {#genome-locus}

The `geom_motif()` is defined in `r Biocpkg("ggtree")` and it is a wrapper layer of the `gggenes::geom_gene_arrow()`. The `geom_motif()` can automatically adjust genomic alignment by selective gene (via the `on` parameter) and can label genes via the `label` parameter. In the following example, we use `example_genes` dataset provided by `r CRANpkg("gggenes")`. As the dataset only provides genomic coordination of a set of genes, a phylogeny for the genomes needs to be constructed first. We calculate Jaccard similarity based on the ratio of overlapping genes among genomes and correspondingly determine genome distance. The BioNJ algorithm was applied to construct the tree. Then we can use `geom_facet()` to visualize the tree with the genomic structures (Figure \@ref(fig:gggenes)). 


(ref:gggenesscap) Genomic features with a phylogenetic tree.

(ref:gggenescap) **Genomic features with a phylogenetic tree.**


```{r gggenes, fig.width=9, fig.height=4, fig.cap="(ref:gggenescap)", fig.scap="(ref:gggenesscap)", out.width='100%'}
library(dplyr)
library(ggplot2)
library(gggenes)
library(ggtree)

get_genes <- function(data, genome) {
    filter(data, molecule == genome) %>% pull(gene)
}

g <- unique(example_genes[,1])
n <- length(g)
d <- matrix(nrow = n, ncol = n)
rownames(d) <- colnames(d) <- g
genes <- lapply(g, get_genes, data = example_genes)

for (i in 1:n) {
    for (j in 1:i) {
        jaccard_sim <- length(intersect(genes[[i]], genes[[j]])) / 
                       length(union(genes[[i]], genes[[j]]))
        d[j, i] <- d[i, j] <- 1 - jaccard_sim
    }
}

tree <- ape::bionj(d) 

p <- ggtree(tree, branch.length='none') + 
    geom_tiplab() + xlim_tree(5.5) + 
    geom_facet(mapping = aes(xmin = start, xmax = end, fill = gene),
               data = example_genes, geom = geom_motif, panel = 'Alignment',
               on = 'genE', label = 'gene', align = 'left') +
    scale_fill_brewer(palette = "Set3") + 
    scale_x_continuous(expand=c(0,0)) +
    theme(strip.text=element_blank(),
        panel.spacing=unit(0, 'cm'))

facet_widths(p, widths=c(1,2))
```

<!--chapter:end:13_ggtree_gallery.Rmd-->

\backmatter
# (APPENDIX) Appendix {-}

\newpage

# Frequently Asked Questions {#faq}

The [ggtree mailing-list](https://groups.google.com/forum/?#!forum/bioc-ggtree)^[<https://groups.google.com/forum/?#!forum/bioc-ggtree>] is a great place to get help, once you have created a reproducible example that illustrates your problem.

## Installation {#installation}

The `r Biocpkg("ggtree")` is released within the Bioconductor project; you need to use `r CRANpkg("BiocManager")` to install it.

```r
## you need to install BiocManager before using it
## install.packages("BiocManager")
library(BiocManager)
install("ggtree")
```

Bioconductor release is adhered to a specific R version. Please make sure you are using the latest version of R if you want to install the latest release of Bioconductor packages, including `r Biocpkg("ggtree")`. Beware that bugs will only be fixed in the current release and develop branches. If you find a bug, please follow the guide^[<https://guangchuangyu.github.io/2016/07/how-to-bug-author/>] to report it.


To make it easy to install and load multiple core packages in a single step, we created a meta-package, `r pkg_treedataverse`. Users can install the package via the following command:

```r
BiocManager::install("YuLab-SMU/treedataverse")
```

Once it is installed, loading the package will also load the core `r pkg_treedataverse` packages, including `r CRANpkg("tidytree")`, `r Biocpkg("treeio")`, `r Biocpkg("ggtree")`, and `r Biocpkg("ggtreeExtra")`.


## Basic R Related {#faq-r}

### Use your local file {#faq-local-file}

If you are new to `R` and want to use `r Biocpkg("ggtree")` for tree visualization, please do
learn some basic `R` and `r CRANpkg("ggplot2")`.

A very common issue is that users copy and paste commands without looking at
the function's behavior. The `system.file()` function was used in some of our examples to find files packed in the packages.



```
system.file                package:base                R Documentation

Find Names of R System Files

Description:

     Finds the full file names of files in packages etc.

Usage:

     system.file(..., package = "base", lib.loc = NULL,
                 mustWork = FALSE)
```

For users who want to use their files, please just use relative or absolute file path (*e.g.*, `file = "your/folder/filename"`).



## Aesthetic mapping {#faq-aes-mapping}

### Inherit aesthetic mapping {#faq-inherit-aes}

```r
ggtree(rtree(30)) + geom_point()
```

For example, we can add symbolic points to nodes with `geom_point()` directly.
The magic here is we don't need to map the `x` and `y` position of the points by providing `aes(x, y)` to `geom_point()` since it was already mapped by the `ggtree()` function and it serves as a global mapping for all layers.

But what if we provide a dataset in a layer and the dataset doesn't contain columns of `x` and/or `y`,
the layer function also tries to map `x` and `y` and also others if you map them in the `ggtree()` function.
As these variables are not available in your dataset, you will get the following error:

```
Error in eval(expr, envir, enclos) : object 'x' not found
```

This can be fixed by using the parameter `inherit.aes=FALSE` which will disable inheriting mapping from the `ggtree()` function.

### Never use `$` in aesthetic mapping {#faq-dollar-aes}

Never do this^[<https://groups.google.com/d/msg/bioc-ggtree/hViM6vRZF94/MsZT8qRgBwAJ>
and <https://github.com/GuangchuangYu/ggtree/issues/106>] and please refer to the explanation in the [ggplot2 book 2ed](https://github.com/hadley/ggplot2-book/blob/master/layers.Rmd#L185) [@wickham_ggplot2_2016]:

>Never refer to a variable with `$` (e.g., `diamonds$carat`) in `aes()`. This breaks containment so that the plot no longer contains everything it needs and causes problems if ggplot2 changes the order of the rows, as it does when facetting.


## Text and Label {#faq-text}

### Tip label truncated {#faq-label-truncated}


The reason for this issue is that `r CRANpkg("ggplot2")` can't auto-adjust `xlim` based on added text^[<https://twitter.com/hadleywickham/status/600280284869697538>].


```r
library(ggtree)
## example tree from https://support.bioconductor.org/p/72398/
tree <- read.tree(text= paste("(Organism1.006G249400.1:0.03977,", 
    "(Organism2.022118m:0.01337,(Organism3.J34265.1:0.00284,",
    "Organism4.G02633.1:0.00468)0.51:0.0104):0.02469);"))
p <- ggtree(tree) + geom_tiplab()  
```

In this example, the tip labels displayed in Figure \@ref(fig:truncatedTip)A are truncated. This is because the units are in two different spaces (data and pixel). Users can use `xlim` to allocate more spaces for tip labels (Figure \@ref(fig:truncatedTip)B).

```r
p + xlim(0, 0.08)
```

Another solution is to set `clip = "off"` to allow drawing outside of the plot panel. We may also need to set `plot.margin` to allocate more spaces for margin (Figure \@ref(fig:truncatedTip)C).

```r
p + coord_cartesian(clip = 'off') + 
  theme_tree2(plot.margin=margin(6, 120, 6, 6))
```

(ref:truncatedTipscap) Allocating more spaces for truncated tip labels.

(ref:truncatedTipcap) **Allocating more spaces for truncated tip labels.** Long tip labels may be truncated (A). One solution is to allocate more spaces for plot panel (B), and another solution is to allow plotting labels outside the plot panel (C).


```{r truncatedTip, fig.width=12, fig.height=4, echo=FALSE, fig.cap="(ref:truncatedTipcap)", fig.scap="(ref:truncatedTipscap)", out.width='100%'}
library(ggplot2)
library(ggtree)
## example tree from https://support.bioconductor.org/p/72398/
tree<-read.tree(text="(Organism1.006G249400.1:0.03977,(Organism2.022118m:0.01337,(Organism3.J34265.1:0.00284,Organism4.G02633.1:0.00468)0.51:0.0104):0.02469);")
p <- ggtree(tree) + geom_tiplab()
p2 <- ggtree(tree) + geom_tiplab() + xlim(0, 0.1)
p3 <- p + coord_cartesian(clip = 'off') + 
  theme_tree2(plot.margin=margin(6, 140, 6, 6))
plot_list(p, p2, p3, ncol=3, tag_levels="A")
```

The third solution is to use `hexpand()` as demonstrated in [session 12.4](#ggexpand). 


For rectangular/dendrogram layout trees, users can display tip labels as *y*-axis labels. In this case, no matter how long the labels are, they will not be truncated (see Figure \@ref(fig:tiplab)C).


### Modify (tip) labels {#faq-modify-label}


If you want to modify tip labels of the tree, you can use `treeio::rename_taxa()` to rename a `phylo` or `treedata` object.

```{r renameTaxa}
tree <- read.tree(text = "((A, B), (C, D));")
d <- data.frame(label = LETTERS[1:4], 
                label2 = c("sunflower", "tree", "snail", "mushroom"))

## rename_taxa use 1st column as key and 2nd column as value by default                
## rename_taxa(tree, d)
rename_taxa(tree, d, label, label2) %>% write.tree
```

If the input tree object is a `treedata` instance, you can use `write.beast()` to export the tree with associated data to a BEAST compatible NEXUS file (see [Chapter 3](#chapter3)).

Renaming phylogeny tip labels seems not to be a good idea, since it may introduce problems when mapping the original sequence alignment to the tree. Personally, I recommend storing the new labels as a tip annotation in `treedata` object. 

```{r warnings = F}
tree2 <- full_join(tree, d, by = "label")
tree2
```

If you just want to show different or additional information when plotting the tree, you don't need to modify tip labels. This could be easily done via the `%<+%` operator to attach the modified version of the labels and then use the `geom_tiplab()` layer to display
the modified version (Figure \@ref(fig:renameTip)).


(ref:renameTipscap) Alternative tip labels.

(ref:renameTipcap) **Alternative tip labels.** Original tip labels (A) and a modified version (B).


```{r renameTip, fig.width=8, fig.height=3, fig.cap="(ref:renameTipcap)", fig.scap="(ref:renameTipscap)", out.width='100%'}
p <- ggtree(tree) + xlim(NA, 3)
p1 <- p + geom_tiplab()

## the following command will produce an identical figure of p2
## ggtree(tree2) + geom_tiplab(aes(label = label2))
p2 <- p %<+% d + geom_tiplab(aes(label=label2))
plot_list(p1, p2, ncol=2, tag_levels = "A")
```

### Formatting (tip) labels {#faq-formatting-label}

If you want to format labels, you need to set `parse=TRUE` in the `geom_text()`/`geom_tiplab()`/`geom_nodelab()` and the `label` should be a string that can be parsed into expression and displayed as described in `?plotmath`. Users can use the `r CRANpkg("latex2exp")` package to convert LaTeX math formulas to R's plotmath expressions, or use the `r CRANpkg("ggtext")` package to render Markdown or HTML.

For example, the tip labels contain several parts (*e.g.*, genus, species, and geo), we can differentiate these pieces of information with different formats (Figure \@ref(fig:formatTip)A).

```{r formatTip-A, eval=F}
tree <- read.tree(text = "((a,(b,c)),d);")
genus <- c("Gorilla", "Pan", "Homo", "Pongo")
species <- c("gorilla", "spp.", "sapiens", "pygmaeus")
geo <- c("Africa", "Africa", "World", "Asia")
d <- data.frame(label = tree$tip.label, genus = genus,
                species = species, geo = geo)

library(glue)
d2 <- dplyr::mutate(d, 
  lab = glue("italic({genus})~bolditalic({species})~({geo})"),
  color = c("#E495A5", "#ABB065", "#39BEB1", "#ACA4E2"),
  name = glue("<i style='color:{color}'>{genus} **{species}**</i> ({geo})")
) 

p1 <- ggtree(tree) %<+% d2 + xlim(NA, 6) +
    geom_tiplab(aes(label=lab), parse=T)
```

Using Markdown or HTML to format text may be easier, and this is supported via the `r CRANpkg("ggtext")` package (Figure \@ref(fig:formatTip)B).


```{r formatTip-B, eval=F}
library(ggtext)

p2 <- ggtree(tree) %<+% d2 + 
  geom_richtext(data=td_filter(isTip), 
                aes(label=name), label.color=NA) + 
  hexpand(.3)

plot_list(p1, p2, ncol=2, tag_levels = 'A') 
```


(ref:formatTipscap) Formatting labels.

(ref:formatTipcap) **Formatting labels.** Formatting specific tip labels using `plotmath` expression (A), and Markdown/HTML (B).

```{r formatTip, fig.width=9.2, fig.height=4.2, echo = F, fig.cap="(ref:formatTipcap)", fig.scap="(ref:formatTipscap)", ref.label = c('formatTip-A', 'formatTip-B'), echo=FALSE, out.width='100%'}
```

### Avoid overlapping text labels {#faq-ggrepel}

Users can use the `r CRANpkg("ggrepel")` package to repel overlapping text labels (Figure \@ref(fig:repelTip)).


(ref:repelTipscap) Repel labels.

(ref:repelTipcap) **Repel labels.** Repel labels to avoid overlapping.


```{r repelTip, fig.width=12, fig.height=8, fig.cap="(ref:repelTipcap)", fig.scap="(ref:repelTipscap)", out.width='100%'}
library(ggrepel)
library(ggtree)
raxml_file <- system.file("extdata/RAxML", 
                    "RAxML_bipartitionsBranchLabels.H3", package="treeio")
raxml <- read.raxml(raxml_file)
ggtree(raxml) + geom_label_repel(aes(label=bootstrap, fill=bootstrap)) + 
  theme(legend.position = c(.1, .8)) + scale_fill_viridis_c()
```

### Bootstrap values from Newick format {#faq-bootstrap}

It is quite common to store *bootstrap* value as node label in the Newick format as in Figure \@ref(fig:nwkbs). Visualizing node label is easy using `geom_text2(aes(subset = !isTip, label=label))`.

If you want to only display a subset of *bootstrap* (*e.g.*, bootstrap > 80), you can't simply use `geom_text2(subset= (label > 80), label=label)` (or `geom_label2`) since `label` is a character vector, which contains node label (bootstrap value) and tip label (taxa name). `geom_text2(subset=(as.numeric(label) > 80), label=label)` won't work either, since `NAs` were introduced by coercion. We need to convert `NAs` to logical `FALSE`. This can be done by the following code:


(ref:nwkbsscap) Bootstrap value stored in node label.

(ref:nwkbscap) **Bootstrap value stored in node label.** 


```{r nwkbs, fig.width=12, fig.height=8, fig.cap="(ref:nwkbscap)", fig.scap="(ref:nwkbsscap)", out.width='100%'}
nwk <- system.file("extdata/RAxML","RAxML_bipartitions.H3", package='treeio')
tr <- read.tree(nwk)
ggtree(tr) + geom_label2(aes(label=label, 
      subset = !is.na(as.numeric(label)) & as.numeric(label) > 80))
```

As this is a very common issue, we implemented a `read.newick()` function in the `r Biocpkg("treeio")` package to allow parsing internal node labels as supported values. As a result, it can be easier to display bootstrap values using the following code:

```r
tr <- read.newick(nwk, node.label='support')
ggtree(tr) + geom_nodelab(geom='label', aes(label=support, subset=support > 80))
```


<!-- 

Another solution is converting the bootstrap value outside `ggtree`.


q <- ggtree(tr)
d <- q$data
d <- d[!d$isTip,]
d$label <- as.numeric(d$label)
d <- d[d$label > 80,]

q + geom_text(data=d, aes(label=label))

-->


## Branch Setting

### Plot the same tree as in `plot.phylo()`

By default, `ggtree()` ladderizes the input tree so that the tree will appear less cluttered. This is the reason why the tree visualized by `ggtree()` is different from the one using `plot.phylo()` which displays a non-ladderized tree. To disable the ladderize effect, users can pass the parameter `ladderize = FALSE` to the `ggtree()` function as demonstrated in Figure \@ref(fig:ggtreeladderize). 


```{r eval=FALSE}
library(ape)
library(ggtree)
set.seed(42)
x <- rtree(5)
plot(x)
ggtree(x, ladderize = FALSE) + geom_tiplab()
ggtree(x) + geom_tiplab()
```


(ref:ggtreeladderizescap) Ladderized and nonladderized tree.

(ref:ggtreeladderizecap) **Ladderized and non-ladderized tree.** `plot.phylo()` displays non-ladderized tree (A), use `ladderize = FALSE` to display non-ladderized tree in `ggtree()` (B), `ggtree()` displays ladderized tree by default (C).

```{r echo=F}
library(ape)
library(ggtree)
library(ggplotify)

set.seed(2020)
x <- rtree(5)

#p1 <- as.ggplot(~plot(x))
#p2 <- ggtree(x, ladderize = FALSE) + geom_tiplab()
#p3 <- ggtree(x) + geom_tiplab()

## don't know why throw error when combine them in bookdown
## it is OK in interactive R terminal

# plot_list(p1, p2, p3, ncol=3, tag_levels = 'A') 
```

```{r ggtreeladderize, fig.cap="(ref:ggtreeladderizecap)", fig.scap="(ref:ggtreeladderizescap)", fig.width=8, fig.height=4, echo=FALSE, out.width="100%"}
pg <- readRDS("cache-objs/ladderize-example.rds")
print(pg) 
```

### Specifying the order of the tips 


The `rotateConstr()` function provided in the `r CRANpkg("ape")` package rotates internal branches based on the specified order of the tips, and the order should be followed when plotting the tree (from bottom to top). As `ggtree()` by default ladderizes the input tree, users need to disable by passing `ladderize = FALSE`. Then the order of the tree will be displayed as expected (Figure \@ref(fig:rotateConstr)). Users can also extract tip order displayed by `ggtree()` using the `get_taxa_name()` function as demonstrated in [session 12.6](#tiporder).  

(ref:rotateConstrscap) Specifying tree order.

(ref:rotateConstrcap) **Specifying tree order.** The order of the input tree will be maintained in `ggtree()` when `ladderize = FALSE`. 

```{r rotateConstr, fig.cap="(ref:rotateConstrcap)", fig.scap="(ref:rotateConstrscap)", fig.width=6, fig.height=4, out.width="100%"}
y <- ape::rotateConstr(x, c('t4', 't2', 't5', 't1', 't3'))
ggtree(y, ladderize = FALSE) + geom_tiplab()
```

### Shrink outlier long branch

When outgroups are on a very long branch length (Figure \@ref(fig:outgroupEdge)A), we would like to keep the outgroups in the tree but ignore their branch lengths (Figure \@ref(fig:outgroupEdge)B)^[Example from: <https://groups.google.com/d/msg/bioc-ggtree/T2ySvqv351g/mHsyljvBCwAJ>]. This can be easily done by modifying the coordinates of the outgroups (Figure \@ref(fig:outgroupEdge)B). Another approach is to truncate the plot using the `r CRANpkg("ggbreak")` package (Figure \@ref(fig:outgroupEdge)C) [@ggbreak].


(ref:outgroupEdgescap) Shrink outlier long branch.

(ref:outgroupEdgecap) **Shrink outlier long branch.** Original tree (A); reduced outgroup branch length (B); truncated tree plot (C).


```{r outgroupEdge, fig.cap="(ref:outgroupEdgecap)", fig.scap="(ref:outgroupEdgescap)", fig.width=9, fig.height=5, out.width="100%", fig.keep="last"}
library(TDbook)
library(ggtree)

x <- tree_long_branch_example
m <- MRCA(x, 75, 76)
y <- groupClade(x, m)

## A
p <- p1 <- ggtree(y, aes(linetype = group)) + 
  geom_tiplab(size = 2) + 
  theme(legend.position = 'none') 

## B
p$data[p$data$node %in% c(75, 76), "x"] <- mean(p$data$x)

## C
library(ggbreak)
p2 <- p1 + scale_x_break(c(0.03, 0.09)) + hexpand(.05)

## align plot
plot_list(p1, p, p2, ncol=3, tag_levels="A")
```


### Attach a new tip to a tree {#bind-tip}

Sometimes there are known branches that are not in the tree, but we would like to have them on the tree. Another common scenario is when we have a new sequence species and would like to update the reference tree with this species by inferring its evolutionary position.

Users can use `phytools::bind.tip()` [@revell_phytools_2012] to attach a new tip to a tree. With `r CRANpkg("tidytree")`, it is easy to add an annotation to differentiate newly introduced and original branches and to reflect the uncertainty of the added branch splits off, as demonstrated in Figure \@ref(fig:bindTip). 

(ref:bindTipscap) Attaching a new tip to a tree.

(ref:bindTipcap) **Attaching a new tip to a tree.** Different line types were employed to distinguish the newly introduced tip and an error bar was added to indicate the uncertainty of the added branch position.


```{r bindTip, fig.cap="(ref:bindTipcap)", fig.scap="(ref:bindTipscap)", fig.width=6, fig.height=5, out.width="100%"}
library(phytools)
library(tidytree)
library(ggplot2)
library(ggtree)

set.seed(2019-11-18)
tr <- rtree(5)

tr2 <- bind.tip(tr, 'U', edge.length = 0.1, where = 7, position=0.15)
d <- as_tibble(tr2)
d$type <- "original"
d$type[d$label == 'U'] <- 'newly introduced'
d$sd <- NA
d$sd[parent(d, 'U')$node] <- 0.05

tr3 <- as.treedata(d)
ggtree(tr3, aes(linetype=type)) +  geom_tiplab() +
  geom_errorbarh(aes(xmin=x-sd, xmax=x+sd, y = y - 0.3), 
                linetype='dashed', height=0.1) +
  scale_linetype_manual(values = c("newly introduced" = "dashed", 
                                   "original" = "solid")) + 
  theme(legend.position=c(.8, .2)) 
``` 


### Change colors or line types of arbitrarily selected branches

If you want to color or change line types of specific branches, you only need to prepare a data frame with variables of branch setting (e.g., selected and unselected). Applying the Method 1 described in [@yu_two_2018] to map the data onto the tree will make it easy to set colors and line types (Figure \@ref(fig:btype)).  

(ref:btypescap) Change colors and line types of specific branches.

(ref:btypecap) **Change colors and line types of specific branches.** 


```{r btype, fig.cap="(ref:btypecap)", fig.scap="(ref:btypescap)", fig.width=7, fig.height=5, out.width="100%"}
set.seed(123)
x <- rtree(10)
## binary choices of colors
d <- data.frame(node=1:Nnode2(x), colour = 'black')
d[c(2,3,14,15), 2] <- "red"

## multiple choices of line types
d2 <- data.frame(node=1:Nnode2(x), lty = 1)
d2[c(2,5,13, 14), 2] <- c(2, 3, 2,4)

p <- ggtree(x) + geom_label(aes(label=node))
p %<+% d %<+% d2 + aes(colour=I(colour), linetype=I(lty))
```

Users can use the `r CRANpkg("gginnards")` package to manipulate plot elements for more complicated scenarios.

### Add an arbitrary point to a branch {#arbitrary-point}

If you want to add an arbitrary point to a branch^[<https://twitter.com/melanoidin/status/1262703932993871874>], you can use `geom_nodepoint()`, `geom_tippoint()`, or `geom_point2()` (works for both external and internal nodes) to filter selected node (the endpoint of the branch) via the `subset` aesthetic mapping and specify horizontal position by `x = x - offset` aesthetic mapping, where the offset can be an absolute value (Figure \@ref(fig:pointOnBranch)A) or in proportion to the branch length (Figure \@ref(fig:pointOnBranch)B).



(ref:pointOnBranchscap) Add an arbitrary point on a branch.

(ref:pointOnBranchcap) **Add an arbitrary point on a branch.** The position of the symbolic point can be adjusted by an absolute value (A) or in proportion to the branch length (B).


```{r pointOnBranch, fig.cap="(ref:pointOnBranchcap)", fig.scap="(ref:pointOnBranchscap)", fig.width=8, fig.height=4.5, out.width="100%"}
set.seed(2020-05-20)
x <- rtree(10)
p <- ggtree(x)

p1 <- p + geom_nodepoint(aes(subset = node == 13, x = x - .1),
                        size = 5, colour = 'firebrick', shape = 21)

p2 <- p + geom_nodepoint(aes(subset = node == 13, x = x - branch.length * 0.2),
                        size = 3, colour = 'firebrick') + 
       geom_nodepoint(aes(subset = node == 13, x = x - branch.length * 0.8),
                        size = 5, colour = 'steelblue')
plot_list(p1, p2, ncol=2, tag_levels="A")
```


## Different *X*-axis Labels for Different Facet Panels

This is not supported by `r CRANpkg("ggplot2")` in general. However, we can just draw text labels for each panel and put the labels beyond the plot panels as demonstrated in Figure \@ref(fig:xlabFacets).

(ref:xlabFacetsscap) *X*-axis titles for different facet panels.

(ref:xlabFacetscap) ***X*-axis titles for different facet panels.** 



```{r xlabFacets, fig.width=7, fig.height=5, fig.cap="(ref:xlabFacetscap)", fig.scap="(ref:xlabFacetsscap)", out.width="100%"}
library(ggtree)
library(ggplot2)
set.seed(2019-05-02)
x <- rtree(30)
p <- ggtree(x) + geom_tiplab()
d <- data.frame(label = x$tip.label, 
                value = rnorm(30))
p2 <- p + geom_facet(panel = "Dot", data = d, 
            geom = geom_point, mapping = aes(x = value)) 
            
p2 <- p2 + theme_bw() + 
    xlim_tree(5) + xlim_expand(c(-5, 5), 'Dot') 

# .panel is the internal variable used in `geom_facet` for faceting.
d <- data.frame(.panel = c('Tree', 'Dot'), 
                lab = c("Distance", "Dot Units"), 
                x=c(2.5,0), y=-2)

p2 + scale_y_continuous(limits=c(0, 31), 
                        expand=c(0,0), 
                        oob=function(x, ...) x) +
    geom_text(aes(label=lab), data=d) + 
    coord_cartesian(clip='off')  + 
    theme(plot.margin=margin(6, 6, 40, 6))
```

## Plot Something behind the Phylogeny {#faq-under-the-tree}

The `ggtree()` function plots the tree structure, and normally we add layers on top of the tree.

```{r tree_behind_box}
set.seed(1982)
x <- rtree(5)
p <- ggtree(x) + geom_hilight(node=7, alpha=1)
```

If we want the layers behind the tree layer, we can reverse the order of all the layers.

```r
p$layers <- rev(p$layers)
```

Another solution is to use `ggplot()` instead of `ggtree()` and `+ geom_tree()` to add the layer of tree structure at the correct position of the layer stack (Figure \@ref(fig:treeLayerOrder)).

```r
ggplot(x) + geom_hilight(node=7, alpha=1) + geom_tree() + theme_tree()     
```

(ref:treeLayerOrderscap) Add layers behind the tree structure.

(ref:treeLayerOrdercap) **Add layers behind the tree structure.** A layer on top of the tree structure (A). Reverse layer order of A (B). Add layer behind the tree layer (C).


```{r treeLayerOrder, echo=F, fig.width=6, fig.height=3, fig.cap="(ref:treeLayerOrdercap)", fig.scap="(ref:treeLayerOrderscap)", out.width="100%"}
g <- p
p$layers <- rev(p$layers)
cowplot::plot_grid(g, p, 
  ggplot(x) + geom_hilight(node=7, alpha=1) + geom_tree() + theme_tree(),
  ncol = 3, labels = LETTERS[1:3])     
```



## Enlarge Center Space in Circular/Fan Layout Tree {#faq-enlarge-center-space}

This question for enlarging center space in circular/fan layout tree was asked several times^[<https://groups.google.com/d/msg/bioc-ggtree/gruC4FztU8I/mwavqWCXAQAJ>, <https://groups.google.com/d/msg/bioc-ggtree/UoGQekWHIvw/ZswUUZKSGwAJ> and <https://github.com/GuangchuangYu/ggtree/issues/95>], and a published example can be found in [@barton_broad_2016]. Increasing the percentage of center white space in a circular tree is useful to avoid overlapping tip labels and to increase the readability of the tree by moving all nodes and branches further out. This can be done simply by using `xlim()` or `hexpand()` to allocate more space (Figure \@ref(fig:circular-space)A), just like in Figure \@ref(fig:layout2)G, or assigning a long root branch that is similar to the "Root Length" parameter in `r pkg_figtree` (Figure \@ref(fig:circular-space)B). 


(ref:innerspacescap) Enlarge center space in circular tree.

(ref:innerspacecap) **Enlarge center space in circular tree.** Allocate more space by `xlim` (A) or long root branch (B).



```{r circular-space, fig.width=8, fig.height=4, fig.cap="(ref:innerspacecap)", fig.scap="(ref:innerspacescap)", out.width="100%"}
set.seed(1982)
tree <- rtree(30)
plot_list(
  ggtree(tree, layout='circular') + xlim(-10, NA),
  ggtree(tree, layout='circular') + geom_rootedge(5),
  tag_levels = "A", ncol=2
)
```

## Use the Most Distant Tip from the Root as the Origin of the Timescale

The `revts()` will reverse the *x*-axis by setting the most recent tip to 0. We can use `scale_x_continuous(labels=abs)` to label *x*-axis using absolute values (Figure \@ref(fig:distantTip)).

(ref:distantTipscap) Origin of the time scale.

(ref:distantTipcap) **Origin of the time scale.** Forward: from the root to the tips (A). Backward: from the most distant tip to the root (B).


```{r distantTip, fig.cap="(ref:distantTipcap)", fig.scap="(ref:distantTipscap)", fig.width=6, fig.height=3, out.width="100%"}
tr <- rtree(10)
p <- ggtree(tr) + theme_tree2()
p2 <- revts(p) + scale_x_continuous(labels=abs)
plot_list(p, p2, ncol=2, tag_levels="A")
```

## Remove Blank Margins for Circular Layout Tree {#circular-blank}

For plots in polar coordinates, such as a circular layout tree, it is very common that extra spaces will be generated. 

If you are using `Rmarkdown`, you can set the following options for `r CRANpkg("knitr")` to remove extra white space automatically.

```r
library(knitr)
knit_hooks$set(crop = hook_pdfcrop)
opts_chunk$set(crop = TRUE)
```


Otherwise, we can use command-line tools to remove extra white space:

```shell
## for pdf
pdfcrop x.pdf

## for png
convert -trim x.png x-crop.png
```

If you want to do it in R, you can use the `r CRANpkg("magick")` package:


```r
library(magick)

x <- image_read("x.png")
## x <- image_read_pdf("x.pdf") # for PDF

image_trim(x)
```


Here is an example (Figure \@ref(fig:trimSpace)):

(ref:trimSpacescap) Trim extra white space for polar coordinates.

(ref:trimSpacecap) **Trim extra white space for polar coordinates.** Original plot (A). Trimmed version (B).


```{r trimSpace, fig.width=8.8, fig.height=4.5, fig.cap="(ref:trimSpacecap)", fig.scap="(ref:trimSpacescap)", out.width="100%"}
library(ggplot2)
library(ggtree)
library(patchwork)
library(magick)

set.seed(2021)
tr <- rtree(30)
p <- ggtree(tr, size=1, colour="purple", layout='circular')

f <- tempfile(fileext=".png")
ggsave(filename = f, plot = p, width=7, height=7)

x <- image_read(f, density=300)
y <- image_trim(x)

panel_border <- theme(panel.border=element_rect(colour='black', 
                                            fill=NA, size=2))
xx <- image_ggplot(x) + panel_border
yy <- image_ggplot(y) + panel_border

plot_list(xx, yy, tag_levels = "A", ncol=2)
``` 


## Edit Tree Graphic Details {#export-edit}


It can be hard to modify plot details for ordinary users using `r CRANpkg("ggplot2")`/`r Biocpkg("ggtree")`. We recommend using the `r CRANpkg("eoffice")` package to export `r Biocpkg("ggtree")` output to a Microsoft Office Document and edit the tree graphic in PowerPoint.


<!--chapter:end:A-app-faq.Rmd-->


\newpage


# Related Tools {#related-tools}

## MicrobiotaProcess: Convert Taxonomy Table to a `treedata` Object {#MicrobiotaProcess-taxonomy}

Taxonomy (genus, family, ...) data are widely used in microbiome or ecology. Hierarchical taxonomies are the tree-like structure that organizes items into subcategories and can be converted to a tree object (see also the [phylog object](#phylog)). The `r Biocpkg("MicrobiotaProcess")` supports converting a `taxonomyTable` object, defined in the `r Biocpkg("phyloseq")` package, to a `treedata` object, and the taxonomic hierarchical relationship can be visualized using `r Biocpkg("ggtree")` (Figure \@ref(fig:TaxaTree)). When there are taxonomy names that are [confused and missing](https://github.com/YuLab-SMU/MicrobiotaProcess/issues/14), the `as.treedata()` method for `taxonomyTable` objects will complete their upper-level taxonomic information automatically.  



(ref:TaxaToTreescap) Convert a `taxonomyTable` object to a `treedata` object. 

(ref:TaxaToTreecap) **Convert a `taxonomyTable` object to a `treedata` object.** 

```{r TaxaTree, fig.widht=8, fig.height=8, fig.cap="(ref:TaxaToTreecap)", fig.scap="ref:TaxaToTreescap"}
library(MicrobiotaProcess)
library(ggtree)

# The original kostic2012crc is a MPSE object
data(kostic2012crc)

taxa <- tax_table(kostic2012crc)
#The rownames (usually is OTUs or other features ) of the taxa will be 
# served as the tip labels if include.rownames = TRUE
tree <- as.treedata(taxa, include.rownames=TRUE)
# Or extract the taxa tree (treedata) with mp_extract_tree, because the 
# taxonomy information is stored as treedata in the MPSE class (kostic2012crc).
# tree <- kostic2012crc %>% mp_extract_tree()

ggtree(tree, layout="circular", size=0.2) +
     geom_tiplab(size=1)
```

## rtol: An R Interface to Open Tree API {#rtol}

The `r CRANpkg("rtol")` [@michonneau_rotl:_2016] is an R package to interact with the Open Tree of Life data APIs. Users can use it to query phylogenetic trees and visualize the trees with `r Biocpkg("ggtree")` to explore species relationships (Figure \@ref(fig:rotlSubtree)).

(ref:rotlSubtreescap) Get an induced subtree from the big Open Tree.

(ref:rotlSubtreecap) **Get an induced subtree from the big Open Tree.**



```{r rotlSubtree, fig.width=8, fig.height=6, fig.cap="(ref:rotlSubtreecap)", fig.scap="(ref:rotlSubtreescap)", out.width='100%'} 
## example from: https://github.com/ropensci/rotl
library(rotl)
apes <- c("Pongo", "Pan", "Gorilla", "Hoolock", "Homo")
(resolved_names <- tnrs_match_names(apes))
tr <- tol_induced_subtree(ott_ids = ott_id(resolved_names))
ggtree(tr) + geom_tiplab() + xlim(NA, 5)
```



```{r, eval = !knitr::is_latex_output(), child="ggtree-plotly.Rmd"}
```


```{r, eval = !knitr::is_latex_output(), child="ggtree-comicR.Rmd"}
```


## Print ASCII-art Rooted Tree {#ascii-tree}

```{r asciiTree, comment=NA}
library(data.tree)
tree <- rtree(10)
d <- as.data.frame(as.Node(tree))
names(d) <- NULL
print(d, row.names=FALSE)
```

It is neat to print ASCII-art of the phylogeny. Sometimes, we don't want to plot the tree, but just take a glance at the tree structure without leaving the focus from the R console. However, it is not a good idea to print the whole tree as ASCII text if the tree is large. Sometimes, we just want to look at a specific portion of the tree and its immediate relatives. In this scenario, we can use `treeio::tree_subset()` function (see [session 2.4](subsetting-tree-with-data)) to extract selected portion of a tree. Then we can print ASCII-art of the tree subset to explore the evolutionary relationship of the species of our interest in the R console.

The `r Biocpkg("ggtree")` supports parsing tip labels as emoji to create [phylomoji](#phylomoji). With the `r CRANpkg("data.tree")` and `r CRANpkg("emojifont")` packages, we can also print phylomoji as ASCII text (Figure \@ref(fig:emojidatatree)).



```{r asciiTreeEmoji, comment=NA, eval=FALSE}
library(data.tree)
library(emojifont)

tt <- '((snail,mushroom),(((sunflower,evergreen_tree),leaves),green_salad));'
tree <- read.tree(text = tt)
tree$tip.label <- emoji(tree$tip.label)
d <- as.data.frame(as.Node(tree))
names(d) <- NULL
print(d, row.names=FALSE)
```


(ref:emojidatatreescap) Print phylomoji as ASCII text.

(ref:emojidatatreecap) **Print phylomoji as ASCII text.**



```{r emojidatatree, echo=FALSE, fig.cap="(ref:emojidatatreecap)", fig.scap="(ref:emojidatatreescap)", out.width='100%'} 
knitr::include_graphics("img/data-tree-emojim.png")
```

Another way to print ASCII-art of phylogeny is to use the `ascii()` device defined in the `r pkg_devout` package. Here is an example:

```{r devout-ascii, comment=NA}
library(devout)
ascii(width=80)
ggtree(rtree(5))
invisible(dev.off())
```


## Zoom in on the Selected Portion {#facet-zoom}


In addition to using `viewClade()` function, users can use the `r CRANpkg("ggforce")` package to zoom in on a selected clade (Figure \@ref(fig:facetZoom)).
 

(ref:facetZoomscap) Zoom in on a selected clade.

(ref:facetZoomcap) **Zoom in on a selected clade.**


```{r facetZoom, fig.width=6, fig.height=4, fig.cap="(ref:facetZoomcap)", fig.scap="(ref:facetZoomscap)"}
set.seed(2019-08-05)
x <- rtree(30)
nn <- tidytree::offspring(x, 43, self_include=TRUE)
ggtree(x) + ggforce::facet_zoom(xy = node %in% nn)
```


## Tips for Using `ggtree` with `ggimage` {#ggimage-tips}

The `r Biocpkg("ggtree")` supports annotating a tree with silhouette images via the `r CRANpkg("ggimage")` package. The `r CRANpkg("ggimage")` provides the grammar of graphic syntax to work with image files. It allows processing images on the fly via the `image_fun` parameter, which accepts a function to process `magick-image` objects (Figure \@ref(fig:ggimagebg)). The `r CRANpkg("magick")` package provides several functions, and these functions can be combined to perform a particular task.

### Example 1: Remove background of images {#ggimage-rm-image-bg}

(ref:ggimagebgscap) Remove image background.

(ref:ggimagebgcap) **Remove image background.** Plotting silhouette images on a phylogenetic tree with background not removed (A) and removed (B).


```{r ggimagebg, fig.width=8, fig.height=4, fig.cap="(ref:ggimagebgcap)", fig.scap="(ref:ggimagebgscap)", out.width='100%'} 
library(ggimage)

imgdir <- system.file("extdata/frogs", package = "TDbook")

set.seed(1982)
x <- rtree(5)
p <- ggtree(x) + theme_grey()
p1 <- p + geom_nodelab(image=paste0(imgdir, "/frog.jpg"), 
                        geom="image", size=.12) + 
      ggtitle("original image")
p2 <- p + geom_nodelab(image=paste0(imgdir, "/frog.jpg"), 
            geom="image", size=.12,
            image_fun= function(.) magick::image_transparent(., "white")) + 
      ggtitle("image with background removed")
plot_grid(p1, p2, ncol=2)
```

### Example 2: Plot tree on a background image {#ggimage-bgimage}

The `geom_bgimage()` adds a layer of the image and puts the layer to the bottom of the layer stack. It is a normal layer and doesn't change the structure of the output `ggtree` object. Users can add annotation layers without the background image layer (Figure \@ref(fig:bgimage)).

(ref:bgimagescap) Use an image file as a tree background.

(ref:bgimagecap) **Use an image file as a tree background.**


```{r bgimage, fig.width=6, fig.height=4, fig.cap="(ref:bgimagecap)", fig.scap="(ref:bgimagescap)"} 
ggtree(rtree(20), size=1.5, color="white") + 
  geom_bgimage('img/blackboard.jpg') + 
  geom_tiplab(color="white", size=5, family='xkcd')
```


## Run ggtree in Jupyter Notebook

If you have [Jupyter notebook](https://jupyter.org/) installed on your system, you can install [IRkernel](https://irkernel.github.io/) with the following command in R:

```r
install.packages("IRkernel")
IRkernel::installspec()
```

Then you can use `r Biocpkg("ggtree")` and other R packages in the Jupyter notebook (Figure \@ref(fig:jupyter)). Here is a screenshot of recreating Figure \@ref(fig:phylomoji1) in the Jupyter notebook.

(ref:jupyterscap) ggtree in Jupyter notebook.

(ref:jupytercap) **ggtree in Jupyter notebook.** Running ggtree in Jupyter notebook via R kernel. 


```{r jupyter, echo=F, fig.cap="(ref:jupytercap)", fig.scap="(ref:jupyterscap)", out.width='100%'}
## htmltools::includeHTML("img/ggtree_jupyter.html")
knitr::include_graphics("img/Screenshot_2019-06-24_ggtree-jupyter.png")
```




<!--chapter:end:A-app-tools.Rmd-->

\newpage


# Figures and Tables



```{r facet-geom, echo=FALSE,results='asis'}

x <- "ggalt\tgeom_dumbbell\tcreates dumbbell charts\n
ggbio\tgeom_alignment\tshows interval data as alignment\n
ggfittext\tgeom_fit_text\tshrinks, grows, or wraps text to fit inside a defined rectangular area\n
gggenes\tgeom_gene_arrow\tdraws genes as arrows\n
ggimage\tgeom_image\tvisualizes image files\n
ggimage\tgeom_phylopic\tqueries image files from the PhyloPic database and visualizes them\n
ggplot2\tgeom_hline\tadds horizontal lines\n
ggplot2\tgeom_jitter\tadds a small amount of random variation to the location of each point\n
ggplot2\tgeom_label\tdraws a rectangle behind the text\n
ggplot2\tgeom_point\tcreates scatterplots\n
ggplot2\tgeom_raster\ta high-performance special case for all the tiles that are the same size\n
ggplot2\tgeom_rect\tdraws rectangle by using the locations of the four corners\n
ggplot2\tgeom_segment\tdraws a straight line between points\n
ggplot2\tgeom_spoke\ta polar parameterization of `geom_segment()'\n
ggplot2\tgeom_text\tadds text to the plot\n
ggplot2\tgeom_tile\tdraws rectangle by using the center of the tile and its size\n
ggplot2\tgeom_vline\tadds vertical lines\n
ggrepel\tgeom_text_repel\tadds text to the plot. The text labels repel away from each other and away from the data points\n
ggrepel\tgeom_label_repel\tdraws a rectangle underneath the text. The text labels repel away from each other and away from the data points\n
ggridges\tgeom_density_ridges\tarranges multiple density plots in a staggered fashion\n
ggridges\tgeom_density_ridges_gradient\tworks just like `geom_density_ridges' except that the `fill' aesthetic can vary along the *x*-axis\n
ggridges\tgeom_ridgeline\tplots the sum of the `y' and `height' aesthetics vs. `x', filling the area between `y' and `y + height' with a color\n
ggridges\tgeom_ridgeline_gradient\tworks just like `geom_ridgeline' except that the `fill' aesthetic can vary along the *x*-axis\n
ggstance\tgeom_barh\thorizontal version of `geom_bar()'\n
ggstance\tgeom_boxploth\thorizontal version of `geom_boxplot()'\n
ggstance\tgeom_crossbarh\thorizontal version of `geom_crossbar()'\n
ggstance\tgeom_errorbarh\thorizontal version of `geom_errorbarh()'\n
ggstance\tgeom_histogramh\thorizontal version of `geom_histogram()'\n
ggstance\tgeom_linerangeh\thorizontal version of `geom_linerange()'\n
ggstance\tgeom_pointrangeh\thorizontal version of `geom_pointrange()'\n
ggstance\tgeom_violinh\thorizontal version of `geom_violin()'\n
ggtree\tgeom_motif\tdraws aligned motifs\n
"

if (!knitr::is_latex_output()) {
    x <- gsub("`", "'", x)
} 

xx <- strsplit(x, "\n\n")[[1]]
y <- strsplit(xx, "\t") %>% do.call("rbind", .)
y <- as.data.frame(y)
colnames(y) <- c("Package", "Geom Layer", "Description")

require(kableExtra)

if (knitr::is_latex_output()) {
  caption = "Geometric layers that supported by, `geom\\textunderscore facet()'"
} else {
  caption = "Geometric layers that supported by `geom_facet()'"
}


knitr::kable(y, caption=caption, booktabs = T) %>% 
  collapse_rows(columns = 1, latex_hline = "major", valign ="top") %>%
  kable_styling(latex_options = c("striped", "scale_down", "hold_position"),
                bootstrap_options = c("striped", "hover")) %>% landscape
```



```{r tree-objects, echo=FALSE,results='asis'}
x <- tibble::tribble(
    ~Package, ~Object, ~Description,
    "ape", "phylo", "basic phylogenetic tree structure",
    "ape", "multiPhylo", "list of phylo objects",
    "ade4", "phylog", "tree structure for ecological data",
    "phylobase", "phylo4", "S4 version of phylo object",
    "phylobase", "phylo4d", "extend phylo4 with trait data",
    "phyloseq", "phyloseq", "phylogenetic tree with microbiome data",
    "tidytree", "tbl_tree", "phylogenetic tree as a tidy data frame",
    "treeio", "treedata", "phylogenetic tree with heterogeneous associated data",
    "treeio", "jplace", "treedata object with placement information",
    "stats", "hclust", "hierarchical cluster result",
    "stats", "dendrogram", "hierarchical clustering or classification/regression tree",
    "cluster", "agnes", "agglomerative hierarchical clustering",
    "cluster", "diana", "divisive hierarchical clustering",
    "cluster", "twins", "agglomerative or divisive (polythetic) hierarchical clustering",
    "pvclust", "pvclust", "hierarchical clustering with p-values calculated by multiscale bootstrap resampling",
    "igraph", "igraph", "network (currently only tree graph supported)"
)


y <- as.data.frame(x)

require(kableExtra)


caption = "Tree-like objects supported by ggtree"



knitr::kable(y, caption=caption, booktabs = T) %>% 
  collapse_rows(columns = 1, latex_hline = "major", valign ="top") %>%
  kable_styling(latex_options = c("striped", "scale_down"),
                bootstrap_options = c("striped", "hover")) #%>% landscape

```


<!--
#``` r treeio, echo=F, message=FALSE}
library(kableExtra)
ff <- matrix(c(
  "read.beast",  "parsing output of BEAST",
  "read.codeml", "parsing output of CodeML (rst and mlc files)",
  "read.codeml_mlc", "parsing mlc file (output of CodeML)",
  "read.hyphy", "parsing output of HYPHY",
  "read.jplace", "parsing jplace file including output of EPA and pplacer",
  "read.nhx", "parsing NHX file including output of PHYLDOG and RevBayes",
  "read.paml_rst", "parsing rst file (output of BaseML or CodeML)",
  "read.phylip", "parsing phylip file",
  "read.phyloT", "parsing output of phyloT (http://phylot.biobyte.de/)",
  "read.r8s", "parsing output of r8s",
  "read.raxml", "parsing output of RAxML",
  "Nnode", "get number of internal nodes",
  "Nnode2", "get number of all nodes (including internal and external nodes)",
  "Ntip", "get number of all tips (external nodes)",
  "as.phylo", "convert tree object to phylo object",
  "as.treedata", "convert tree object to treedata object",
  "drop.tip", "remove tips in a tree",
  "get.fields", "get available tree attributes stored in tree object",
  "get.placements", "get placement result of jplace object",
  "get.subs", "get substitution by comparing parent node and child node",
  "get.tipseq", "get tip sequences",
  "get.treetext", "get newick text of a tree object",
  "groupClade", "add clade grouping information to tree object",
  "groupOTU", "grouping OTUs by tracing back to most recent commond ancestor",
  "merge_tree", "merging tree objects into one",
  "write.jpace", "write tree with associated annotation data to a jplace file"
  ), ncol=2, byrow=TRUE)
ff <- as.data.frame(ff)
colnames(ff) <- c("Function", "Description")
knitr::kable(ff, caption = "Functions defined in treeio.", booktabs = T) #%>%
  #kable_styling(latex_options = c("striped", "hold_position"), full_width = T)
```


-->


```{r, child="publications.md"}
```



```{r, eval = FALSE, child="session-info.Rmd"}
```



<!--chapter:end:A-app-fig-tab.Rmd-->

\printindex
\backmatter

\newpage

# References {-}





<!--chapter:end:B-references.Rmd-->

